diff --git a/qtbase/src/plugins/platforms/cocoa/qcocoamenuitem.mm b/qtbase/src/plugins/platforms/cocoa/qcocoamenuitem.mm
index 21f2b4de85155fe64db91ef28005fed115f32387..c9f5ef057c342c0f60be6ebed3bdaa6abc1fe2d9 100644
--- a/qtbase/src/plugins/platforms/cocoa/qcocoamenuitem.mm
+++ b/qtbase/src/plugins/platforms/cocoa/qcocoamenuitem.mm
@@ -224,7 +224,7 @@ NSMenuItem *QCocoaMenuItem::sync()
 {
     if (m_isSeparator != [m_native isSeparatorItem]) {
         [m_native release];
-        if (m_isSeparator) {
+        if (m_isSeparator && m_text.isEmpty()) {
             m_native = [[NSMenuItem separatorItem] retain];
             [m_native setTag:reinterpret_cast<NSInteger>(this)];
         } else
@@ -329,22 +329,57 @@ NSMenuItem *QCocoaMenuItem::sync()
 
     QString finalString = QPlatformTheme::removeMnemonics(text);
     bool useAttributedTitle = false;
+    NSFont *customMenuFont = NULL;
+    NSMutableArray *keys = [NSMutableArray arrayWithCapacity:1];
+    NSMutableArray *objects = [NSMutableArray arrayWithCapacity:1];
     // Cocoa Font and title
     if (m_font.resolve()) {
-        NSFont *customMenuFont = [NSFont fontWithName:m_font.family().toNSString()
+        customMenuFont = [NSFont fontWithName:m_font.family().toNSString()
                                   size:m_font.pointSize()];
         if (customMenuFont) {
-            NSArray *keys = [NSArray arrayWithObjects:NSFontAttributeName, nil];
-            NSArray *objects = [NSArray arrayWithObjects:customMenuFont, nil];
-            NSDictionary *attributes = [NSDictionary dictionaryWithObjects:objects forKeys:keys];
-            NSAttributedString *str = [[[NSAttributedString alloc] initWithString:finalString.toNSString()
-                                     attributes:attributes] autorelease];
-            [m_native setAttributedTitle: str];
+            [keys addObject:NSFontAttributeName];
+            [objects addObject:customMenuFont];
             useAttributedTitle = true;
         }
     }
+    if (m_isSeparator && !m_text.isEmpty()) {
+        if (!customMenuFont) {
+            // make sure we use the correct font
+            customMenuFont = [NSFont menuFontOfSize:0];
+            if (customMenuFont) {
+                [keys addObject:NSFontAttributeName];
+                [objects addObject:customMenuFont];
+            }
+        }
+        // the item text will be underlined over a bit more than its actual text
+        finalString = QStringLiteral("___") + finalString + QStringLiteral("___");
+        [keys addObject:NSUnderlineStyleAttributeName];
+        [objects addObject:[NSNumber numberWithInt:NSUnderlineStyleSingle|NSUnderlinePatternSolid]];
+        // the text will be drawn with a slightly heavier stroke:
+        [keys addObject:NSStrokeWidthAttributeName];
+        [objects addObject:[NSNumber numberWithDouble:-1.5]];
+        // expand the text ever so slightly:
+        [keys addObject:NSExpansionAttributeName];
+        [objects addObject:[NSNumber numberWithDouble:0.05]];
+        // add some additional vertical space:
+        [keys addObject:NSBaselineOffsetAttributeName];
+        [objects addObject:[NSNumber numberWithDouble:-5]];
+        // and align it appropriately for a header:
+        NSMutableParagraphStyle *paragraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy];
+        [paragraphStyle setAlignment:NSCenterTextAlignment];
+        [keys addObject:NSParagraphStyleAttributeName];
+        [objects addObject:paragraphStyle];
+        [paragraphStyle release];
+        useAttributedTitle = true;
+        setEnabled(false);
+    }
     if (!useAttributedTitle) {
        [m_native setTitle:finalString.toNSString()];
+    } else {
+        NSDictionary *attributes = [NSDictionary dictionaryWithObjects:objects forKeys:keys];
+        NSAttributedString *str = [[[NSAttributedString alloc] initWithString:finalString.toNSString()
+                                 attributes:attributes] autorelease];
+        [m_native setAttributedTitle: str];
     }
 
 #ifndef QT_NO_SHORTCUT
diff --git a/qtbase/src/widgets/widgets/qmenu.cpp b/qtbase/src/widgets/widgets/qmenu.cpp
index 36a8a96b79e6c56ffbc320313376778514930b35..b4bd597bb3f768c0d54d92273c20679bf0e3bc6f 100644
--- a/qtbase/src/widgets/widgets/qmenu.cpp
+++ b/qtbase/src/widgets/widgets/qmenu.cpp
@@ -1852,6 +1852,52 @@ QAction *QMenu::addSeparator()
     return action;
 }
 
+#ifdef Q_OS_MACOS
+static bool isNativeMenubarMenu(const QMenu *m)
+{   bool ret = false;
+    QSet<const QMenu*> checkList;
+    if (m->menuAction()) {
+        QAction *mAct = m->menuAction();
+        foreach (const QWidget *w, mAct->associatedWidgets()) {
+            if (w == m) {
+                goto done;
+            }
+            if (const QMenuBar *mb = qobject_cast<const QMenuBar*>(w)) {
+                ret = mb->isNativeMenuBar();
+                goto done;
+            }
+            else if (const QMenu *mm = qobject_cast<const QMenu*>(w)) {
+                if (checkList.contains(mm)) {
+                    continue;
+                }
+                checkList += mm;
+                if (isNativeMenubarMenu(mm)) {
+                    ret = true;
+                    goto done;
+                }
+            }
+        }
+    }
+done:;
+    return ret;
+}
+#endif
+
+static bool qMenuRendersSections(const QMenu *m)
+{
+    bool ret = false;
+    if (m) {
+#ifdef Q_OS_MACOS
+        // on Mac menus in the native menubar will never render sections properly,
+        // regardless of the style in use
+        ret = m->style()->styleHint(QStyle::SH_Menu_SupportsSections) || isNativeMenubarMenu(m);
+#else
+        ret = m->style()->styleHint(QStyle::SH_Menu_SupportsSections);
+#endif
+    }
+    return ret;
+}
+
 /*!
     \since 5.1
 
@@ -1862,7 +1908,8 @@ QAction *QMenu::addSeparator()
 
     The rendering of the hint is style and platform dependent. Widget
     styles can use the text information in the rendering for sections,
-    or can choose to ignore it and render sections like simple separators.
+    or can choose to ignore it and render sections like simple separators,
+    depending on whether the platform supports texted separators.
 
     QMenu takes ownership of the returned QAction.
 
@@ -1871,7 +1918,18 @@ QAction *QMenu::addSeparator()
 QAction *QMenu::addSection(const QString &text)
 {
     QAction *action = new QAction(text, this);
+    if (!qMenuRendersSections(this)) {
+        // add the text item without turning it into a separator first
+        // but deactivated, also to make it visually distinct
+        action->setEnabled(false);
+        action->setMenuRole(QAction::NoRole);
+        addAction(action);
+        // create a 2nd action that will be returned and have the expected properties
+        // but show up as a simple separator on this platform
+        action = new QAction(text, this);
+    }
     action->setSeparator(true);
+    action->setMenuRole(QAction::NoRole);
     addAction(action);
     return action;
 }
@@ -1886,7 +1944,8 @@ QAction *QMenu::addSection(const QString &text)
 
     The rendering of the hints is style and platform dependent. Widget
     styles can use the text and icon information in the rendering for sections,
-    or can choose to ignore them and render sections like simple separators.
+    or can choose to ignore them and render sections like simple separators,
+    depending on whether the platform supports texted separators.
 
     QMenu takes ownership of the returned QAction.
 
@@ -1895,7 +1954,18 @@ QAction *QMenu::addSection(const QString &text)
 QAction *QMenu::addSection(const QIcon &icon, const QString &text)
 {
     QAction *action = new QAction(icon, text, this);
+    if (!qMenuRendersSections(this)) {
+        // add the text item without turning it into a separator first
+        // but deactivated, also to make it visually distinct
+        action->setEnabled(false);
+        action->setMenuRole(QAction::NoRole);
+        addAction(action);
+        // create a 2nd action that will be returned and have the expected properties
+        // but show up as a simple separator on this platform
+        action = new QAction(icon, text, this);
+    }
     action->setSeparator(true);
+    action->setMenuRole(QAction::NoRole);
     addAction(action);
     return action;
 }
