diff --git a/qtbase/src/corelib/tools/qregexp.cpp b/qtbase/src/corelib/tools/qregexp.cpp
index 96ddca56afab297ebeac889af0cb02b62587559b..791851efd99e415c28932e814cc893093b18d034 100644
--- a/qtbase/src/corelib/tools/qregexp.cpp
+++ b/qtbase/src/corelib/tools/qregexp.cpp
@@ -39,6 +39,7 @@
 
 #include "qregexp.h"
 
+#include "qobject.h"
 #include "qalgorithms.h"
 #include "qbitarray.h"
 #include "qcache.h"
@@ -52,6 +53,8 @@
 #include "qstringlist.h"
 #include "qstringmatcher.h"
 #include "qvector.h"
+#include "qcoreapplication.h"
+#include "qsemaphore.h"
 
 #include <limits.h>
 #include <algorithm>
@@ -3813,17 +3816,92 @@ struct QRegExpPrivate
 };
 
 #if !defined(QT_NO_REGEXP_OPTIM)
-typedef QCache<QRegExpEngineKey, QRegExpEngine> EngineCache;
+class EngineCache : public QCache<QRegExpEngineKey, QRegExpEngine>
+#if !defined(QT_NO_OBJECT) && !defined(QT_BOOTSTRAPPED)
+    , public QObject
+#endif
+{
+public:
+    class Locker : public QMutexLocker
+    {
+    public:
+        Locker(EngineCache *cache)
+            : QMutexLocker(&cache->m_mutex)
+            , m_cache(cache)
+        {
+            m_cache->m_sem.acquire();
+        }
+        ~Locker()
+        {
+            m_cache->m_sem.release();
+        }
+        EngineCache *m_cache;
+    };
+
+    EngineCache()
+        : QCache<QRegExpEngineKey, QRegExpEngine>()
+    {
+#if !defined(QT_NO_OBJECT) && !defined(QT_BOOTSTRAPPED)
+        if (QCoreApplication::instance()) {
+            connect(QCoreApplication::instance(), &QCoreApplication::aboutToQuit, this, &EngineCache::takeDown);
+        }
+#endif
+        // create the number of required resources:
+        m_sem.release(1);
+    }
+
+    bool isAvailable(bool forAdding)
+    {
+        if (!m_isAvailable) {
+            if (forAdding) {
+                qDebug() << "globalEngineCache: new items can no longer be added";
+            } else {
+                qDebug() << "globalEngineCache has already been emptied";
+            }
+        }
+        return m_isAvailable;
+    }
+
+public Q_SLOTS:
+    // take down the cache when the application is about to quit. Emptying the
+    // cache at this time is our best bet to get rid of any entries that reference
+    // QStrings which belong to dynamically loaded code. Deleting such entries after
+    // unloading the code would cause a crash or worse, execution of unknown code.
+    // Note that this is only protects against code (plugins) that is unloaded automatic
+    // during shutdown.
+    void takeDown()
+    {
+        // take the cache offline
+        m_isAvailable = false;
+        // use the semaphore to ensure no one else is using the cache
+        // but wouldn't this deadlock us if the current thread is already
+        // accessing the cache?
+        m_sem.acquire();
+        qDebug() << "globalEngineCache discarding" << size() << "entries";
+        clear();
+        if (!isEmpty()) {
+            qWarning() << "globalEngineCache wasn't emptied completely; remain:" << size();
+        }
+        m_sem.release();
+    }
+
+    // mutex for syncing access from different threads
+    QBasicMutex m_mutex;
+    // semaphore for avoiding concurrent cache access by the same thread.
+    QSemaphore m_sem;
+
+private:
+    bool m_isAvailable = true;
+};
 Q_GLOBAL_STATIC(EngineCache, globalEngineCache)
-static QBasicMutex globalEngineCacheMutex;
 #endif // QT_NO_REGEXP_OPTIM
 
 static void derefEngine(QRegExpEngine *eng, const QRegExpEngineKey &key)
 {
     if (!eng->ref.deref()) {
 #if !defined(QT_NO_REGEXP_OPTIM)
-        if (globalEngineCache()) {
-            QMutexLocker locker(&globalEngineCacheMutex);
+        if (globalEngineCache() && globalEngineCache()->isAvailable(true)) {
+            EngineCache::Locker locker(globalEngineCache());
             QT_TRY {
                 globalEngineCache()->insert(key, eng, 4 + key.pattern.length() / 4);
             } QT_CATCH(const std::bad_alloc &) {
@@ -3844,8 +3922,8 @@ static void prepareEngine_helper(QRegExpPrivate *priv)
 {
     bool initMatchState = !priv->eng;
 #if !defined(QT_NO_REGEXP_OPTIM)
-    if (!priv->eng && globalEngineCache()) {
-        QMutexLocker locker(&globalEngineCacheMutex);
+    if (!priv->eng && globalEngineCache() && globalEngineCache()->isAvailable(false)) {
+        EngineCache::Locker locker(globalEngineCache());
         priv->eng = globalEngineCache()->take(priv->engineKey);
         if (priv->eng != 0)
             priv->eng->ref.ref();
