diff --git a/qtbase/src/corelib/tools/qregexp.cpp b/qtbase/src/corelib/tools/qregexp.cpp
index 96ddca56afab297ebeac889af0cb02b62587559b..9834c0770a71d26cada174c38edf3364672194d9 100644
--- a/qtbase/src/corelib/tools/qregexp.cpp
+++ b/qtbase/src/corelib/tools/qregexp.cpp
@@ -39,6 +39,7 @@
 
 #include "qregexp.h"
 
+#include "qobject.h"
 #include "qalgorithms.h"
 #include "qbitarray.h"
 #include "qcache.h"
@@ -52,6 +53,7 @@
 #include "qstringlist.h"
 #include "qstringmatcher.h"
 #include "qvector.h"
+#include "qcoreapplication.h"
 
 #include <limits.h>
 #include <algorithm>
@@ -3813,17 +3815,80 @@ struct QRegExpPrivate
 };
 
 #if !defined(QT_NO_REGEXP_OPTIM)
-typedef QCache<QRegExpEngineKey, QRegExpEngine> EngineCache;
+class EngineCache : public QCache<QRegExpEngineKey, QRegExpEngine>
+#ifndef QT_BOOTSTRAPPED
+    , public QObject
+#endif
+{
+// #ifndef QT_BOOTSTRAPPED
+//     Q_OBJECT
+// #endif
+public:
+    class Locker : public QMutexLocker
+    {
+    public:
+        Locker(EngineCache *cache)
+            : QMutexLocker(&cache->m_mutex)
+        {}
+    };
+
+    EngineCache()
+        : QCache<QRegExpEngineKey, QRegExpEngine>()
+    {
+#ifndef QT_BOOTSTRAPPED
+        if (QCoreApplication::instance()) {
+            connect(QCoreApplication::instance(), &QCoreApplication::aboutToQuit, this, &EngineCache::takeDown);
+        }
+#endif
+    }
+
+    bool isAvailable(bool forAdding)
+    {
+        if (!m_isAvailable) {
+            if (forAdding) {
+                qDebug() << "globalEngineCache: new items can no longer be added";
+            } else {
+                qDebug() << "globalEngineCache has already been emptied";
+            }
+        }
+        return m_isAvailable;
+    }
+
+public Q_SLOTS:
+    // take down the cache when the application is about to quit. Emptying the
+    // cache at this time is our best bet to get rid of any entries that reference
+    // QStrings which belong to dynamically loaded code. Deleting such entries after
+    // unloading the code would cause a crash or worse, execution of unknown code.
+    // Note that this is only protects against code (plugins) that is unloaded automatic
+    // during shutdown.
+    void takeDown()
+    {
+        // take the cache offline
+        m_isAvailable = false;
+        qDebug() << "globalEngineCache discarding" << size() << "entries";
+        m_mutex.lock();
+        clear();
+        if (!isEmpty()) {
+            qWarning() << "globalEngineCache wasn't emptied completely; remain:" << size();
+        }
+        m_mutex.unlock();
+    }
+
+    // mutex for syncing access from different threads
+    QBasicMutex m_mutex;
+
+private:
+    bool m_isAvailable = true;
+};
 Q_GLOBAL_STATIC(EngineCache, globalEngineCache)
-static QBasicMutex globalEngineCacheMutex;
 #endif // QT_NO_REGEXP_OPTIM
 
 static void derefEngine(QRegExpEngine *eng, const QRegExpEngineKey &key)
 {
     if (!eng->ref.deref()) {
 #if !defined(QT_NO_REGEXP_OPTIM)
-        if (globalEngineCache()) {
-            QMutexLocker locker(&globalEngineCacheMutex);
+        if (globalEngineCache() && globalEngineCache()->isAvailable(true)) {
+            EngineCache::Locker locker(globalEngineCache());
             QT_TRY {
                 globalEngineCache()->insert(key, eng, 4 + key.pattern.length() / 4);
             } QT_CATCH(const std::bad_alloc &) {
@@ -3844,8 +3909,8 @@ static void prepareEngine_helper(QRegExpPrivate *priv)
 {
     bool initMatchState = !priv->eng;
 #if !defined(QT_NO_REGEXP_OPTIM)
-    if (!priv->eng && globalEngineCache()) {
-        QMutexLocker locker(&globalEngineCacheMutex);
+    if (!priv->eng && globalEngineCache() && globalEngineCache()->isAvailable(false)) {
+        EngineCache::Locker locker(globalEngineCache());
         priv->eng = globalEngineCache()->take(priv->engineKey);
         if (priv->eng != 0)
             priv->eng->ref.ref();
@@ -4601,3 +4666,7 @@ QDebug operator<<(QDebug dbg, const QRegExp &r)
 #endif
 
 QT_END_NAMESPACE
+
+// #ifndef QT_BOOTSTRAPPED
+// #include "moc_qregexp.cpp"
+// #endif
