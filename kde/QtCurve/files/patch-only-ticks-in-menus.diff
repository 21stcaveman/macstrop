diff --git qt5/style/qtcurve_api.cpp qt5/style/qtcurve_api.cpp
index b8535da..6080e12 100644
--- qt5/style/qtcurve_api.cpp
+++ qt5/style/qtcurve_api.cpp
@@ -3040,13 +3040,14 @@ Style::drawControl(ControlElement element, const QStyleOption *option,
                     checkcol = menuItem->maxIconWidth;
                 }
             } else {
+                bool onlyTicksInMenu = true;
                 // Check
                 QRect checkRect(r.left() + 3, r.center().y() - 6,
                                 opts.crSize, opts.crSize);
                 checkRect = visualRect(menuItem->direction, menuItem->rect,
                                        checkRect);
                 if (checkable) {
-                    if ((menuItem->checkType &
+                    if (!onlyTicksInMenu && (menuItem->checkType &
                          QStyleOptionMenuItem::Exclusive) &&
                         menuItem->icon.isNull()) {
                         QStyleOptionButton button;
@@ -3065,7 +3066,7 @@ Style::drawControl(ControlElement element, const QStyleOption *option,
                             if (checked)
                                 button.state |= State_On;
                             button.palette = palette;
-                            drawPrimitive(PE_IndicatorCheckBox, &button,
+                            drawPrimitive(PE_IndicatorMenuCheckMark, &button,
                                           painter, widget);
                         } else if (checked) {
                             int iconSize = qMax(menuItem->maxIconWidth, 20);
@@ -3078,9 +3079,9 @@ Style::drawControl(ControlElement element, const QStyleOption *option,
                             sunkenRect = visualRect(menuItem->direction,
                                                     menuItem->rect, sunkenRect);
                             opt.state = menuItem->state;
-                            opt.state |= State_Raised | State_Horizontal;
-                            if (checked)
-                                opt.state |= State_On;
+                            opt.state |= State_Raised | State_Horizontal | State_On;
+//                             if (checked)
+//                                 opt.state |= State_On;
                             drawLightBevel(painter, sunkenRect, &opt, widget,
                                            ROUNDED_ALL,
                                            getFill(&opt, m_buttonCols),
diff --git qt5/style/qtcurve_primitive.cpp qt5/style/qtcurve_primitive.cpp
index a8a2bed..c5cee26 100644
--- qt5/style/qtcurve_primitive.cpp
+++ qt5/style/qtcurve_primitive.cpp
@@ -1658,6 +1658,8 @@ Style::drawPrimitiveIndicatorCheckBox(PrimitiveElement element,
                                  State_Selected));
     int crSize = opts.crSize + (doEtch ? 2 : 0);
     QRect rect(r.x(), r.y() + (view ? -1 : 0), crSize, crSize);
+    // render checkable menu items with only a tick; should become an option
+    bool onlyTicksInMenu = menu;
 
     // For OO.o 3.2 need to fill widget background!
     if (isOO) {
@@ -1675,7 +1677,8 @@ Style::drawPrimitiveIndicatorCheckBox(PrimitiveElement element,
         if (r == QRect(0, 0, 15, 15)) {
             rect.adjust(-1, -1, -1, -1);
         }
-    } else {
+    } else if (!onlyTicksInMenu) {
+        // don't do this when rendering a regular menu so we get just a tick
         if (isOO && r == QRect(0, 0, opts.crSize, opts.crSize)) {
             rect.adjust(0, -1, 0, -1);
         }
@@ -1762,12 +1765,20 @@ Style::drawPrimitiveIndicatorCheckBox(PrimitiveElement element,
                        WIDGET_CHECKBOX);
             painter->setRenderHint(QPainter::Antialiasing, QPAINTER_ANTIALIAS_MAYBE_ON);
         }
+    } else {
+        // only tickmarks (= without the box) in menu; adjust its horizontal position
+        rect.adjust(6, 0, 0, 0);
     }
     if (state & State_On || selectedOOMenu) {
+        bool xCheck = opts.xCheck;
+        if (onlyTicksInMenu) {
+            opts.xCheck = false;
+        }
         QPixmap *pix = getPixmap(checkRadioCol(option), PIX_CHECK, 1.0);
 
         painter->drawPixmap(rect.center().x() - pix->width() / 2,
                             rect.center().y() - pix->height() / 2, *pix);
+        opts.xCheck = xCheck;
     } else if (state & State_NoChange) {
         // tri-state
         int x(rect.center().x()), y(rect.center().y());
diff --git qt4/style/qtcurve.cpp qt4/style/qtcurve.cpp
index 951ec1a..bdbe2e1 100644
--- qt4/style/qtcurve.cpp
+++ qt4/style/qtcurve.cpp
@@ -4315,6 +4315,8 @@ void Style::drawPrimitive(PrimitiveElement element, const QStyleOption *option,
                                 ((State_Sunken|State_Enabled)==state || (State_Sunken|State_Enabled|State_Selected)==state));
             int   crSize(opts.crSize+(doEtch ? 2 : 0));
             QRect rect(r.x(), r.y()+(view ? -1 : 0), crSize, crSize);
+            // render checkable menu items with only a tick; should become an option
+            bool onlyTicksInMenu = menu;
 
             painter->save();
 
@@ -4332,7 +4334,7 @@ void Style::drawPrimitive(PrimitiveElement element, const QStyleOption *option,
                 if(r==QRect(0, 0, 15, 15))
                     rect.adjust(-1, -1, -1, -1);
             }
-            else
+            else if (!onlyTicksInMenu)
             {
                 if(isOO && r==QRect(0, 0, opts.crSize, opts.crSize))
                     rect.adjust(0, -1, 0, -1);
@@ -4411,12 +4413,24 @@ void Style::drawPrimitive(PrimitiveElement element, const QStyleOption *option,
                     drawBorder(painter, rect, option, ROUNDED_ALL, use, WIDGET_CHECKBOX);
                 }
             }
+            else
+            {
+                // only tickmarks (= without the box) in menu; adjust its horizontal position
+                rect.adjust(6, 0, 0, 0);
+            }
+
 
             if(state&State_On || selectedOOMenu)
             {
+                bool xCheck = opts.xCheck;
+                if (onlyTicksInMenu)
+                {
+                    opts.xCheck = false;
+                }
                 QPixmap *pix(getPixmap(checkRadioCol(option), PIX_CHECK, 1.0));
 
                 painter->drawPixmap(rect.center().x()-(pix->width()/2), rect.center().y()-(pix->height()/2), *pix);
+                opts.xCheck = xCheck;
             }
             else if (state&State_NoChange)    // tri-state
             {
@@ -6141,12 +6155,13 @@ void Style::drawControl(ControlElement element, const QStyleOption *option, QPai
                 }
                 else
                 {
+                    bool onlyTicksInMenu = true;
                     // Check
                     QRect checkRect(r.left() + 3, r.center().y() - 6, opts.crSize, opts.crSize);
                     checkRect = visualRect(menuItem->direction, menuItem->rect, checkRect);
                     if (checkable)
                     {
-                        if ((menuItem->checkType & QStyleOptionMenuItem::Exclusive) && menuItem->icon.isNull())
+                        if (!onlyTicksInMenu && (menuItem->checkType & QStyleOptionMenuItem::Exclusive) && menuItem->icon.isNull())
                         {
                             QStyleOptionButton button;
                             button.rect = checkRect;
@@ -6166,7 +6181,7 @@ void Style::drawControl(ControlElement element, const QStyleOption *option, QPai
                                 if (checked)
                                     button.state |= State_On;
                                 button.palette = palette;
-                                drawPrimitive(PE_IndicatorCheckBox, &button, painter, widget);
+                                drawPrimitive(PE_IndicatorMenuCheckMark, &button, painter, widget);
                             }
                             else if (checked)
                             {
@@ -6177,9 +6192,9 @@ void Style::drawControl(ControlElement element, const QStyleOption *option, QPai
 
                                 sunkenRect = visualRect(menuItem->direction, menuItem->rect, sunkenRect);
                                 opt.state = menuItem->state;
-                                opt.state|=State_Raised|State_Horizontal;
-                                if (checked)
-                                    opt.state |= State_On;
+                                opt.state|=State_Raised|State_Horizontal|State_On;
+//                                 if (checked)
+//                                     opt.state |= State_On;
                                 drawLightBevel(painter, sunkenRect, &opt, widget, ROUNDED_ALL, getFill(&opt, m_buttonCols), m_buttonCols);
                             }
                         }
