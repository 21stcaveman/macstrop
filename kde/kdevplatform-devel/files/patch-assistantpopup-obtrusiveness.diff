--- shell/orig.assistantpopup.h	2014-06-25 12:35:11.000000000 +0200
+++ shell/assistantpopup.h	2014-08-21 19:23:47.000000000 +0200
@@ -112,13 +112,15 @@
      * @brief Get the geometry of the inner part (with the text) of the KTextEditor::View being used.
      */
     QRect textWidgetGeometry(KTextEditor::View *view) const;
+    void grabFocus();
+    void releaseFocus();
 
     KDevelop::IAssistant::Ptr m_assistant;
     QList<KDevelop::IAssistantAction::Ptr> m_assistantActions;
     QPointer<KTextEditor::View> m_view;
     QScopedPointer<AssistantPopupConfig> m_config;
     bool m_shownAtBottom;
-    bool m_reopening;
+    bool m_reopening, m_hasFocus, m_AltPressed;
 };
 
 #endif // KDEVPLATFORM_ASSISTANTPOPUP_H
--- shell/orig.assistantpopup.cpp	2014-06-25 12:35:11.000000000 +0200
+++ shell/assistantpopup.cpp	2014-08-22 12:22:05.000000000 +0200
@@ -63,7 +63,9 @@
     , m_view()
     , m_shownAtBottom(false)
     , m_reopening(false)
-{
+    , m_hasFocus(false)
+    , m_AltPressed(false)
+    {
     Q_ASSERT(assistant);
 
     QPalette p = palette();
@@ -79,6 +81,7 @@
 
 void AssistantPopup::reset(KTextEditor::View* widget, const IAssistant::Ptr& assistant)
 {
+    m_AltPressed = false;
     disconnect(this);
     if ( m_view ) {
         m_view->removeEventFilter(this);
@@ -175,6 +178,26 @@
     return geom;
 }
 
+void AssistantPopup::grabFocus()
+{
+    if( !m_hasFocus ){
+        setFocus();
+        m_config->setActive(true);
+        m_hasFocus = true;
+    }
+}
+
+void AssistantPopup::releaseFocus()
+{
+    if( m_hasFocus ){
+        m_config->setActive(false);
+        if (m_view) {
+            m_view->setFocus();
+        }
+        m_hasFocus = false;
+    }
+}
+
 void AssistantPopup::keyPressEvent(QKeyEvent* event)
 {
     if (event->key() >= Qt::Key_0 && event->key() <= Qt::Key_9) {
@@ -189,6 +212,10 @@
             }
         }
     } else {
+        // on OS X, typing Alt-Left or Alt-Right will here give event->modifiers()==Qt::AltModifier|Qt::ShiftModifier ?!
+        //qDebug() << "keyPressEvent: passing on event" << event; //->key() << "with modifiers" << event->modifiers();
+        // rather than just release focus, execute the hide action and then pass on the event
+        executeHideAction();
         QDeclarativeView::keyPressEvent(event);
     }
 }
@@ -196,13 +223,16 @@
 
 void AssistantPopup::keyReleaseEvent(QKeyEvent *event)
 {
-    if (event->key() == Qt::Key_Alt || event->modifiers() == Qt::AltModifier) {
-        m_config->setActive(false);
-        if (m_view) {
-            m_view->setFocus();
-        }
+    if (event->key() == Qt::Key_Alt || (event->modifiers() & Qt::AltModifier)) {
+        releaseFocus();
+        m_AltPressed = false;
     } else {
-        QDeclarativeView::keyReleaseEvent(event);
+        // don't pass on an event that we should have treated by now:
+        if (event->key() < Qt::Key_0 || event->key() > Qt::Key_9) {
+            // rather than just release focus, execute the hide action and then pass on the event
+            executeHideAction();
+            QDeclarativeView::keyReleaseEvent(event);
+        }
     }
 }
 
@@ -220,15 +250,64 @@
         executeHideAction();
     } else if (event->type() == QEvent::KeyPress) {
         auto keyEvent = static_cast<QKeyEvent*>(event);
+        int pressedKey = keyEvent->key();
+        switch (pressedKey) {
+            case Qt::Key_Escape:
+                executeHideAction();
+                break;
+#ifdef Q_WS_MACX
+            case Qt::Key_0:
+            case Qt::Key_1:
+            case Qt::Key_2:
+            case Qt::Key_3:
+            case Qt::Key_4:
+            case Qt::Key_5:
+            case Qt::Key_6:
+            case Qt::Key_7:
+            case Qt::Key_8:
+            case Qt::Key_9:
+                if( m_AltPressed ){
+                    auto actions = m_config->model();
+                    const int field = pressedKey - Qt::Key_0;
+                    // we shouldn't really ever get here
+                    qDebug() << "eventFilter: doing action for key" << field;
+                    if (field == 0) {
+                        executeHideAction();
+                    } else {
+                        auto action = m_assistantActions.value(field - 1);
+                        if (action) {
+                            action->execute();
+                        }
+                    }
+                    return true;
+                }
+                break;
+#endif //Q_WS_MACX
+//             case Qt::Key_Alt:
+//                    // grab focus even if other modifiers are being held
+//                     m_AltPressed = true;
+//                     grabFocus();
+//                     break;
+            default:
+#ifdef Q_WS_MACX
+                qDebug() << "eventFilter: unhandled key event" << keyEvent << "with AltPressed=" << m_AltPressed;
+#endif
+                break;
+        }
         if (keyEvent->modifiers() == Qt::AltModifier) {
-            setFocus();
-            m_config->setActive(true);
+            // grab focus when only the Alt key is held
+            grabFocus();
+            m_AltPressed = true;
         }
-        if (static_cast<QKeyEvent*>(event)->key() == Qt::Key_Escape) {
-            executeHideAction();
+    } else if (event->type() == QEvent::KeyRelease) {
+        auto keyEvent = static_cast<QKeyEvent*>(event);
+        if ( (keyEvent->key() == Qt::Key_Alt /*|| keyEvent->modifiers() == Qt::AltModifier*/) ) {
+            m_AltPressed = false;
         }
     }
-    return false;
+    // the example from the Qt documentation suggests one should pass on the event to the parent if we didn't handle it
+    // instead of simply returning false
+    return QDeclarativeView::eventFilter(object, event);
 }
 
 void AssistantPopup::updatePosition(KTextEditor::View* view, const KTextEditor::Cursor& newPos)
@@ -275,9 +354,10 @@
 {
     if ( isVisible() ) {
         m_assistant->doHide();
-        if (m_view) {
-            m_view->setFocus();
-        }
+//         if (m_view) {
+//             m_view->setFocus();
+//         }
+        releaseFocus();
     }
 }
 
