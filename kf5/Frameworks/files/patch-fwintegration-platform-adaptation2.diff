diff --git src/kstyle/CMakeLists.txt src/kstyle/CMakeLists.txt
index bc26667..572e6d6 100644
--- src/kstyle/CMakeLists.txt
+++ src/kstyle/CMakeLists.txt
@@ -21,7 +21,12 @@ configure_file(config-kstyle.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/config-kstyle.h
 
 remove_definitions(-DQT_NO_CAST_FROM_ASCII)
 
-add_library(KF5Style kstyle.cpp)
+if (APPLE)
+    # must use kstyle as file basename or rename the class. 
+    add_library(KF5Style kstyle.mm)
+else ()
+    add_library(KF5Style kstyle.cpp)
+endif (APPLE)
 generate_export_header(KF5Style BASE_NAME KStyle)
 add_library(KF5::Style ALIAS KF5Style)
 
diff --git src/kstyle/kstyle.mm src/kstyle/kstyle.mm
new file mode 100644
index 0000000..8bb260c
--- /dev/null
+++ src/kstyle/kstyle.mm
@@ -0,0 +1,421 @@
+/**
+ * KStyle for KDE4
+ * Copyright (C) 2004-2005 Maksim Orlovich <maksim@kde.org>
+ * Copyright (C) 2005,2006 Sandro Giessl <giessl@kde.org>
+ *
+ * Based in part on the following software:
+ *  KStyle for KDE3
+ *      Copyright (C) 2001-2002 Karol Szwed <gallium@kde.org>
+ *      Portions  (C) 1998-2000 TrollTech AS
+ *  Keramik for KDE3,
+ *      Copyright (C) 2002      Malte Starostik   <malte@kde.org>
+ *                (C) 2002-2003 Maksim Orlovich  <maksim@kde.org>
+ *      Portions  (C) 2001-2002 Karol Szwed     <gallium@kde.org>
+ *                (C) 2001-2002 Fredrik Höglund <fredrik@kde.org>
+ *                (C) 2000 Daniel M. Duley       <mosfet@kde.org>
+ *                (C) 2000 Dirk Mueller         <mueller@kde.org>
+ *                (C) 2001 Martijn Klingens    <klingens@kde.org>
+ *                (C) 2003 Sandro Giessl      <sandro@giessl.com>
+ *                (C) 2015 René J.V. Bertin <rjvbertin@gmail.com>
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ * Many thanks to Bradley T. Hughes for the 3 button scrollbar code.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License version 2 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "kstyle.h"
+
+#include <QAbstractItemView>
+#include <QApplication>
+#include <QDialogButtonBox>
+#include <QEvent>
+#include <QIcon>
+#include <QStyleOption>
+#include <QPushButton>
+#include <QToolBar>
+
+#include <kconfiggroup.h>
+#include <kiconloader.h>
+#include <kcolorscheme.h>
+#include <config-kstyle.h>
+
+// ----------------------------------------------------------------------------
+
+static const QStyle::StyleHint SH_KCustomStyleElement = (QStyle::StyleHint)0xff000001;
+static const int X_KdeBase = 0xff000000;
+
+class KStylePrivate
+{
+public:
+    KStylePrivate();
+
+    QHash<QString, int> styleElements;
+    int hintCounter, controlCounter, subElementCounter;
+};
+
+KStylePrivate::KStylePrivate()
+{
+    controlCounter = subElementCounter = X_KdeBase;
+    hintCounter = X_KdeBase + 1; //sic! X_KdeBase is covered by SH_KCustomStyleElement
+}
+
+/*
+    The functions called by widgets that request custom element support, passed to the effective style.
+    Collected in a static inline function due to similarity.
+*/
+
+static inline int customStyleElement(QStyle::StyleHint type, const QString &element, QWidget *widget)
+{
+    if (!widget || widget->style()->metaObject()->indexOfClassInfo("X-KDE-CustomElements") < 0) {
+        return 0;
+    }
+
+    const QString originalName = widget->objectName();
+    widget->setObjectName(element);
+    const int id = widget->style()->styleHint(type, 0, widget);
+    widget->setObjectName(originalName);
+    return id;
+}
+
+QStyle::StyleHint KStyle::customStyleHint(const QString &element, const QWidget *widget)
+{
+    return (StyleHint) customStyleElement(SH_KCustomStyleElement, element, const_cast<QWidget *>(widget));
+}
+
+QStyle::ControlElement KStyle::customControlElement(const QString &element, const QWidget *widget)
+{
+    return (ControlElement) customStyleElement(SH_KCustomStyleElement, element, const_cast<QWidget *>(widget));
+}
+
+QStyle::SubElement KStyle::customSubElement(const QString &element, const QWidget *widget)
+{
+    return (SubElement) customStyleElement(SH_KCustomStyleElement, element, const_cast<QWidget *>(widget));
+}
+
+KStyle::KStyle() : d(new KStylePrivate)
+{
+}
+
+KStyle::~KStyle()
+{
+    delete d;
+}
+
+/*
+    Custom Style Element runtime extension:
+    We reserve one StyleHint to let the effective style inform widgets whether it supports certain
+    string based style elements.
+    As this could lead to number conflicts (i.e. an app utilizing one of the hints itself for other
+    purposes) there're various safety mechanisms to rule out such interference.
+
+    1) It's most unlikely that a widget in some 3rd party app will accidentally call a general
+    QStyle/KStyle styleHint() or draw*() and (unconditionally) expect a valid return, however:
+    a. The StyleHint is not directly above Qt's custom base, assuming most 3rd party apps would
+    - in case - make use of such
+    b. In order to be accepted, the StyleHint query must pass a widget with a perfectly matching
+    name, containing the typical element prefix ("CE_", etc.) and being supported by the current style
+    c. Instead using Qt's fragile qstyleoption_cast on the QStyleOption provided to the StyleHint
+    query, try to dump out a string and hope for the best, we now manipulate the widgets objectName().
+    Plain Qt dependent widgets can do that themselves and if a widget uses KStyle's convenience access
+    functions, it won't notice this at all
+
+    2) The key problem is that a common KDE widget will run into an apps custom style which will then
+    falsely respond to the styleHint() call with an invalid value.
+    To prevent this, supporting styles *must* set a Q_CLASSINFO "X-KDE-CustomElements".
+
+    3) If any of the above traps snaps, the returned id is 0 - the QStyle default, indicating
+    that this element is not supported by the current style.
+
+    Obviously, this contains the "diminished clean" action to (temporarily) manipulate the
+    objectName() of a const QWidget* - but this happens completely inside KStyle or the widget, if
+    it does not make use of KStyles static convenience functions.
+    My biggest worry here would be, that in a multithreaded environment a thread (usually not being
+    owner of the widget) does something crucially relying on the widgets name property...
+    This however would also have to happen during the widget construction or stylechanges, when
+    the functions in doubt will typically be called.
+    So this is imho unlikely causing any trouble, ever.
+*/
+
+/*
+    The functions called by the real style implementation to add support for a certain element.
+    Checks for well-formed string (containing the element prefix) and returns 0 otherwise.
+    Checks whether the element is already supported or inserts it otherwise; Returns the proper id
+    NOTICE: We could check for "X-KDE-CustomElements", but this would bloat style start up times
+    (if they e.g. register 100 elements or so)
+*/
+
+static inline int newStyleElement(const QString &element, const char *check, int &counter, QHash<QString, int> *elements)
+{
+    if (!element.contains(check)) {
+        return 0;
+    }
+    int id = elements->value(element, 0);
+    if (!id) {
+        ++counter;
+        id = counter;
+        elements->insert(element, id);
+    }
+    return id;
+}
+
+QStyle::StyleHint KStyle::newStyleHint(const QString &element)
+{
+    return (StyleHint)newStyleElement(element, "SH_", d->hintCounter, &d->styleElements);
+}
+
+QStyle::ControlElement KStyle::newControlElement(const QString &element)
+{
+    return (ControlElement)newStyleElement(element, "CE_", d->controlCounter, &d->styleElements);
+}
+
+KStyle::SubElement KStyle::newSubElement(const QString &element)
+{
+    return (SubElement)newStyleElement(element, "SE_", d->subElementCounter, &d->styleElements);
+}
+
+void KStyle::polish(QWidget *w)
+{
+    // Enable hover effects in all itemviews
+    if (QAbstractItemView *itemView = qobject_cast<QAbstractItemView *>(w)) {
+        itemView->viewport()->setAttribute(Qt::WA_Hover);
+    }
+
+    if (QDialogButtonBox *box = qobject_cast<QDialogButtonBox *>(w)) {
+        QPushButton *button = box->button(QDialogButtonBox::Ok);
+        if (button && button->shortcut().isEmpty()) {
+            button->setShortcut(Qt::CTRL | Qt::Key_Return);
+        }
+    }
+
+    QCommonStyle::polish(w);
+}
+
+QPalette KStyle::standardPalette() const
+{
+    return KColorScheme::createApplicationPalette(KSharedConfig::openConfig());
+}
+
+QIcon KStyle::standardIcon(StandardPixmap standardIcon, const QStyleOption */*option*/,
+                           const QWidget */*widget*/) const
+{
+    switch (standardIcon) {
+    case QStyle::SP_DesktopIcon:
+        return QIcon::fromTheme(QStringLiteral("user-desktop"));
+    case QStyle::SP_TrashIcon:
+        return QIcon::fromTheme(QStringLiteral("user-trash"));
+    case QStyle::SP_ComputerIcon:
+        return QIcon::fromTheme(QStringLiteral("computer"));
+    case QStyle::SP_DriveFDIcon:
+        return QIcon::fromTheme(QStringLiteral("media-floppy"));
+    case QStyle::SP_DriveHDIcon:
+        return QIcon::fromTheme(QStringLiteral("drive-harddisk"));
+    case QStyle::SP_DriveCDIcon:
+    case QStyle::SP_DriveDVDIcon:
+        return QIcon::fromTheme(QStringLiteral("drive-optical"));
+    case QStyle::SP_DriveNetIcon:
+        return QIcon::fromTheme(QStringLiteral("folder-remote"));
+    case QStyle::SP_DirHomeIcon:
+        return QIcon::fromTheme(QStringLiteral("user-home"));
+    case QStyle::SP_DirOpenIcon:
+        return QIcon::fromTheme(QStringLiteral("document-open-folder"));
+    case QStyle::SP_DirClosedIcon:
+        return QIcon::fromTheme(QStringLiteral("folder"));
+    case QStyle::SP_DirIcon:
+        return QIcon::fromTheme(QStringLiteral("folder"));
+    case QStyle::SP_DirLinkIcon:
+        return QIcon::fromTheme(QStringLiteral("folder")); //TODO: generate (!?) folder with link emblem
+    case QStyle::SP_FileIcon:
+        return QIcon::fromTheme(QStringLiteral("text-plain")); //TODO: look for a better icon
+    case QStyle::SP_FileLinkIcon:
+        return QIcon::fromTheme(QStringLiteral("text-plain")); //TODO: generate (!?) file with link emblem
+    case QStyle::SP_FileDialogStart:
+        return QIcon::fromTheme(QStringLiteral("media-playback-start")); //TODO: find correct icon
+    case QStyle::SP_FileDialogEnd:
+        return QIcon::fromTheme(QStringLiteral("media-playback-stop")); //TODO: find correct icon
+    case QStyle::SP_FileDialogToParent:
+        return QIcon::fromTheme(QStringLiteral("go-up"));
+    case QStyle::SP_FileDialogNewFolder:
+        return QIcon::fromTheme(QStringLiteral("folder-new"));
+    case QStyle::SP_FileDialogDetailedView:
+        return QIcon::fromTheme(QStringLiteral("view-list-details"));
+    case QStyle::SP_FileDialogInfoView:
+        return QIcon::fromTheme(QStringLiteral("document-properties"));
+    case QStyle::SP_FileDialogContentsView:
+        return QIcon::fromTheme(QStringLiteral("view-list-icons"));
+    case QStyle::SP_FileDialogListView:
+        return QIcon::fromTheme(QStringLiteral("view-list-text"));
+    case QStyle::SP_FileDialogBack:
+        return QIcon::fromTheme(QStringLiteral("go-previous"));
+    case QStyle::SP_MessageBoxInformation:
+        return QIcon::fromTheme(QStringLiteral("dialog-information"));
+    case QStyle::SP_MessageBoxWarning:
+        return QIcon::fromTheme(QStringLiteral("dialog-warning"));
+    case QStyle::SP_MessageBoxCritical:
+        return QIcon::fromTheme(QStringLiteral("dialog-error"));
+    case QStyle::SP_MessageBoxQuestion:
+        return QIcon::fromTheme(QStringLiteral("dialog-information"));
+    case QStyle::SP_DialogOkButton:
+        return QIcon::fromTheme(QStringLiteral("dialog-ok"));
+    case QStyle::SP_DialogCancelButton:
+        return QIcon::fromTheme(QStringLiteral("dialog-cancel"));
+    case QStyle::SP_DialogHelpButton:
+        return QIcon::fromTheme(QStringLiteral("help-contents"));
+    case QStyle::SP_DialogOpenButton:
+        return QIcon::fromTheme(QStringLiteral("document-open"));
+    case QStyle::SP_DialogSaveButton:
+        return QIcon::fromTheme(QStringLiteral("document-save"));
+    case QStyle::SP_DialogCloseButton:
+        return QIcon::fromTheme(QStringLiteral("dialog-close"));
+    case QStyle::SP_DialogApplyButton:
+        return QIcon::fromTheme(QStringLiteral("dialog-ok-apply"));
+    case QStyle::SP_DialogResetButton:
+        return QIcon::fromTheme(QStringLiteral("document-revert"));
+    case QStyle::SP_DialogDiscardButton:
+        return QIcon::fromTheme(QStringLiteral("dialog-cancel"));
+    case QStyle::SP_DialogYesButton:
+        return QIcon::fromTheme(QStringLiteral("dialog-ok-apply"));
+    case QStyle::SP_DialogNoButton:
+        return QIcon::fromTheme(QStringLiteral("dialog-cancel"));
+    case QStyle::SP_ArrowUp:
+        return QIcon::fromTheme(QStringLiteral("go-up"));
+    case QStyle::SP_ArrowDown:
+        return QIcon::fromTheme(QStringLiteral("go-down"));
+    case QStyle::SP_ArrowLeft:
+        return QIcon::fromTheme(QStringLiteral("go-previous-view"));
+    case QStyle::SP_ArrowRight:
+        return QIcon::fromTheme(QStringLiteral("go-next-view"));
+    case QStyle::SP_ArrowBack:
+        return QIcon::fromTheme(QStringLiteral("go-previous"));
+    case QStyle::SP_ArrowForward:
+        return QIcon::fromTheme(QStringLiteral("go-next"));
+    case QStyle::SP_BrowserReload:
+        return QIcon::fromTheme(QStringLiteral("view-refresh"));
+    case QStyle::SP_BrowserStop:
+        return QIcon::fromTheme(QStringLiteral("process-stop"));
+    case QStyle::SP_MediaPlay:
+        return QIcon::fromTheme(QStringLiteral("media-playback-start"));
+    case QStyle::SP_MediaStop:
+        return QIcon::fromTheme(QStringLiteral("media-playback-stop"));
+    case QStyle::SP_MediaPause:
+        return QIcon::fromTheme(QStringLiteral("media-playback-pause"));
+    case QStyle::SP_MediaSkipForward:
+        return QIcon::fromTheme(QStringLiteral("media-skip-forward"));
+    case QStyle::SP_MediaSkipBackward:
+        return QIcon::fromTheme(QStringLiteral("media-skip-backward"));
+    case QStyle::SP_MediaSeekForward:
+        return QIcon::fromTheme(QStringLiteral("media-seek-forward"));
+    case QStyle::SP_MediaSeekBackward:
+        return QIcon::fromTheme(QStringLiteral("media-seek-backward"));
+    case QStyle::SP_MediaVolume:
+        return QIcon::fromTheme(QStringLiteral("audio-volume-medium"));
+    case QStyle::SP_MediaVolumeMuted:
+        return QIcon::fromTheme(QStringLiteral("audio-volume-muted"));
+
+    default:
+        return QIcon();
+    }
+}
+
+int KStyle::styleHint(StyleHint hint, const QStyleOption *option, const QWidget *widget, QStyleHintReturn *returnData) const
+{
+    switch (hint) {
+    case SH_DialogButtonBox_ButtonsHaveIcons: {
+        // was KGlobalSettings::showIconsOnPushButtons() :
+        KConfigGroup g(KSharedConfig::openConfig(), "KDE");
+        return g.readEntry("ShowIconsOnPushButtons", false);
+    }
+
+    case SH_ItemView_ArrowKeysNavigateIntoChildren:
+        return true;
+
+    case SH_Widget_Animate: {
+        KConfigGroup g(KSharedConfig::openConfig(), "KDE-Global GUI Settings");
+        return g.readEntry("GraphicEffectsLevel", true);
+    }
+
+    case SH_ToolButtonStyle: {
+        KConfigGroup g(KSharedConfig::openConfig(), "Toolbar style");
+
+        bool useOthertoolbars = false;
+        const QWidget *parent = widget ? widget->parentWidget() : nullptr;
+
+        //If the widget parent is a QToolBar and the magic property is set
+        if (parent && qobject_cast< const QToolBar * >(parent)) {
+            if (parent->property("otherToolbar").isValid()) {
+                useOthertoolbars = true;
+            }
+        }
+
+        QString buttonStyle;
+        if (useOthertoolbars) {
+            buttonStyle = g.readEntry("ToolButtonStyleOtherToolbars", "NoText").toLower();
+        } else {
+            buttonStyle = g.readEntry("ToolButtonStyle", "TextBesideIcon").toLower();
+        }
+
+        return buttonStyle == QLatin1String("textbesideicon") ? Qt::ToolButtonTextBesideIcon
+               : buttonStyle == QLatin1String("icontextright") ? Qt::ToolButtonTextBesideIcon
+               : buttonStyle == QLatin1String("textundericon") ? Qt::ToolButtonTextUnderIcon
+               : buttonStyle == QLatin1String("icontextbottom") ? Qt::ToolButtonTextUnderIcon
+               : buttonStyle == QLatin1String("textonly") ? Qt::ToolButtonTextOnly
+               : Qt::ToolButtonIconOnly;
+    }
+
+    case SH_KCustomStyleElement:
+        if (!widget) {
+            return 0;
+        }
+
+        return d->styleElements.value(widget->objectName(), 0);
+
+    default:
+        break;
+    };
+
+    return QCommonStyle::styleHint(hint, option, widget, returnData);
+}
+
+int KStyle::pixelMetric(PixelMetric metric, const QStyleOption *option, const QWidget *widget) const
+{
+    switch (metric) {
+    case PM_SmallIconSize:
+    case PM_ButtonIconSize:
+        return KIconLoader::global()->currentSize(KIconLoader::Small);
+
+    case PM_ToolBarIconSize:
+        return KIconLoader::global()->currentSize(KIconLoader::Toolbar);
+
+    case PM_LargeIconSize:
+        return KIconLoader::global()->currentSize(KIconLoader::Dialog);
+
+    case PM_MessageBoxIconSize:
+        // TODO return KIconLoader::global()->currentSize(KIconLoader::MessageBox);
+        return KIconLoader::SizeHuge;
+    default:
+        break;
+    }
+
+    return QCommonStyle::pixelMetric(metric, option, widget);
+}
+
diff --git src/platformtheme/CMakeLists.txt src/platformtheme/CMakeLists.txt
index 23f590e..e7343f9 100644
--- src/platformtheme/CMakeLists.txt
+++ src/platformtheme/CMakeLists.txt
@@ -19,17 +19,31 @@ endif()
 
 configure_file(config-platformtheme.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/config-platformtheme.h )
 
-set(platformtheme_SRCS
-    kdeplatformtheme.cpp
-    kfontsettingsdata.cpp
-    khintssettings.cpp
-    kdeplatformfiledialoghelper.cpp
-    kdeplatformfiledialogbase.cpp
-    kdeplatformsystemtrayicon.cpp
-    kfiletreeview.cpp
-    kdirselectdialog.cpp
-    main.cpp
-)
+if (APPLE)
+    set(platformtheme_SRCS
+        kdemactheme.mm
+        kfontsettingsdata.cpp
+        khintssettingsmac.mm
+        kdeplatformfiledialoghelper.cpp
+        kdeplatformfiledialogbase.cpp
+        kdeplatformsystemtrayicon.cpp
+        kfiletreeview.cpp
+        kdirselectdialog.cpp
+        main_mac.cpp
+    )
+else ()
+    set(platformtheme_SRCS
+        kdeplatformtheme.cpp
+        kfontsettingsdata.cpp
+        khintssettings.cpp
+        kdeplatformfiledialoghelper.cpp
+        kdeplatformfiledialogbase.cpp
+        kdeplatformsystemtrayicon.cpp
+        kfiletreeview.cpp
+        kdirselectdialog.cpp
+        main.cpp
+    )
+endif (APPLE)
 
 include_directories(
     ${Qt5Gui_PRIVATE_INCLUDE_DIRS}
diff --git src/platformtheme/kdemactheme.h src/platformtheme/kdemactheme.h
new file mode 100644
index 0000000..bb86a35
--- /dev/null
+++ src/platformtheme/kdemactheme.h
@@ -0,0 +1,71 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Kevin Ottens <ervin+bluesystems@kde.org>
+ *  Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KDEPLATFORMTHEME_H
+// use the same token as kdeplatform.h to ensure that including both leads to an error
+#define KDEPLATFORMTHEME_H
+
+#include <qpa/qplatformtheme.h>
+
+#include <QHash>
+#include <QObject>
+#include <QKeySequence>
+
+class KHintsSettingsMac;
+class KFontSettingsData;
+class QIconEngine;
+
+class KdeMacTheme : public QPlatformTheme
+{
+public:
+    KdeMacTheme();
+    ~KdeMacTheme();
+
+    // KdeMacTheme must provide platform menu methods or else there will be no menus
+    QPlatformMenuItem* createPlatformMenuItem() const Q_DECL_OVERRIDE;
+    QPlatformMenu* createPlatformMenu() const Q_DECL_OVERRIDE;
+    QPlatformMenuBar* createPlatformMenuBar() const Q_DECL_OVERRIDE;
+
+    QVariant themeHint(ThemeHint hint) const Q_DECL_OVERRIDE;
+    const QPalette *palette(Palette type = SystemPalette) const Q_DECL_OVERRIDE;
+    const QFont *font(Font type) const Q_DECL_OVERRIDE;
+    QIconEngine *createIconEngine(const QString &iconName) const Q_DECL_OVERRIDE;
+    QList<QKeySequence> keyBindings(QKeySequence::StandardKey key) const Q_DECL_OVERRIDE;
+
+    QPlatformDialogHelper *createPlatformDialogHelper(DialogType type) const Q_DECL_OVERRIDE;
+    bool usePlatformNativeDialog(DialogType type) const Q_DECL_OVERRIDE;
+
+#if QT_VERSION >= QT_VERSION_CHECK(5, 3, 0)
+    QString standardButtonText(int button) const Q_DECL_OVERRIDE;
+#endif
+
+    QPlatformSystemTrayIcon *createPlatformSystemTrayIcon() const Q_DECL_OVERRIDE;
+
+private:
+    void loadSettings();
+
+    KHintsSettingsMac *m_hints;
+    KFontSettingsData *m_fontsData;
+    // this will hold the instance of the native theme that will be used as a fallback
+    QPlatformTheme *nativeTheme;
+};
+
+#endif // KDEPLATFORMTHEME_H
diff --git src/platformtheme/kdemactheme.mm src/platformtheme/kdemactheme.mm
new file mode 100644
index 0000000..a7ff248
--- /dev/null
+++ src/platformtheme/kdemactheme.mm
@@ -0,0 +1,365 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Kevin Ottens <ervin+bluesystems@kde.org>
+ *  Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+ *  Copyright 2014 Lukáš Tinkl <ltinkl@redhat.com>
+ *  Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include "kdemactheme.h"
+#include "kfontsettingsdata.h"
+#include "khintssettingsmac.h"
+#include "kdeplatformfiledialoghelper.h"
+#include "kdeplatformsystemtrayicon.h"
+
+#include <QCoreApplication>
+#include <QFont>
+#include <QPalette>
+#include <QString>
+#include <QStringList>
+#include <QVariant>
+#include <QDebug>
+
+// instantiating the natice platform theme requires the use of private APIs
+#include <QtGui/private/qguiapplication_p.h>
+#include <QtGui/qpa/qplatformintegration.h>
+
+
+#include <kiconengine.h>
+#include <kiconloader.h>
+#include <kstandardshortcut.h>
+#include <KStandardGuiItem>
+#include <KLocalizedString>
+
+static void warnNoNativeTheme()
+{
+    qWarning() << "The KdePlatformThemePlugin is being used and the native Cocoa theme failed to load.";
+    qWarning() << "Applications will function but lack functionality available only through the native theme,";
+    qWarning() << "including the menu bar at the top of the screen(s).";
+}
+
+KdeMacTheme::KdeMacTheme()
+{
+    nativeTheme = QGuiApplicationPrivate::platform_integration->createPlatformTheme(QString::fromLatin1("cocoa"));
+    if (!nativeTheme) {
+        warnNoNativeTheme();
+    }
+    loadSettings();
+}
+
+KdeMacTheme::~KdeMacTheme()
+{
+    delete m_fontsData;
+    delete m_hints;
+    delete nativeTheme;
+}
+
+QPlatformMenuItem* KdeMacTheme::createPlatformMenuItem() const
+{
+    if (nativeTheme) {
+        return nativeTheme->createPlatformMenuItem();
+    } else {
+        warnNoNativeTheme();
+        return QPlatformTheme::createPlatformMenuItem();
+    }
+}
+
+QPlatformMenu* KdeMacTheme::createPlatformMenu() const
+{
+    if (nativeTheme) {
+        return nativeTheme->createPlatformMenu();
+    } else {
+        warnNoNativeTheme();
+        return QPlatformTheme::createPlatformMenu();
+    }
+}
+
+QPlatformMenuBar* KdeMacTheme::createPlatformMenuBar() const
+{
+    if (nativeTheme) {
+        return nativeTheme->createPlatformMenuBar();
+    } else {
+        warnNoNativeTheme();
+        return QPlatformTheme::createPlatformMenuBar();
+    }
+}
+
+QVariant KdeMacTheme::themeHint(QPlatformTheme::ThemeHint hintType) const
+{
+    QVariant hint = m_hints->hint(hintType);
+    if (hint.isValid()) {
+        return hint;
+    } else {
+        if (nativeTheme) {
+            return nativeTheme->themeHint(hintType);
+        }
+        return QPlatformTheme::themeHint(hintType);
+    }
+}
+
+const QPalette *KdeMacTheme::palette(Palette type) const
+{
+    QPalette *palette = m_hints->palette(type);
+    if (palette) {
+        return palette;
+    } else {
+        if (nativeTheme) {
+            return nativeTheme->palette(type);
+        }
+        return QPlatformTheme::palette(type);
+    }
+}
+
+const QFont *KdeMacTheme::font(Font type) const
+{
+    KFontSettingsData::FontTypes fdtype;
+    switch (type) {
+    case SystemFont:
+        fdtype = KFontSettingsData::GeneralFont; break;
+    case MenuFont:
+    case MenuBarFont:
+    case MenuItemFont:
+        fdtype = KFontSettingsData::MenuFont; break;
+    case MessageBoxFont:
+    case LabelFont:
+    case TipLabelFont:
+    case StatusBarFont:
+    case PushButtonFont:
+    case ToolButtonFont:
+    case ItemViewFont:
+    case ListViewFont:
+    case HeaderViewFont:
+    case ListBoxFont:
+    case ComboMenuItemFont:
+    case ComboLineEditFont:
+        fdtype = KFontSettingsData::GeneralFont; break;
+    case TitleBarFont:
+    case MdiSubWindowTitleFont:
+    case DockWidgetTitleFont:
+        fdtype = KFontSettingsData::WindowTitleFont; break;
+    case SmallFont:
+    case MiniFont:
+        fdtype = KFontSettingsData::SmallestReadableFont; break;
+    case FixedFont:
+        fdtype = KFontSettingsData::FixedFont; break;
+    default:
+        // here we do not use the OS X native theme for a fallback value:
+        // it does not provide different font roles (types).
+        // It would impose the system default font which is often not
+        // the most appropriate choice.
+        fdtype = KFontSettingsData::GeneralFont; break;
+    }
+
+    return m_fontsData->font(fdtype);
+}
+
+QIconEngine *KdeMacTheme::createIconEngine(const QString &iconName) const
+{
+    return new KIconEngine(iconName, KIconLoader::global());
+}
+
+void KdeMacTheme::loadSettings()
+{
+    m_fontsData = new KFontSettingsData;
+    m_hints = new KHintsSettingsMac;
+}
+
+QList<QKeySequence> KdeMacTheme::keyBindings(QKeySequence::StandardKey key) const
+{
+    // return a native keybinding if we can determine what that is
+    if (nativeTheme) {
+        return nativeTheme->keyBindings(key);
+    }
+    // or else we return whatever KDE applications expect elsewhere
+    switch (key) {
+    case QKeySequence::HelpContents:
+        return KStandardShortcut::shortcut(KStandardShortcut::Help);
+    case QKeySequence::WhatsThis:
+        return KStandardShortcut::shortcut(KStandardShortcut::WhatsThis);
+    case QKeySequence::Open:
+        return KStandardShortcut::shortcut(KStandardShortcut::Open);
+    case QKeySequence::Close:
+        return KStandardShortcut::shortcut(KStandardShortcut::Close);
+    case QKeySequence::Save:
+        return KStandardShortcut::shortcut(KStandardShortcut::Save);
+    case QKeySequence::New:
+        return KStandardShortcut::shortcut(KStandardShortcut::New);
+    case QKeySequence::Cut:
+        return KStandardShortcut::shortcut(KStandardShortcut::Cut);
+    case QKeySequence::Copy:
+        return KStandardShortcut::shortcut(KStandardShortcut::Copy);
+    case QKeySequence::Paste:
+        return KStandardShortcut::shortcut(KStandardShortcut::Paste);
+    case QKeySequence::Undo:
+        return KStandardShortcut::shortcut(KStandardShortcut::Undo);
+    case QKeySequence::Redo:
+        return KStandardShortcut::shortcut(KStandardShortcut::Redo);
+    case QKeySequence::Back:
+        return KStandardShortcut::shortcut(KStandardShortcut::Back);
+    case QKeySequence::Forward:
+        return KStandardShortcut::shortcut(KStandardShortcut::Forward);
+    case QKeySequence::Refresh:
+        return KStandardShortcut::shortcut(KStandardShortcut::Reload);
+    case QKeySequence::ZoomIn:
+        return KStandardShortcut::shortcut(KStandardShortcut::ZoomIn);
+    case QKeySequence::ZoomOut:
+        return KStandardShortcut::shortcut(KStandardShortcut::ZoomOut);
+    case QKeySequence::Print:
+        return KStandardShortcut::shortcut(KStandardShortcut::Print);
+    case QKeySequence::Find:
+        return KStandardShortcut::shortcut(KStandardShortcut::Find);
+    case QKeySequence::FindNext:
+        return KStandardShortcut::shortcut(KStandardShortcut::FindNext);
+    case QKeySequence::FindPrevious:
+        return KStandardShortcut::shortcut(KStandardShortcut::FindPrev);
+    case QKeySequence::Replace:
+        return KStandardShortcut::shortcut(KStandardShortcut::Replace);
+    case QKeySequence::SelectAll:
+        return KStandardShortcut::shortcut(KStandardShortcut::SelectAll);
+    case QKeySequence::MoveToNextWord:
+        return KStandardShortcut::shortcut(KStandardShortcut::ForwardWord);
+    case QKeySequence::MoveToPreviousWord:
+        return KStandardShortcut::shortcut(KStandardShortcut::BackwardWord);
+    case QKeySequence::MoveToNextPage:
+        return KStandardShortcut::shortcut(KStandardShortcut::Next);
+    case QKeySequence::MoveToPreviousPage:
+        return KStandardShortcut::shortcut(KStandardShortcut::Prior);
+    case QKeySequence::MoveToStartOfLine:
+        return KStandardShortcut::shortcut(KStandardShortcut::BeginningOfLine);
+    case QKeySequence::MoveToEndOfLine:
+        return KStandardShortcut::shortcut(KStandardShortcut::EndOfLine);
+    case QKeySequence::MoveToStartOfDocument:
+        return KStandardShortcut::shortcut(KStandardShortcut::Begin);
+    case QKeySequence::MoveToEndOfDocument:
+        return KStandardShortcut::shortcut(KStandardShortcut::End);
+    case QKeySequence::SaveAs:
+        return KStandardShortcut::shortcut(KStandardShortcut::SaveAs);
+    case QKeySequence::Preferences:
+        return KStandardShortcut::shortcut(KStandardShortcut::Preferences);
+    case QKeySequence::Quit:
+        return KStandardShortcut::shortcut(KStandardShortcut::Quit);
+    case QKeySequence::FullScreen:
+        return KStandardShortcut::shortcut(KStandardShortcut::FullScreen);
+    case QKeySequence::Deselect:
+        return KStandardShortcut::shortcut(KStandardShortcut::Deselect);
+    case QKeySequence::DeleteStartOfWord:
+        return KStandardShortcut::shortcut(KStandardShortcut::DeleteWordBack);
+    case QKeySequence::DeleteEndOfWord:
+        return KStandardShortcut::shortcut(KStandardShortcut::DeleteWordForward);
+    case QKeySequence::NextChild:
+        return KStandardShortcut::shortcut(KStandardShortcut::TabNext);
+    case QKeySequence::PreviousChild:
+        return KStandardShortcut::shortcut(KStandardShortcut::TabPrev);
+    default:
+        return QPlatformTheme::keyBindings(key);
+    }
+}
+
+bool KdeMacTheme::usePlatformNativeDialog(QPlatformTheme::DialogType type) const
+{
+    if (nativeTheme) {
+        return nativeTheme->usePlatformNativeDialog(type);
+    }
+    return type == QPlatformTheme::FileDialog;
+}
+
+#if QT_VERSION >= QT_VERSION_CHECK(5, 3, 0)
+QString KdeMacTheme::standardButtonText(int button) const
+{
+    // assume that button text is a domain where cross-platform application
+    // coherence primes over native platform look and feel. IOW, function over form.
+    switch (static_cast<QPlatformDialogHelper::StandardButton>(button)) {
+    case QPlatformDialogHelper::NoButton:
+        qWarning() << Q_FUNC_INFO << "Unsupported standard button:" << button;
+        return QString();
+    case QPlatformDialogHelper::Ok:
+        return KStandardGuiItem::ok().text();
+    case QPlatformDialogHelper::Save:
+        return KStandardGuiItem::save().text();
+    case QPlatformDialogHelper::SaveAll:
+        return i18nc("@action:button", "Save All");
+    case QPlatformDialogHelper::Open:
+        return KStandardGuiItem::open().text();
+    case QPlatformDialogHelper::Yes:
+        return KStandardGuiItem::yes().text();
+    case QPlatformDialogHelper::YesToAll:
+        return i18nc("@action:button", "Yes to All");
+    case QPlatformDialogHelper::No:
+        return KStandardGuiItem::no().text();
+    case QPlatformDialogHelper::NoToAll:
+        return i18nc("@action:button", "No to All");
+    case QPlatformDialogHelper::Abort:
+        // FIXME KStandardGuiItem::stop() doesn't seem right here
+        return i18nc("@action:button", "Abort");
+    case QPlatformDialogHelper::Retry:
+        return i18nc("@action:button", "Retry");
+    case QPlatformDialogHelper::Ignore:
+        return i18nc("@action:button", "Ignore");
+    case QPlatformDialogHelper::Close:
+        return KStandardGuiItem::close().text();
+    case QPlatformDialogHelper::Cancel:
+        return KStandardGuiItem::cancel().text();
+    case QPlatformDialogHelper::Discard:
+        return KStandardGuiItem::discard().text();
+    case QPlatformDialogHelper::Help:
+        return KStandardGuiItem::help().text();
+    case QPlatformDialogHelper::Apply:
+        return KStandardGuiItem::apply().text();
+    case QPlatformDialogHelper::Reset:
+        return KStandardGuiItem::reset().text();
+    case QPlatformDialogHelper::RestoreDefaults:
+        return KStandardGuiItem::defaults().text();
+    default:
+        if (nativeTheme) {
+            // something not foreseen by Qt/KDE: now see if OS X
+            // has an opinion about the text.
+            return nativeTheme->standardButtonText(button);
+        }
+        return QPlatformTheme::defaultStandardButtonText(button);
+    }
+}
+#endif
+
+QPlatformDialogHelper *KdeMacTheme::createPlatformDialogHelper(QPlatformTheme::DialogType type) const
+{
+    // always prefer native dialogs
+    if (nativeTheme) {
+        return nativeTheme->createPlatformDialogHelper(type);
+    }
+    switch (type) {
+    case QPlatformTheme::FileDialog:
+        // given that QPlatformTheme::createPlatformDialogHelper() is likely to keep
+        // returning NULL in the foreseeable future, it's better to have some kind of
+        // fallback rather than none at all.
+        return new KDEPlatformFileDialogHelper;
+    case QPlatformTheme::FontDialog:
+    case QPlatformTheme::ColorDialog:
+    case QPlatformTheme::MessageDialog:
+    default:
+        return QPlatformTheme::createPlatformDialogHelper(type);
+    }
+}
+
+QPlatformSystemTrayIcon *KdeMacTheme::createPlatformSystemTrayIcon() const
+{
+    if (nativeTheme) {
+        return nativeTheme->createPlatformSystemTrayIcon();
+    }
+    // TODO: figure out if this makes sense as a fallback, i.e. if it works.
+    return new KDEPlatformSystemTrayIcon;
+}
diff --git src/platformtheme/khintssettingsmac.h src/platformtheme/khintssettingsmac.h
new file mode 100644
index 0000000..6931a4d
--- /dev/null
+++ src/platformtheme/khintssettingsmac.h
@@ -0,0 +1,90 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Alejandro Fiestas Olivares <afiestas@kde.org>
+ *  Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KHINTS_SETTINGS_H
+#define KHINTS_SETTINGS_H
+
+#include <QObject>
+#include <QVariant>
+
+#include <qpa/qplatformtheme.h>
+#include <ksharedconfig.h>
+
+class KConfigGroup;
+
+class QPalette;
+class KHintsSettingsMac : public QObject
+{
+    Q_OBJECT
+public:
+    /**
+    * An identifier for change signals.
+    * @note Copied from KGlobalSettings
+    */
+    enum ChangeType { PaletteChanged = 0, FontChanged, StyleChanged,
+                      SettingsChanged, IconChanged, CursorChanged,
+                      ToolbarStyleChanged, ClipboardConfigChanged,
+                      BlockShortcuts, NaturalSortingChanged
+                    };
+    /**
+    * Valid values for the settingsChanged signal
+    * @note Copied from KGlobalSettings
+    */
+    enum SettingsCategory { SETTINGS_MOUSE, SETTINGS_COMPLETION, SETTINGS_PATHS,
+                            SETTINGS_POPUPMENU, SETTINGS_QT, SETTINGS_SHORTCUTS,
+                            SETTINGS_LOCALE, SETTINGS_STYLE
+                          };
+    explicit KHintsSettingsMac();
+    virtual ~KHintsSettingsMac();
+
+    inline QVariant hint(QPlatformTheme::ThemeHint hint) const
+    {
+        return m_hints[hint];
+    }
+
+    inline QPalette *palette(QPlatformTheme::Palette type) const
+    {
+        return m_palettes[type];
+    }
+
+private Q_SLOTS:
+    void delayedDBusConnects();
+    void setupIconLoader();
+    void toolbarStyleChanged();
+    void slotNotifyChange(int type, int arg);
+
+private:
+    QVariant readConfigValue(const QString &group, const QString &key, const QVariant &defaultValue);
+    void loadPalettes();
+    void iconChanged(int group);
+    void updateQtSettings(KConfigGroup &cg);
+    Qt::ToolButtonStyle toolButtonStyle(const KConfigGroup &cg) const;
+    void updateCursorTheme();
+
+    QStringList xdgIconThemePaths() const;
+    QHash<QPlatformTheme::Palette, QPalette *> m_palettes;
+    QHash<QPlatformTheme::ThemeHint, QVariant> m_hints;
+    KSharedConfigPtr mKdeGlobals;
+    KSharedConfigPtr mDefaultLnfConfig;
+    KSharedConfigPtr mLnfConfig;
+};
+
+#endif //KHINTS_SETTINGS_H
diff --git src/platformtheme/khintssettingsmac.mm src/platformtheme/khintssettingsmac.mm
new file mode 100644
index 0000000..196fc02
--- /dev/null
+++ src/platformtheme/khintssettingsmac.mm
@@ -0,0 +1,331 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Kevin Ottens <ervin+bluesystems@kde.org>
+ *  Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+ *  Copyright 2013 Alejandro Fiestas Olivares <afiestas@kde.org>
+ *  Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include "khintssettingsmac.h"
+
+#include <QDebug>
+#include <QDir>
+#include <QString>
+#include <QFileInfo>
+#include <QToolBar>
+#include <QPalette>
+#include <QToolButton>
+#include <QMainWindow>
+#include <QApplication>
+#include <QGuiApplication>
+#include <QDialogButtonBox>
+#include <QScreen>
+
+#include <QDBusConnection>
+#include <QDBusInterface>
+
+#include <kiconloader.h>
+#include <kconfiggroup.h>
+#include <ksharedconfig.h>
+#include <kcolorscheme.h>
+
+#ifndef UNIT_TEST
+#include <config-platformtheme.h>
+#endif
+
+KHintsSettingsMac::KHintsSettingsMac() : QObject(0)
+{
+    mKdeGlobals = KSharedConfig::openConfig(QStringLiteral("kdeglobals"), KConfig::NoGlobals);
+    KConfigGroup cg(mKdeGlobals, "KDE");
+
+    KConfigGroup cgToolbar(mKdeGlobals, "Toolbar style");
+    m_hints[QPlatformTheme::ToolButtonStyle] = toolButtonStyle(cgToolbar);
+
+    KConfigGroup cgToolbarIcon(mKdeGlobals, "MainToolbarIcons");
+    m_hints[QPlatformTheme::ToolBarIconSize] = cgToolbarIcon.readEntry("Size", 22);
+
+    m_hints[QPlatformTheme::ItemViewActivateItemOnSingleClick] = cg.readEntry("SingleClick", true);
+
+    m_hints[QPlatformTheme::SystemIconThemeName] = readConfigValue(QStringLiteral("Icons"), QStringLiteral("Theme"), "oxygen");
+
+    m_hints[QPlatformTheme::SystemIconFallbackThemeName] = "hicolor";
+    m_hints[QPlatformTheme::IconThemeSearchPaths] = xdgIconThemePaths();
+
+    QStringList styleNames;
+    styleNames << cg.readEntry("widgetStyle", QString())
+               << QStringLiteral("macintosh")
+               << QStringLiteral("fusion")
+               << QStringLiteral("windows");
+    const QString lnfStyle = readConfigValue(QStringLiteral("KDE"), QStringLiteral("widgetStyle"), QString()).toString();
+    if (!lnfStyle.isEmpty()) {
+        styleNames.removeOne(lnfStyle);
+        styleNames.prepend(lnfStyle);
+    }
+    m_hints[QPlatformTheme::StyleNames] = styleNames;
+
+    m_hints[QPlatformTheme::DialogButtonBoxButtonsHaveIcons] = cg.readEntry("ShowIconsOnPushButtons", false);
+    m_hints[QPlatformTheme::UseFullScreenForPopupMenu] = true;
+    m_hints[QPlatformTheme::UiEffects] = cg.readEntry("GraphicEffectsLevel", 0) != 0 ? QPlatformTheme::GeneralUiEffect : 0;
+    m_hints[QPlatformTheme::IconPixmapSizes] = QVariant::fromValue(QList<int>() << 512 << 256 << 128 << 64 << 32 << 22 << 16 << 8);
+
+    bool showIcons = cg.readEntry("ShowIconsInMenuItems", !QApplication::testAttribute(Qt::AA_DontShowIconsInMenus));
+    QCoreApplication::setAttribute(Qt::AA_DontShowIconsInMenus, !showIcons);
+
+    QMetaObject::invokeMethod(this, "delayedDBusConnects", Qt::QueuedConnection);
+    QMetaObject::invokeMethod(this, "setupIconLoader", Qt::QueuedConnection);
+
+    loadPalettes();
+}
+
+KHintsSettingsMac::~KHintsSettingsMac()
+{
+    qDeleteAll(m_palettes);
+}
+
+QVariant KHintsSettingsMac::readConfigValue(const QString &group, const QString &key, const QVariant &defaultValue)
+{
+    KConfigGroup userCg(mKdeGlobals, group);
+    QVariant value = userCg.readEntry(key, QString());
+
+    if (!value.isNull()) {
+        return value;
+    }
+
+    if (mLnfConfig) {
+        KConfigGroup lnfCg(mLnfConfig, "kdeglobals");
+        lnfCg = KConfigGroup(&lnfCg, group);
+        if (lnfCg.isValid()) {
+            value = lnfCg.readEntry(key, defaultValue);
+
+            if (!value.isNull()) {
+                return value;
+            }
+        }
+    }
+
+    KConfigGroup lnfCg(mDefaultLnfConfig, group);
+    if (lnfCg.isValid()) {
+        return lnfCg.readEntry(key, defaultValue);
+    }
+
+    return defaultValue;
+}
+
+QStringList KHintsSettingsMac::xdgIconThemePaths() const
+{
+    QStringList paths;
+
+    const QFileInfo homeIconDir(QDir::homePath() + QStringLiteral("/.icons"));
+    if (homeIconDir.isDir()) {
+        paths << homeIconDir.absoluteFilePath();
+    }
+
+    QString xdgDirString = QStandardPaths::standardLocations(QStandardPaths::GenericDataLocation).join(':');
+
+    if (xdgDirString.isEmpty()) {
+        xdgDirString = QStringLiteral("/opt/local/share:/usr/local/share:/usr/share");
+    }
+
+    foreach (const QString &xdgDir, xdgDirString.split(QLatin1Char(':'))) {
+        const QFileInfo xdgIconsDir(xdgDir + QStringLiteral("/icons"));
+        if (xdgIconsDir.isDir()) {
+            paths << xdgIconsDir.absoluteFilePath();
+        }
+    }
+
+    return paths;
+}
+
+void KHintsSettingsMac::delayedDBusConnects()
+{
+    QDBusConnection::sessionBus().connect(QString(), QStringLiteral("/KToolBar"), QStringLiteral("org.kde.KToolBar"),
+                                          QStringLiteral("styleChanged"), this, SLOT(toolbarStyleChanged()));
+    QDBusConnection::sessionBus().connect(QString(), QStringLiteral("/KGlobalSettings"), QStringLiteral("org.kde.KGlobalSettings"),
+                                          QStringLiteral("notifyChange"), this, SLOT(slotNotifyChange(int,int)));
+}
+
+void KHintsSettingsMac::setupIconLoader()
+{
+    connect(KIconLoader::global(), &KIconLoader::iconChanged, this, &KHintsSettingsMac::iconChanged);
+}
+
+void KHintsSettingsMac::toolbarStyleChanged()
+{
+    mKdeGlobals->reparseConfiguration();
+    KConfigGroup cg(mKdeGlobals, "Toolbar style");
+
+    m_hints[QPlatformTheme::ToolButtonStyle] = toolButtonStyle(cg);
+    //from gtksymbol.cpp
+    QWidgetList widgets = QApplication::allWidgets();
+    for (int i = 0; i < widgets.size(); ++i) {
+        QWidget *widget = widgets.at(i);
+        if (qobject_cast<QToolButton *>(widget)) {
+            QEvent event(QEvent::StyleChange);
+            QApplication::sendEvent(widget, &event);
+        }
+    }
+}
+
+void KHintsSettingsMac::slotNotifyChange(int type, int arg)
+{
+    mKdeGlobals->reparseConfiguration();
+    KConfigGroup cg(mKdeGlobals, "KDE");
+
+    switch (type) {
+    case PaletteChanged: {
+        loadPalettes();
+
+        //QApplication::setPalette and QGuiApplication::setPalette are different functions
+        //and non virtual. Call the correct one
+        if (qobject_cast<QApplication *>(QCoreApplication::instance())) {
+            QApplication::setPalette(*m_palettes[QPlatformTheme::SystemPalette]);
+        } else if (qobject_cast<QGuiApplication *>(QCoreApplication::instance())) {
+            QGuiApplication::setPalette(*m_palettes[QPlatformTheme::SystemPalette]);
+        }
+        break;
+    }
+    case SettingsChanged: {
+
+        SettingsCategory category = static_cast<SettingsCategory>(arg);
+        if (category == SETTINGS_QT || category == SETTINGS_MOUSE) {
+            updateQtSettings(cg);
+        } else if (category == SETTINGS_STYLE) {
+            m_hints[QPlatformTheme::DialogButtonBoxButtonsHaveIcons] = cg.readEntry("ShowIconsOnPushButtons", false);
+            m_hints[QPlatformTheme::UiEffects] = cg.readEntry("GraphicEffectsLevel", 0) != 0 ? QPlatformTheme::GeneralUiEffect : 0;
+        }
+        break;
+    }
+    case ToolbarStyleChanged: {
+        toolbarStyleChanged();
+        break;
+    }
+    case IconChanged:
+        iconChanged(arg); //Once the KCM is ported to use IconChanged, this should not be needed
+        break;
+    case CursorChanged:
+        // updateCursorTheme();
+        break;
+    case StyleChanged: {
+        QApplication *app = qobject_cast<QApplication *>(QCoreApplication::instance());
+        if (!app) {
+            return;
+        }
+
+        const QString theme = cg.readEntry("widgetStyle", QString());
+        if (theme.isEmpty()) {
+            return;
+        }
+
+        QStringList styleNames;
+        styleNames << cg.readEntry("widgetStyle", QString())
+                << QStringLiteral("macintosh")
+                << QStringLiteral("fusion")
+                << QStringLiteral("windows");
+        const QString lnfStyle = readConfigValue(QStringLiteral("KDE"), QStringLiteral("widgetStyle"), QString()).toString();
+        if (!lnfStyle.isEmpty() && !styleNames.contains(lnfStyle)) {
+            styleNames.prepend(lnfStyle);
+        }
+        m_hints[QPlatformTheme::StyleNames] = styleNames;
+
+        app->setStyle(theme);
+        loadPalettes();
+        break;
+    }
+    default:
+        qWarning() << "Unknown type of change in KGlobalSettings::slotNotifyChange: " << type;
+    }
+}
+
+void KHintsSettingsMac::iconChanged(int group)
+{
+    KIconLoader::Group iconGroup = (KIconLoader::Group) group;
+    if (iconGroup != KIconLoader::MainToolbar) {
+        m_hints[QPlatformTheme::SystemIconThemeName] = readConfigValue(QStringLiteral("Icons"), QStringLiteral("Theme"), "oxygen");
+
+        return;
+    }
+
+    const int currentSize = KIconLoader::global()->currentSize(KIconLoader::MainToolbar);
+    if (m_hints[QPlatformTheme::ToolBarIconSize] == currentSize) {
+        return;
+    }
+
+    m_hints[QPlatformTheme::ToolBarIconSize] = currentSize;
+
+    //If we are not a QApplication, means that we are a QGuiApplication, then we do nothing.
+    if (!qobject_cast<QApplication *>(QCoreApplication::instance())) {
+        return;
+    }
+
+    QWidgetList widgets = QApplication::allWidgets();
+    Q_FOREACH (QWidget *widget, widgets) {
+        if (qobject_cast<QToolBar *>(widget) || qobject_cast<QMainWindow *>(widget)) {
+            QEvent event(QEvent::StyleChange);
+            QApplication::sendEvent(widget, &event);
+        }
+    }
+}
+
+void KHintsSettingsMac::updateQtSettings(KConfigGroup &cg)
+{
+    m_hints[QPlatformTheme::ItemViewActivateItemOnSingleClick] = cg.readEntry("SingleClick", true);
+
+    bool showIcons = cg.readEntry("ShowIconsInMenuItems", !QApplication::testAttribute(Qt::AA_DontShowIconsInMenus));
+    QCoreApplication::setAttribute(Qt::AA_DontShowIconsInMenus, !showIcons);
+
+#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
+    int wheelScrollLines = cg.readEntry("WheelScrollLines", 3);
+    m_hints[QPlatformTheme::WheelScrollLines] = wheelScrollLines;
+#endif
+    QApplication *app = qobject_cast<QApplication *>(QCoreApplication::instance());
+    if (app) {
+        QApplication::setWheelScrollLines(cg.readEntry("WheelScrollLines", 3));
+    }
+}
+
+Qt::ToolButtonStyle KHintsSettingsMac::toolButtonStyle(const KConfigGroup &cg) const
+{
+    const QString buttonStyle = cg.readEntry("ToolButtonStyle", "TextBesideIcon").toLower();
+    return buttonStyle == QLatin1String("textbesideicon") ? Qt::ToolButtonTextBesideIcon
+           : buttonStyle == QLatin1String("icontextright") ? Qt::ToolButtonTextBesideIcon
+           : buttonStyle == QLatin1String("textundericon") ? Qt::ToolButtonTextUnderIcon
+           : buttonStyle == QLatin1String("icontextbottom") ? Qt::ToolButtonTextUnderIcon
+           : buttonStyle == QLatin1String("textonly") ? Qt::ToolButtonTextOnly
+           : Qt::ToolButtonIconOnly;
+}
+
+void KHintsSettingsMac::loadPalettes()
+{
+    qDeleteAll(m_palettes);
+    m_palettes.clear();
+
+    if (mKdeGlobals->hasGroup("Colors:View")) {
+        m_palettes[QPlatformTheme::SystemPalette] = new QPalette(KColorScheme::createApplicationPalette(mKdeGlobals));
+    } else {
+        const QString scheme = readConfigValue(QStringLiteral("General"), QStringLiteral("ColorScheme"), "oxygen").toString();
+        const QString path = QStandardPaths::locate(QStandardPaths::GenericDataLocation, "color-schemes/" + scheme + ".colors");
+
+        if (!path.isEmpty()) {
+            m_palettes[QPlatformTheme::SystemPalette] = new QPalette(KColorScheme::createApplicationPalette(KSharedConfig::openConfig(path)));
+        }
+    }
+}
+
+void KHintsSettingsMac::updateCursorTheme()
+{
+}
diff --git src/platformtheme/main_mac.cpp src/platformtheme/main_mac.cpp
new file mode 100644
index 0000000..02d061a
--- /dev/null
+++ src/platformtheme/main_mac.cpp
@@ -0,0 +1,52 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Kevin Ottens <ervin+bluesystems@kde.org>
+ *  Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include <qpa/qplatformthemeplugin.h>
+
+#include "kdemactheme.h"
+
+#include <config-platformtheme.h>
+
+class KdePlatformThemePlugin : public QPlatformThemePlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QPA.QPlatformThemeFactoryInterface.5.1" FILE "kdeplatformtheme.json")
+public:
+    KdePlatformThemePlugin(QObject *parent = 0)
+        : QPlatformThemePlugin(parent) {}
+
+    QPlatformTheme *create(const QString &key, const QStringList &paramList) Q_DECL_OVERRIDE
+    {
+        Q_UNUSED(key)
+        Q_UNUSED(paramList)
+        return new KdeMacTheme;
+    }
+
+public Q_SLOTS:
+    // do we need the slot at all?
+    void setupXcbFlush();
+};
+
+void KdePlatformThemePlugin::setupXcbFlush()
+{
+}
+
+#include "main_mac.moc"
