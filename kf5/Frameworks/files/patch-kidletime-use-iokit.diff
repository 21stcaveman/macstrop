diff --git src/plugins/osx/CMakeLists.txt src/plugins/osx/CMakeLists.txt
index e1b50b8..849a715 100644
--- src/plugins/osx/CMakeLists.txt
+++ src/plugins/osx/CMakeLists.txt
@@ -5,7 +5,7 @@ set(osx_plugin_SRCS
 add_library(KF5IdleTimeOsxPlugin MODULE ${osx_plugin_SRCS})
 target_link_libraries(KF5IdleTimeOsxPlugin
     KF5IdleTime
-    "-framework CoreFoundation -framework Carbon"
+    "-framework CoreFoundation -framework IOKit"
 )
 
 install(
diff --git src/plugins/osx/macpoller.cpp src/plugins/osx/macpoller.cpp
index ad9c10f..79f1bc4 100644
--- src/plugins/osx/macpoller.cpp
+++ src/plugins/osx/macpoller.cpp
@@ -20,7 +20,12 @@
 */
 
 #include "macpoller.h"
+#include <CoreServices/CoreServices.h>
 
+#include <QDebug>
+#include <QTimer>
+
+#ifndef USE_IOKIT
 // Why does Apple have to make this so complicated?
 static OSStatus LoadFrameworkBundle(CFStringRef framework, CFBundleRef *bundlePtr)
 {
@@ -97,7 +102,7 @@ pascal void MacPoller::IdleTimerAction(EventLoopTimerRef, EventLoopIdleTimerMess
     case kEventLoopIdleTimerIdling:
         // Called every time the timer fires (i.e. every second).
         ((MacPoller *)inUserData)->m_secondsIdle++;
-        ((MacPoller *)inUserData)->poll();
+        ((MacPoller *)inUserData)->poll(true);
         break;
     }
 }
@@ -109,22 +114,54 @@ typedef OSStatus(*InstallEventLoopIdleTimerPtr)(EventLoopRef inEventLoop,
         EventLoopIdleTimerUPP    inTimerProc,
         void                *inTimerData,
         EventLoopTimerRef   *outTimer);
+#endif
+
+typedef OSErr(*UpdateSystemActivityPtr)(UInt8 activity);
+static UpdateSystemActivityPtr updateSystemActivity;
 
 MacPoller::MacPoller(QObject *parent)
     : AbstractSystemPoller(parent)
+#ifndef USE_IOKIT
     , m_timerRef(0)
     , m_secondsIdle(0)
+#else
+    , ioPort(0)
+    , ioIterator(0)
+    , ioObject(0)
+    , m_idleTimer(0)
+    , m_minTimeout(-1)
+#endif // !USE_IOKIT
     , m_catch(false)
 {
 }
 
 MacPoller::~MacPoller()
 {
+#ifdef USE_IOKIT
+    unloadPoller();
+    delete m_idleTimer;
+#endif
 }
 
 void MacPoller::unloadPoller()
 {
+#ifdef USE_IOKIT
+    if (m_idleTimer) {
+        m_idleTimer->stop();
+        delete m_idleTimer;
+        m_idleTimer = 0;
+    }
+    if (ioObject) {
+        IOObjectRelease( ioObject );
+        ioObject = 0;
+    }
+    if (ioIterator) {
+        IOObjectRelease( ioIterator );
+        ioIterator = 0;
+    }
+#else
     RemoveEventLoopTimer(m_timerRef);
+#endif
 }
 
 bool MacPoller::isAvailable()
@@ -135,10 +172,61 @@ bool MacPoller::isAvailable()
 bool MacPoller::setUpPoller()
 {
     // May already be init'ed.
+#ifdef USE_IOKIT
+    if (ioObject) {
+        return true;
+    }
+#else
     if (m_timerRef) {
         return true;
     }
+#endif
+
+    // The easiest way to simulate user activity is to call UpdateSystemActivity(), but that function has
+    // sadly been deprecated. Hence the attempt to load it dynamically from the framework that provides/d it.
+    static CFBundleRef csBundle = 0;
+    if (!csBundle) {
+        csBundle = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.CoreServices"));
+    }
+    if (csBundle) {
+        updateSystemActivity = (UpdateSystemActivityPtr) CFBundleGetFunctionPointerForName(csBundle, CFSTR("UpdateSystemActivity"));
+        if (!updateSystemActivity) {
+            qWarning() << "failed to load UpdateSystemActivity from CoreServices.framework";
+        }
+    }
+    else{
+        updateSystemActivity = 0;
+        qWarning() << "failed to load CoreServices.framework: UpdateSystemActivity not available";
+    }
+
+#ifdef USE_IOKIT
+    kern_return_t status;
+    // establish the connection with I/O Kit, on the default port (MACH_PORT_NULL).
+    status = IOMasterPort( MACH_PORT_NULL, &ioPort );
+    if (status != KERN_SUCCESS) {
+        qWarning() << "could not establish a connection with I/O Kit on the default port";
+        return false;
+    }
+    // We will use the IOHID service which will allow us to know about user interaction.
+    // Get an iterator on the I/O Kit services, so we can access IOHID:
+    status = IOServiceGetMatchingServices( ioPort, IOServiceMatching("IOHIDSystem"), &ioIterator );
+    if (status != KERN_SUCCESS) {
+        ioIterator = 0;
+        qWarning() << "could not get an iterator on the I/O Kit services, to access IOHID";
+        return false;
+    }
+    // get the actual IOHID service object:
+    ioObject = IOIteratorNext(ioIterator);
+    if (!ioObject) {
+        qWarning() << "could not get the actual IOHID service object";
+        return false;
+    }
+    IOObjectRetain(ioObject);
+    IOObjectRetain(ioIterator);
 
+    m_idleTimer = new QTimer(this);
+    connect(m_idleTimer, SIGNAL(timeout()), this, SLOT(checkForIdle()));
+#else
     // According to the docs, InstallEventLoopIdleTimer is new in 10.2.
     // According to the headers, it has been around since 10.0.
     // One of them is lying.  We'll play it safe and weak-link the function.
@@ -162,6 +250,7 @@ bool MacPoller::setUpPoller()
     if ((*myInstallEventLoopIdleTimer)(GetMainEventLoop(), kEventDurationSecond, kEventDurationSecond, timerUPP, this, &m_timerRef)) {
         return true;
     }
+#endif
 
     return false;
 }
@@ -173,19 +262,63 @@ QList<int> MacPoller::timeouts() const
 
 void MacPoller::addTimeout(int nextTimeout)
 {
-    m_timeouts.append(nextTimeout);
-    poll();
+    if (!m_timeouts.contains(nextTimeout)) {
+        m_timeouts.append(nextTimeout);
+        if (nextTimeout < m_minTimeout || m_minTimeout < 0) {
+            m_minTimeout = nextTimeout;
+            if (m_idleTimer && m_idleTimer->isActive()) {
+                m_idleTimer->setInterval(nextTimeout);
+            }
+        }
+        qDebug() << "Appended timeout" << nextTimeout << "; min.==" << m_minTimeout;
+        poll(false);
+    }
 }
 
-int MacPoller::poll()
+int MacPoller::poll(bool allowEmit)
 {
+#ifdef USE_IOKIT
+    int idle = 0;
+    kern_return_t status;
+    CFTypeRef cfIdle;
+    CFTypeID type;
+    uint64_t time = 0;
+    CFMutableDictionaryRef properties = 0;
+    status = IORegistryEntryCreateCFProperties( ioObject, &properties, kCFAllocatorDefault, 0 );
+    if (status == KERN_SUCCESS && properties) {
+        cfIdle = CFDictionaryGetValue( properties, CFSTR("HIDIdleTime") );
+        if (cfIdle) {
+            CFRetain(cfIdle);
+            // cfIdle can have different types: handle them properly:
+            type = CFGetTypeID(cfIdle);
+            if (type == CFDataGetTypeID()) {
+                CFDataGetBytes( (CFDataRef)cfIdle, CFRangeMake( 0, sizeof(time) ), (UInt8*)&time );
+            }
+            else if (type == CFNumberGetTypeID()) {
+                CFNumberGetValue( (CFNumberRef)cfIdle, kCFNumberSInt64Type, &time );
+            }
+            CFRelease(cfIdle);
+        }
+        CFRelease( (CFTypeRef)properties );
+        // convert nanoseconds to milliseconds:
+        idle = int(time / 1000000);
+    }
+    m_gotTimeout = false;
+#else
     int idle = m_secondsIdle * 1000;
-
-    // Check if we reached a timeout..
-    Q_FOREACH (int i, m_timeouts) {
-        if ((i - idle < 1000 && i > idle) || (idle - i < 1000 && idle > i)) {
-            // Bingo!
-            emit timeoutReached(i);
+#endif
+
+    if (allowEmit) {
+        Q_FOREACH (int i, m_timeouts) {
+            qDebug() << "Comparing idle" << idle << "to timeout" << i;
+            if ((i - idle < 1000 && i > idle) || (idle - i < 1000 && idle > i)) {
+                // Bingo!
+                m_gotTimeout = true;
+                emit timeoutReached(i);
+//                 // not necessary to update the alarm to fire back if the system gets inactive for the same time
+//                 catchIdleEvent();
+                return idle;
+            }
         }
     }
 
@@ -194,35 +327,82 @@ int MacPoller::poll()
 
 int MacPoller::forcePollRequest()
 {
-    return poll();
+    return poll(false);
 }
 
 void MacPoller::removeTimeout(int timeout)
 {
     m_timeouts.removeOne(timeout);
-    poll();
+    m_minTimeout = -1;
+    Q_FOREACH (int i, m_timeouts) {
+        if (i < m_minTimeout || m_minTimeout < 0) {
+            m_minTimeout = i;
+        }
+    }
+    if (m_idleTimer && m_idleTimer->isActive() && m_minTimeout > 0) {
+        m_idleTimer->setInterval(m_minTimeout);
+    }
+    poll(false);
 }
 
 void MacPoller::catchIdleEvent()
 {
+#ifdef USE_IOKIT
+    if (m_idleTimer) {
+        if (!m_idleTimer->isActive()) {
+            qDebug() << "starting the idletime poll QTimer with interval" << m_idleTimer->interval()
+                << "and m_minTimeout" << m_minTimeout << "; start of catch";
+            m_idleTimer->start( (m_minTimeout>0)? m_minTimeout : 0 );
+        }
+        else {
+            m_idleTimer->setInterval( (m_minTimeout>0)? m_minTimeout : 0 );
+        }
+    }
+#endif
     m_catch = true;
+    m_gotTimeout = false;
 }
 
 void MacPoller::stopCatchingIdleEvents()
 {
+#ifdef USE_IOKIT
+    if (m_idleTimer) {
+        qDebug() << "stopping the idletime poll QTimer; end of catch, idle=" << poll(false);
+// stopCatchingIdleEvents is called after each resumingFromIdle signal??!
+//         qFatal(__FUNCTION__);
+        m_idleTimer->stop();
+    }
+#endif
     m_catch = false;
 }
 
+void MacPoller::checkForIdle()
+{
+#ifdef USE_IOKIT
+    int idle = poll(true);
+    if (idle == 0 && m_catch) {
+        emit resumingFromIdle();
+    }
+#endif
+}
+
 void MacPoller::triggerResume()
 {
+#ifndef USE_IOKIT
     if (m_catch) {
         emit resumingFromIdle();
-        stopCatchingIdleEvents();
     }
+#endif
 }
 
 void MacPoller::simulateUserActivity()
 {
-    // TODO
+    // The alternative is to disable sleep using 
+    //     IOReturn success = IOPMAssertionCreateWithName(kIOPMAssertionTypeNoDisplaySleep,
+    //                                                    kIOPMAssertionLevelOn, CFSTR("simulated user activity"), &assertionID);
+    // coupled with a timer to re-allow sleep, but there are reports that isn't very reliable.
+    if (updateSystemActivity) {
+        (*updateSystemActivity)(UsrActivity);
+    }
 }
 
diff --git src/plugins/osx/macpoller.h src/plugins/osx/macpoller.h
index ef51ea5..c1d7b19 100644
--- src/plugins/osx/macpoller.h
+++ src/plugins/osx/macpoller.h
@@ -21,7 +21,15 @@
 
 #include "abstractsystempoller.h"
 
+#include <QTimer>
+
+// Use IOKIT instead of the deprecated Carbon interface
+#define USE_IOKIT
+#ifdef USE_IOKIT
+#include <IOKit/IOKitLib.h>
+#else
 #include <Carbon/Carbon.h>
+#endif
 
 class MacPoller: public AbstractSystemPoller
 {
@@ -37,9 +45,11 @@ public:
     bool setUpPoller();
     void unloadPoller();
 
+#ifndef USE_IOKIT
     static pascal void IdleTimerAction(EventLoopTimerRef, EventLoopIdleTimerMessage inState, void *inUserData);
+#endif
 
-public Q_SLOTS:
+public:
     void addTimeout(int nextTimeout);
     void removeTimeout(int nextTimeout);
     QList<int> timeouts() const;
@@ -50,12 +60,22 @@ public Q_SLOTS:
     void triggerResume();
 
 private Q_SLOTS:
-    int poll();
+    void checkForIdle();
 
 private:
+    int poll(bool allowEmits);
     QList<int> m_timeouts;
+#ifdef USE_IOKIT
+    mach_port_t ioPort;
+    io_iterator_t ioIterator;
+    io_object_t ioObject;
+    QTimer *m_idleTimer;
+    int m_minTimeout;
+    bool m_gotTimeout;
+#else
     EventLoopTimerRef m_timerRef;
     int m_secondsIdle;
+#endif
     bool m_catch;
 };
 
