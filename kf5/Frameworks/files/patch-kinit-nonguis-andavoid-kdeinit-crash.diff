diff --git src/kdeinit/CMakeLists.txt src/kdeinit/CMakeLists.txt
index f94db71..500fc32 100644
--- src/kdeinit/CMakeLists.txt
+++ src/kdeinit/CMakeLists.txt
@@ -1,6 +1,9 @@
 if (WIN32)
   set(kdeinit_SRCS kinit_win.cpp ../klauncher_cmds.cpp )
   set(kdeinit_LIBS psapi)
+elseif (APPLE)
+  set(kdeinit_SRCS kinit_mac.mm proctitle.cpp ../klauncher_cmds.cpp )
+  set(kdeinit_LIBS "")
 else ()
   set(kdeinit_SRCS kinit.cpp proctitle.cpp ../klauncher_cmds.cpp )
   set(kdeinit_LIBS "")
@@ -11,14 +14,7 @@ include_directories(${KInit_BINARY_DIR}) # for kinit_version.h
 # on win32 kdeinit5 has to be a console application
 # to be able to catch stderr based --verbose output
 add_executable(kdeinit5 ${kdeinit_SRCS})
-if (APPLE)
-  # this has to be GUI on OSX because it launches GUI apps and need a quartz context
-  set_target_properties(kdeinit5 PROPERTIES MACOSX_BUNDLE_INFO_PLIST ${CMAKE_CURRENT_SOURCE_DIR}/Info.plist.template)
-  set_target_properties(kdeinit5 PROPERTIES MACOSX_BUNDLE_GUI_IDENTIFIER "org.kde.kdeinit5")
-  set_target_properties(kdeinit5 PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "KDE Init")
-else ()
-  ecm_mark_nongui_executable(kdeinit5)
-endif ()
+ecm_mark_nongui_executable(kdeinit5)
 
 target_link_libraries(kdeinit5 ${kdeinit_LIBS} ${KINIT_SOCKET_LIBRARY}
     Qt5::Gui #QFont::initialize
@@ -28,6 +24,9 @@ target_link_libraries(kdeinit5 ${kdeinit_LIBS} ${KINIT_SOCKET_LIBRARY}
     KF5::ConfigCore
     Qt5::DBus
 )
+if (APPLE)
+    target_link_libraries(kdeinit5 PUBLIC "-framework Foundation -framework AppKit")
+endif ()
 
 target_compile_definitions(kdeinit5 PRIVATE
     CMAKE_INSTALL_PREFIX="${CMAKE_INSTALL_PREFIX}"
@@ -41,6 +40,15 @@ endif()
 
 install(TARGETS kdeinit5 ${KF5_INSTALL_TARGETS_DEFAULT_ARGS} )
 
+if (APPLE)
+    ########### kdeinit5 helper app ###############
+    set(kdeinit5_proxy_SRCS kdeinit5_proxy.mm)
+    add_executable(kdeinit5_proxy ${kdeinit5_proxy_SRCS})
+    ecm_mark_nongui_executable(kdeinit5_proxy)
+    target_link_libraries(kdeinit5_proxy Qt5::Core "-framework Foundation")
+    install(TARGETS kdeinit5_proxy DESTINATION ${CMAKE_INSTALL_FULL_LIBEXECDIR_KF5} )
+endif ()
+
 if (NOT WIN32)
   # kdeinit5_shutdown
   add_executable(kdeinit5_shutdown ../wrapper.cpp)
diff --git src/kdeinit/kdeinit5_proxy.mm src/kdeinit/kdeinit5_proxy.mm
new file mode 100644
index 0000000..97faf1a
--- /dev/null
+++ src/kdeinit/kdeinit5_proxy.mm
@@ -0,0 +1,79 @@
+/*
+  This file is part of the KDE libraries
+  Copyright (c) 2009 Jeremy Lainé <sharky@macports.org>
+            (c) 2009 Jeremy Lavergne <snc@macports.org>
+            (c) 2015 René J.V. Bertin <rjvbertin@gmail.com>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Library General Public
+  License version 2 as published by the Free Software Foundation.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Library General Public License for more details.
+
+  You should have received a copy of the GNU Library General Public License
+  along with this library; see the file COPYING.LIB.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+*/
+
+#include <stdlib.h>
+#include <libgen.h>
+
+#include <QtCore/QLibrary>
+#include <QtCore/QString>
+#include <QtCore/QFile>
+#include <QtCore/QFileInfo>
+#include <QCoreApplication>
+#include <QDebug>
+
+#import <Foundation/Foundation.h>
+
+typedef int (*handler) (int, char *[]);
+
+// NB: this application should refrain from using unsafe non-POSIX APIs, or else
+// it will no longer be able to serve its function.
+// As of this writing (Qt 5.5.1) the functions used from QtCore are safe.
+int main(int argc, char *argv[])
+{
+    if (argc < 2) {
+        qWarning() << "Too few arguments";
+        exit(1);
+    }
+
+    QString libpath = QFile::decodeName(argv[argc-1]);
+    QLibrary l(libpath);
+
+    if (!libpath.isEmpty() && (!l.load() || !l.isLoaded())) {
+        qWarning() << "Could not open library" << libpath << ":" << l.errorString();
+        exit(1);
+    }
+
+    QFunctionPointer sym = l.resolve( "kdeinitmain");
+    if (!sym) {
+        sym = l.resolve( "kdemain" );
+        if ( !sym ) {
+            qWarning() << "Could not find the kdemain function:" << l.errorString();
+            exit(1);
+        }
+    }
+
+    // attempt to set the correct application name
+    QFileInfo fi(libpath);
+    [[NSProcessInfo processInfo] setProcessName:(NSString*)fi.baseName().toCFString()];
+    qApp->setApplicationName(fi.baseName());
+    const char *bname = fi.baseName().toLocal8Bit().constData();
+    int len0 = strlen(argv[0]),
+        len1 = strlen(bname);
+    if (len1 <= len0) {
+        strcpy(argv[0], bname);
+        for (int i = len1 ; i <len0 ; ++i) {
+            argv[0][i] = '\0';
+        }
+    }
+    handler func = (int (*)(int, char *[])) sym;
+    exit( func(argc - 1, argv)); /* Launch! */
+}
+
diff --git src/kdeinit/kinit.cpp src/kdeinit/kinit.cpp
index a18008a..bbe7b63 100644
--- src/kdeinit/kinit.cpp
+++ src/kdeinit/kinit.cpp
@@ -64,14 +64,6 @@
 #endif
 #endif
 
-#ifdef Q_OS_MAC
-#include <CoreFoundation/CFBundle.h>
-#include <CoreFoundation/CFString.h>
-#include <CoreFoundation/CFURL.h>
-#include <crt_externs.h> // for _NSGetArgc and friends
-#include <mach-o/dyld.h> // for _NSGetExecutablePath
-#endif
-
 #include <kinit_version.h>
 
 #include "klauncher_cmds.h"
@@ -85,13 +77,6 @@
 #include <qstandardpaths.h>
 
 #ifdef Q_OS_UNIX
-#ifdef Q_OS_MAC
-static const char *extra_libs[] = {
-    "libKF5KIOCore.5.dylib",
-    "libKF5Parts.5.dylib",
-    "libKF5Plasma.5.dylib"
-};
-#else
 //TODO: make sure what libraries we want here...
 static const char *extra_libs[] = {
     "libKF5KIOCore.so.5",
@@ -101,7 +86,6 @@ static const char *extra_libs[] = {
 //#endif
 };
 #endif
-#endif
 
 // #define SKIP_PROCTITLE 1
 
@@ -126,8 +110,6 @@ static const char* displayEnvVarName_c()
     // Can't use QGuiApplication::platformName() here, there is no app instance.
 #if HAVE_X11
     return "DISPLAY";
-#elif defined(Q_OS_MACX)
-    return "MAC_DISPLAY";
 #elif defined(Q_OS_WIN)
     return "WIN_DISPLAY";
 #endif
@@ -550,9 +532,6 @@ static pid_t launch(int argc, const char *_name, const char *args,
 #endif
     // find out this path before forking, doing it afterwards
     // crashes on some platforms, notably OSX
-#ifdef Q_OS_MAC
-    const QString bundlepath = QStandardPaths::findExecutable(QFile::decodeName(execpath));
-#endif
 
     d.errorMsg = 0;
     d.fork = fork();
@@ -615,14 +594,6 @@ static pid_t launch(int argc, const char *_name, const char *args,
             QByteArray procTitle;
             d.argv = (char **) malloc(sizeof(char *) * (argc + 1));
             d.argv[0] = (char *) _name;
-#ifdef Q_OS_MAC
-            QString argvexe = QStandardPaths::findExecutable(QString::fromLatin1(d.argv[0]));
-            if (!argvexe.isEmpty()) {
-                QByteArray cstr = argvexe.toLocal8Bit();
-                // qDebug() << "kdeinit5: launch() setting argv: " << cstr.data();
-                d.argv[0] = strdup(cstr.data());
-            }
-#endif
             for (int i = 1;  i < argc; i++) {
                 d.argv[i] = (char *) args;
                 procTitle += ' ';
@@ -699,11 +670,6 @@ static pid_t launch(int argc, const char *_name, const char *args,
             setup_tty(tty);
 
             QByteArray executable = execpath;
-#ifdef Q_OS_MAC
-            if (!bundlepath.isEmpty()) {
-                executable = QFile::encodeName(bundlepath);
-            }
-#endif
 
             if (!executable.isEmpty()) {
                 execvp(executable.constData(), d.argv);
@@ -1576,58 +1542,6 @@ static QString findSharedLib(const QString &lib)
     return QString();
 }
 
-#ifdef Q_OS_MAC
-/**
- Calling CoreFoundation APIs (which is unavoidable in Qt/Mac) has always had issues
- on Mac OS X, but as of 10.5 is explicitly disallowed with an exception.  As a
- result, in the case where we would normally fork and then dlopen code, or continue
- to run other code, we must now fork-and-exec.
-
- See "CoreFoundation and fork()" at http://developer.apple.com/releasenotes/CoreFoundation/CoreFoundation.html
-*/
-// Copied from kkernel_mac.cpp
-void
-mac_fork_and_reexec_self()
-{
-    int argc = *_NSGetArgc();
-    char **argv = *_NSGetArgv();
-    char *newargv[argc + 2];
-    char progname[PATH_MAX];
-    uint32_t buflen = PATH_MAX;
-    _NSGetExecutablePath(progname, &buflen);
-    bool found_psn = false;
-
-    for (int i = 0; i < argc; i++) {
-        newargv[i] = argv[i];
-    }
-
-    newargv[argc] = "--nofork";
-    newargv[argc + 1] = NULL;
-
-    int x_fork_result = fork();
-    switch (x_fork_result) {
-
-    case -1:
-#ifndef NDEBUG
-        fprintf(stderr, "Mac OS X workaround fork() failed!\n");
-#endif
-        ::_exit(255);
-        break;
-
-    case 0:
-        // Child
-        execvp(progname, newargv);
-        break;
-
-    default:
-        // Parent
-        _exit(0);
-        break;
-
-    }
-}
-#endif
-
 extern "C" {
 
     static void secondary_child_handler(int)
@@ -1704,9 +1618,6 @@ int main(int argc, char **argv)
     (void)dup2(2, 1);
 
     if (do_fork) {
-#ifdef Q_OS_MAC
-        mac_fork_and_reexec_self();
-#else
         if (pipe(d.initpipe) != 0) {
             perror("kdeinit5: pipe failed");
             return 1;
@@ -1730,7 +1641,6 @@ int main(int argc, char **argv)
         }
         close(d.initpipe[0]);
         d.initpipe[0] = -1;
-#endif
     }
 
     /** Make process group leader (for shutting down children later) **/
diff --git src/kdeinit/kinit_mac.mm src/kdeinit/kinit_mac.mm
new file mode 100644
index 0000000..62d3329
--- /dev/null
+++ src/kdeinit/kinit_mac.mm
@@ -0,0 +1,1474 @@
+/*
+ * This file is part of the KDE libraries
+ * Copyright (c) 1999-2000 Waldo Bastian <bastian@kde.org>
+ *           (c) 1999 Mario Weilguni <mweilguni@sime.com>
+ *           (c) 2001 Lubos Lunak <l.lunak@kde.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License version 2 as published by the Free Software Foundation.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include <config-kdeinit.h>
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/stat.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/wait.h>
+#if HAVE_SYS_SELECT_H
+#include <sys/select.h>     // Needed on some systems.
+#endif
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include "proctitle.h"
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <locale.h>
+
+#include <QtCore/QLibrary>
+#include <QtCore/QString>
+#include <QtCore/QFile>
+#include <QtCore/QDate>
+#include <QtCore/QDir>
+#include <QtCore/QFileInfo>
+#include <QtCore/QRegExp>
+#include <QCoreApplication>
+#include <QFont>
+#include <kcrash.h>
+#include <kconfig.h>
+#include <klocalizedstring.h>
+#include <QDebug>
+#include <qsavefile.h>
+
+#import <Foundation/Foundation.h>
+#import <AppKit/AppKit.h>
+#include <CoreFoundation/CFBundle.h>
+#include <CoreFoundation/CFString.h>
+#include <CoreFoundation/CFURL.h>
+#include <crt_externs.h> // for _NSGetArgc and friends
+#include <mach-o/dyld.h> // for _NSGetExecutablePath
+
+#include <kinit_version.h>
+
+#include "klauncher_cmds.h"
+
+#include <qstandardpaths.h>
+
+static const char *extra_libs[] = {
+    "libKF5KIOCore.5.dylib",
+    "libKF5Parts.5.dylib",
+    "libKF5Plasma.5.dylib"
+};
+
+// #define SKIP_PROCTITLE 1
+
+namespace KCrash
+{
+extern KCRASH_EXPORT bool loadedByKdeinit;
+}
+
+extern char **environ;
+
+#define MAX_SOCK_FILE 255
+static char sock_file[MAX_SOCK_FILE];
+
+static const char* displayEnvVarName_c()
+{
+    // Can't use QGuiApplication::platformName() here, there is no app instance.
+    return "MAC_DISPLAY";
+}
+
+/* Group data */
+static struct {
+    int maxname;
+    int fd[2];
+    int launcher[2]; /* socket pair for launcher communication */
+    int deadpipe[2]; /* pipe used to detect dead children */
+    int initpipe[2];
+    int wrapper; /* socket for wrapper communication */
+    int accepted_fd; /* socket accepted and that must be closed in the child process */
+    char result;
+    int exit_status;
+    pid_t fork;
+    pid_t launcher_pid;
+    pid_t kded_pid;
+    int n;
+    char **argv;
+    int (*func)(int, char *[]);
+    int (*launcher_func)(int);
+    bool debug_wait;
+    QByteArray errorMsg;
+    bool launcher_ok;
+    bool suicide;
+} d;
+
+struct child {
+    pid_t pid;
+    int sock; /* fd to write message when child is dead*/
+    struct child *next;
+};
+
+static struct child *children;
+
+#if KDEINIT_OOM_PROTECT
+static int oom_pipe = -1;
+#endif
+
+/*
+ * Clean up the file descriptor table by closing all file descriptors
+ * that are still open.
+ *
+ * This function is called very early in the main() function, so that
+ * we don't leak anything that was leaked to us.
+ */
+static void cleanup_fds()
+{
+    int maxfd = FD_SETSIZE;
+    struct rlimit rl;
+    if (getrlimit(RLIMIT_NOFILE, &rl) == 0) {
+        maxfd = rl.rlim_max;
+    }
+    for (int fd = 3; fd < maxfd; ++fd) {
+#if KDEINIT_OOM_PROTECT
+        if (fd != oom_pipe)
+#endif
+            close(fd);
+    }
+}
+
+/*
+ * Close fd's which are only useful for the parent process.
+ * Restore default signal handlers.
+ */
+static void close_fds()
+{
+    while (struct child *child = children) {
+        close(child->sock);
+        children = child->next;
+        free(child);
+    }
+
+    if (d.deadpipe[0] != -1) {
+        close(d.deadpipe[0]);
+        d.deadpipe[0] = -1;
+    }
+
+    if (d.deadpipe[1] != -1) {
+        close(d.deadpipe[1]);
+        d.deadpipe[1] = -1;
+    }
+
+    if (d.initpipe[0] != -1) {
+        close(d.initpipe[0]);
+        d.initpipe[0] = -1;
+    }
+
+    if (d.initpipe[1] != -1) {
+        close(d.initpipe[1]);
+        d.initpipe[1] = -1;
+    }
+
+    if (d.launcher[0] != -1) {
+        close(d.launcher[0]);
+        d.launcher[0] = -1;
+    }
+    if (d.wrapper != -1) {
+        close(d.wrapper);
+        d.wrapper = -1;
+    }
+    if (d.accepted_fd != -1) {
+        close(d.accepted_fd);
+        d.accepted_fd = -1;
+    }
+
+    signal(SIGCHLD, SIG_DFL);
+    signal(SIGPIPE, SIG_DFL);
+}
+
+/* Notify wrapper program that the child it started has finished. */
+static void child_died(pid_t exit_pid, int exit_status)
+{
+    struct child *child, **childptr = &children;
+
+    while ((child = *childptr)) {
+        if (child->pid == exit_pid) {
+            /* Send a message with the return value of the child on the control socket */
+            klauncher_header request_header;
+            long request_data[2];
+            request_header.cmd = LAUNCHER_CHILD_DIED;
+            request_header.arg_length = sizeof(long) * 2;
+            request_data[0] = exit_pid;
+            request_data[1] = exit_status;
+            write(child->sock, &request_header, sizeof(request_header));
+            write(child->sock, request_data, request_header.arg_length);
+            close(child->sock);
+
+            *childptr = child->next;
+            free(child);
+            return;
+        }
+
+        childptr = &child->next;
+    }
+}
+
+static void exitWithErrorMsg(const QString &errorMsg)
+{
+    fprintf(stderr, "%s\n", errorMsg.toLocal8Bit().data());
+    QByteArray utf8ErrorMsg = errorMsg.toUtf8();
+    d.result = 3; // Error with msg
+    write(d.fd[1], &d.result, 1);
+    int l = utf8ErrorMsg.length();
+    write(d.fd[1], &l, sizeof(int));
+    write(d.fd[1], utf8ErrorMsg.data(), l);
+    close(d.fd[1]);
+    exit(255);
+}
+
+static void setup_tty(const char *tty)
+{
+    if (tty == NULL || *tty == '\0') {
+        return;
+    }
+    QFile f(QFile::decodeName(tty));
+    f.open(QFileDevice::WriteOnly);
+    int fd = f.handle();
+
+    if (fd < 0) {
+        perror("kdeinit5: could not open() tty");
+        return;
+    }
+    if (dup2(fd, STDOUT_FILENO) < 0) {
+        perror("kdeinit5: could not dup2() stdout tty");
+    }
+    if (dup2(fd, STDERR_FILENO) < 0) {
+        perror("kdeinit5: could not dup2() stderr tty");
+    }
+    close(fd);
+}
+
+// var has to be e.g. "DISPLAY=", i.e. with =
+const char *get_env_var(const char *var, int envc, const char *envs)
+{
+    if (envc > 0) {
+        // get the var from envs
+        const char *env_l = envs;
+        int ln = strlen(var);
+        for (int i = 0;  i < envc; i++) {
+            if (strncmp(env_l, var, ln) == 0) {
+                return env_l + ln;
+            }
+            while (*env_l != 0) {
+                env_l++;
+            }
+            env_l++;
+        }
+    }
+    return NULL;
+}
+
+QByteArray execpath_avoid_loops(const QByteArray &exec, int envc, const char *envs, bool avoid_loops)
+{
+    QStringList paths;
+    const QRegExp pathSepRegExp(QString::fromLatin1("[:\b]"));
+    if (envc > 0) { /* use the passed environment */
+        const char *path = get_env_var("PATH=", envc, envs);
+        if (path != NULL) {
+            paths = QFile::decodeName(path).split(pathSepRegExp);
+        }
+    } else {
+        paths = QString::fromLocal8Bit(qgetenv("PATH")).split(pathSepRegExp, QString::KeepEmptyParts);
+        paths.prepend(QFile::decodeName(CMAKE_INSTALL_FULL_LIBEXECDIR_KF5));
+    }
+    QString execpath = QStandardPaths::findExecutable(QFile::decodeName(exec), paths);
+    if (avoid_loops && !execpath.isEmpty()) {
+        const int pos = execpath.lastIndexOf(QLatin1Char('/'));
+        const QString bin_path = execpath.left(pos);
+        for (QStringList::Iterator it = paths.begin();
+                it != paths.end();
+                ++it) {
+            if (*it == bin_path || *it == bin_path + QLatin1Char('/')) {
+                paths.erase(it);
+                break; // -->
+            }
+        }
+        execpath = QStandardPaths::findExecutable(QFile::decodeName(exec), paths);
+    }
+    return QFile::encodeName(execpath);
+}
+
+#if KDEINIT_OOM_PROTECT
+static void oom_protect_sighandler(int)
+{
+}
+
+static void reset_oom_protect()
+{
+    if (oom_pipe <= 0) {
+        return;
+    }
+    struct sigaction act, oldact;
+    act.sa_handler = oom_protect_sighandler;
+    act.sa_flags = 0;
+    sigemptyset(&act.sa_mask);
+    sigaction(SIGUSR1, &act, &oldact);
+    sigset_t sigs, oldsigs;
+    sigemptyset(&sigs);
+    sigaddset(&sigs, SIGUSR1);
+    sigprocmask(SIG_BLOCK, &sigs, &oldsigs);
+    pid_t pid = getpid();
+    if (write(oom_pipe, &pid, sizeof(pid_t)) > 0) {
+        sigsuspend(&oldsigs);   // wait for the signal to come
+    } else {
+#ifndef NDEBUG
+        fprintf(stderr, "Failed to reset OOM protection: %d\n", pid);
+#endif
+    }
+    sigprocmask(SIG_SETMASK, &oldsigs, NULL);
+    sigaction(SIGUSR1, &oldact, NULL);
+    close(oom_pipe);
+    oom_pipe = -1;
+}
+#else
+static void reset_oom_protect()
+{
+}
+#endif
+
+static pid_t launch(int argc, const char *_name, const char *args,
+                    const char *cwd = 0, int envc = 0, const char *envs = 0,
+                    bool reset_env = false,
+                    const char *tty = 0, bool avoid_loops = false,
+                    const char *startup_id_str = "0")  // krazy:exclude=doublequote_chars
+{
+    QString lib;
+    QByteArray name;
+    QString libpath;
+    QByteArray execpath;
+    bool libpath_relative = false;
+
+    if (_name[0] != '/') {
+        name = _name;
+        lib = QFile::decodeName(name);
+        libpath = QLatin1String("libkdeinit5_") + lib;
+        libpath_relative = true;
+        execpath = execpath_avoid_loops(name, envc, envs, avoid_loops);
+    } else {
+        name = _name;
+        lib = QFile::decodeName(name);
+        name = name.mid(name.lastIndexOf('/') + 1);
+
+        // FIXME: this .so extension stuff is very Linux-specific
+        // a .so extension can occur on OS X, but the typical extension is .dylib
+        if (lib.endsWith(QLatin1String(".so")) || lib.endsWith(QLatin1String(".dylib"))) {
+            libpath = lib;
+        } else {
+            execpath = _name;
+
+            // Try to match an absolute path to an executable binary (either in
+            // bin/ or in libexec/) to a kdeinit module in the same prefix.
+            //
+            // Note that these *_INSTALL_DIR values should normally relative to
+            // the install prefix, although this may not be the case if the user
+            // has overridden them, and so this search is inherently fragile in
+            // the face of unusual installation layouts.
+            if (lib.contains(QLatin1String(KF5_LIBEXEC_INSTALL_DIR))) {
+                libpath = QString(lib).replace(QLatin1String(KF5_LIBEXEC_INSTALL_DIR),
+                                               QLatin1String(LIB_INSTALL_DIR "/libkdeinit5_")) + QLatin1String(".so");
+            } else if (lib.contains(QLatin1String("/bin/"))) {
+                libpath = QString(lib).replace(QLatin1String("/bin/"),
+                                               QLatin1String(LIB_INSTALL_DIR "/libkdeinit5_")) + QLatin1String(".so");
+            }
+            // Don't confuse the user with "Could not load libkdeinit5_foo.so" if it doesn't exist
+            if (!QFile::exists(libpath)) {
+                libpath.clear();
+            }
+        }
+    }
+#ifndef NDEBUG
+    fprintf(stderr, "kdeinit5: preparing to launch '%s'\n", libpath.isEmpty()
+            ? execpath.constData() : libpath.toUtf8().constData());
+#endif
+    if (!args) {
+        argc = 1;
+    }
+
+    if (0 > pipe(d.fd)) {
+        perror("kdeinit5: pipe() failed");
+        d.result = 3;
+        d.errorMsg = i18n("Unable to start new process.\n"
+                          "The system may have reached the maximum number of open files possible or the maximum number of open files that you are allowed to use has been reached.").toUtf8();
+        d.fork = 0;
+        return d.fork;
+    }
+
+    // find out this path before forking, doing it afterwards
+    // crashes on some platforms, notably OSX
+    const QString bundlepath = QStandardPaths::findExecutable(QFile::decodeName(execpath));
+
+    // Don't run this inside the child process, it crashes on OS/X 10.6 and higher;
+    // use an additional helper proxy instead, one that will not have used any
+    // non-POSIX APIs.
+    // Find the helper using our own function that will be able to find it for us.
+    const QByteArray helperexe = execpath_avoid_loops("kdeinit5_proxy", 0, 0, false);
+    const QString argvexe = QStandardPaths::findExecutable(QString::fromLatin1(_name));
+
+    d.errorMsg = 0;
+    d.fork = fork();
+    switch (d.fork) {
+    case -1:
+        perror("kdeinit5: fork() failed");
+        d.result = 3;
+        d.errorMsg = i18n("Unable to create new process.\n"
+                          "The system may have reached the maximum number of processes possible or the maximum number of processes that you are allowed to use has been reached.").toUtf8();
+        close(d.fd[0]);
+        close(d.fd[1]);
+        d.fork = 0;
+        break;
+    case 0: {
+        /** Child **/
+        close(d.fd[0]);
+        close_fds();
+        reset_oom_protect();
+
+        // Try to chdir, either to the requested directory or to the user's document path by default.
+        // We ignore errors - if you write a desktop file with Exec=foo and Path=/doesnotexist,
+        // we still want to execute `foo` even if the chdir() failed.
+        if (cwd && *cwd) {
+            (void)chdir(cwd);
+        }
+
+        if (reset_env) { // KWRAPPER/SHELL
+
+            QList<QByteArray> unset_envs;
+            for (int tmp_env_count = 0;
+                    environ[tmp_env_count];
+                    tmp_env_count++) {
+                unset_envs.append(environ[ tmp_env_count ]);
+            }
+            foreach (const QByteArray &tmp, unset_envs) {
+                int pos = tmp.indexOf('=');
+                if (pos >= 0) {
+                    unsetenv(tmp.left(pos).constData());
+                }
+            }
+        }
+
+        for (int i = 0;  i < envc; i++) {
+            putenv((char *)envs);
+            while (*envs != 0) {
+                envs++;
+            }
+            envs++;
+        }
+
+        {
+            QByteArray procTitle;
+            if (execpath.isEmpty()) {
+                // launching from a shared library: need to use the helper proxy
+                d.argv = (char **) malloc(sizeof(char *) * (argc + 2));
+            } else {
+                // launching an executable: can do an exec directly
+                d.argv = (char **) malloc(sizeof(char *) * (argc + 1));
+            }
+            if (!argvexe.isEmpty()) {
+                QByteArray cstr = argvexe.toLocal8Bit();
+                d.argv[0] = strdup(cstr.data());
+            } else {
+                d.argv[0] = (char *) _name;
+            }
+            for (int i = 1;  i < argc; i++) {
+                d.argv[i] = (char *) args;
+                procTitle += ' ';
+                procTitle += (char *) args;
+                while (*args != 0) {
+                    args++;
+                }
+                args++;
+            }
+            d.argv[argc] = 0;
+
+#ifndef SKIP_PROCTITLE
+            /** Give the process a new name **/
+            proctitle_set("%s%s", name.data(), procTitle.data() ? procTitle.data() : "");
+#endif
+        }
+
+        if (libpath.isEmpty() && execpath.isEmpty()) {
+            QString errorMsg = i18n("Could not find '%1' executable.", QFile::decodeName(_name));
+            exitWithErrorMsg(errorMsg);
+        }
+
+        if (!qgetenv("KDE_IS_PRELINKED").isEmpty() && !execpath.isEmpty()) {
+            libpath.truncate(0);
+        }
+
+        if (!execpath.isEmpty()) {
+            // we're launching an executable; even after a fork and being exec'ed, that
+            // executable is allowed to use non-POSIX APIs.
+            d.result = 2; // Try execing
+            write(d.fd[1], &d.result, 1);
+
+            // We set the close on exec flag.
+            // Closing of d.fd[1] indicates that the execvp succeeded!
+            fcntl(d.fd[1], F_SETFD, FD_CLOEXEC);
+
+            setup_tty(tty);
+
+            QByteArray executable = execpath;
+            if (!bundlepath.isEmpty()) {
+                executable = QFile::encodeName(bundlepath);
+            }
+            // TODO: we probably want to use [[NSProcessInfo processInfo] setProcessName:NSString*] here to
+            // make the new app show up under its own name in non-POSIX process listings.
+
+            if (!executable.isEmpty()) {
+#ifndef NDEBUG
+                qDebug() << "execvp" << executable;
+                for (int i = 0 ; i < argc ; ++i) {
+                    qDebug() << "arg #" << i << "=" << d.argv[i];
+                }
+#endif
+                // attempt to the correct application name
+                QFileInfo fi(QString::fromUtf8(executable));
+                [[NSProcessInfo processInfo] setProcessName:(NSString*)fi.baseName().toCFString()];
+                qApp->setApplicationName(fi.baseName());
+                [NSApp activateIgnoringOtherApps:YES];
+                execvp(executable.constData(), d.argv);
+            }
+
+            d.result = 1; // Error
+            write(d.fd[1], &d.result, 1);
+            close(d.fd[1]);
+            exit(255);
+        }
+
+        // if we are here that means we've been asked to launch kdeinitmain or kdemain from
+        // a shared library. On OS X we cannot just dlopen the library, fetch the function
+        // and call it; that would crash during the dlopen (unless by chance the library doesn't)
+        // call any non-POSIX APIs, which about impossible for KDE applications).
+        // Therefore, we use the helper application; dlopen'ing the library is allowed and safe
+        // after a new command (the helper) has been started through exec (ditto the subsequent steps).
+        d.result = 2; // Try exec'ing
+        write(d.fd[1], &d.result, 1);
+        // We set the close on exec flag.
+        // Closing of d.fd[1] indicates that the execvp succeeded.
+        fcntl(d.fd[1], F_SETFD, FD_CLOEXEC);
+        if (d.debug_wait) {
+            fprintf(stderr, "kdeinit5: Suspending process\n"
+                    "kdeinit5: 'lldb -p %d' to debug\n"
+                    "kdeinit5: 'kill -SIGCONT %d' to continue\n",
+                    getpid(), getpid());
+            kill(getpid(), SIGSTOP);
+        } else {
+            setup_tty(tty);
+        }
+
+        QByteArray libpathbytes = QFile::encodeName(libpath);
+        d.argv[argc] = libpathbytes.data();
+        d.argv[argc+1] = 0;
+
+#ifndef NDEBUG
+        qDebug() << "execvp" << helperexe;
+        for (int i = 0 ; i <= argc ; ++i) {
+            qDebug() << "arg #" << i << "=" << d.argv[i];
+        }
+#endif
+        if (!helperexe.isEmpty()) {
+            execvp(helperexe.constData(), d.argv);
+        } else {
+            qWarning() << "Failed to find kdeinit5 helper application \"kdeinit5_proxy\"";
+        }
+
+        d.result = 1; // Error
+        write(d.fd[1], &d.result, 1);
+        close(d.fd[1]);
+        exit(255);
+
+        break;
+    }
+    default:
+        /** Parent **/
+        close(d.fd[1]);
+        bool exec = false;
+        for (;;) {
+            d.n = read(d.fd[0], &d.result, 1);
+            if (d.n == 1) {
+                if (d.result == 2) {
+#ifndef NDEBUG
+                    //fprintf(stderr, "kdeinit5: no kdeinit module, trying exec....\n");
+#endif
+                    exec = true;
+                    continue;
+                }
+                if (d.result == 3) {
+                    int l = 0;
+                    d.n = read(d.fd[0], &l, sizeof(int));
+                    if (d.n == sizeof(int)) {
+                        QByteArray tmp;
+                        tmp.resize(l + 1);
+                        d.n = read(d.fd[0], tmp.data(), l);
+                        tmp[l] = 0;
+                        if (d.n == l) {
+                            d.errorMsg = tmp;
+                        }
+                    }
+                }
+                // Finished
+                break;
+            }
+            if (d.n == -1) {
+                if (errno == ECHILD) {  // a child died.
+                    continue;
+                }
+                if (errno == EINTR || errno == EAGAIN) { // interrupted or more to read
+                    continue;
+                }
+            }
+            if (d.n == 0) {
+                if (exec) {
+                    d.result = 0;
+                } else {
+                    fprintf(stderr, "kdeinit5: (%s %s) Pipe closed unexpectedly", name.constData(), execpath.constData());
+                    perror("kdeinit5: Pipe closed unexpectedly");
+                    d.result = 1; // Error
+                }
+                break;
+            }
+            perror("kdeinit5: Error reading from pipe");
+            d.result = 1; // Error
+            break;
+        }
+        close(d.fd[0]);
+    }
+    return d.fork;
+}
+
+extern "C" {
+
+    static void sig_child_handler(int)
+    {
+        /*
+         * Write into the pipe of death.
+         * This way we are sure that we return from the select()
+         *
+         * A signal itself causes select to return as well, but
+         * this creates a race-condition in case the signal arrives
+         * just before we enter the select.
+         */
+        char c = 0;
+        write(d.deadpipe[1], &c, 1);
+    }
+
+}
+
+static void init_signals()
+{
+    struct sigaction act;
+    long options;
+
+    if (pipe(d.deadpipe) != 0) {
+        perror("kdeinit5: Aborting. Can not create pipe");
+        exit(255);
+    }
+
+    options = fcntl(d.deadpipe[0], F_GETFL);
+    if (options == -1) {
+        perror("kdeinit5: Aborting. Can not make pipe non-blocking");
+        exit(255);
+    }
+
+    if (fcntl(d.deadpipe[0], F_SETFL, options | O_NONBLOCK) == -1) {
+        perror("kdeinit5: Aborting. Can not make pipe non-blocking");
+        exit(255);
+    }
+
+    /*
+     * A SIGCHLD handler is installed which sends a byte into the
+     * pipe of death. This is to ensure that a dying child causes
+     * an exit from select().
+     */
+    act.sa_handler = sig_child_handler;
+    sigemptyset(&(act.sa_mask));
+    sigaddset(&(act.sa_mask), SIGCHLD);
+    sigprocmask(SIG_UNBLOCK, &(act.sa_mask), 0L);
+    act.sa_flags = SA_NOCLDSTOP;
+
+    // CC: take care of SunOS which automatically restarts interrupted system
+    // calls (and thus does not have SA_RESTART)
+
+#ifdef SA_RESTART
+    act.sa_flags |= SA_RESTART;
+#endif
+    sigaction(SIGCHLD, &act, 0L);
+
+    act.sa_handler = SIG_IGN;
+    sigemptyset(&(act.sa_mask));
+    sigaddset(&(act.sa_mask), SIGPIPE);
+    sigprocmask(SIG_UNBLOCK, &(act.sa_mask), 0L);
+    act.sa_flags = 0;
+    sigaction(SIGPIPE, &act, 0L);
+}
+
+static void init_kdeinit_socket()
+{
+    struct sockaddr_un sa;
+    kde_socklen_t socklen;
+    long options;
+    const QByteArray home_dir = qgetenv("HOME");
+    int max_tries = 10;
+    if (home_dir.isEmpty()) {
+        fprintf(stderr, "kdeinit5: Aborting. $HOME not set!");
+        exit(255);
+    }
+    if (chdir(home_dir.constData()) != 0) {
+        fprintf(stderr, "kdeinit5: Aborting. Couldn't enter '%s'!", home_dir.constData());
+        exit(255);
+    }
+
+    {
+        QByteArray path = home_dir;
+        QByteArray readOnly = qgetenv("KDE_HOME_READONLY");
+        if (access(path.data(), R_OK | W_OK)) {
+            if (errno == ENOENT) {
+                fprintf(stderr, "kdeinit5: Aborting. $HOME directory (%s) does not exist.\n", path.data());
+                exit(255);
+            } else if (readOnly.isEmpty()) {
+                fprintf(stderr, "kdeinit5: Aborting. No write access to $HOME directory (%s).\n", path.data());
+                exit(255);
+            }
+        }
+    }
+
+    /** Test if socket file is already present
+     *  note that access() resolves symlinks, and so we check the actual
+     *  socket file if it exists
+     */
+    if (access(sock_file, W_OK) == 0) {
+        int s;
+        struct sockaddr_un server;
+
+//     fprintf(stderr, "kdeinit5: Warning, socket_file already exists!\n");
+        /*
+         * create the socket stream
+         */
+        s = socket(PF_UNIX, SOCK_STREAM, 0);
+        if (s < 0) {
+            perror("socket() failed");
+            exit(255);
+        }
+        server.sun_family = AF_UNIX;
+        qstrncpy(server.sun_path, sock_file, sizeof(server.sun_path));
+        socklen = sizeof(server);
+
+        if (connect(s, (struct sockaddr *)&server, socklen) == 0) {
+            fprintf(stderr, "kdeinit5: Shutting down running client.\n");
+            klauncher_header request_header;
+            request_header.cmd = LAUNCHER_TERMINATE_KDEINIT;
+            request_header.arg_length = 0;
+            write(s, &request_header, sizeof(request_header));
+            sleep(1); // Give it some time
+        }
+        close(s);
+    }
+
+    /** Delete any stale socket file (and symlink) **/
+    unlink(sock_file);
+
+    /** create socket **/
+    d.wrapper = socket(PF_UNIX, SOCK_STREAM, 0);
+    if (d.wrapper < 0) {
+        perror("kdeinit5: Aborting. socket() failed");
+        exit(255);
+    }
+
+    options = fcntl(d.wrapper, F_GETFL);
+    if (options == -1) {
+        perror("kdeinit5: Aborting. Can not make socket non-blocking");
+        close(d.wrapper);
+        exit(255);
+    }
+
+    if (fcntl(d.wrapper, F_SETFL, options | O_NONBLOCK) == -1) {
+        perror("kdeinit5: Aborting. Can not make socket non-blocking");
+        close(d.wrapper);
+        exit(255);
+    }
+
+    while (1) {
+        /** bind it **/
+        socklen = sizeof(sa);
+        memset(&sa, 0, socklen);
+        sa.sun_family = AF_UNIX;
+        strcpy(sa.sun_path, sock_file);
+        if (bind(d.wrapper, (struct sockaddr *)&sa, socklen) != 0) {
+            if (max_tries == 0) {
+                perror("kdeinit5: Aborting. bind() failed");
+                fprintf(stderr, "Could not bind to socket '%s'\n", sock_file);
+                close(d.wrapper);
+                exit(255);
+            }
+            max_tries--;
+        } else {
+            break;
+        }
+    }
+
+    /** set permissions **/
+    if (chmod(sock_file, 0600) != 0) {
+        perror("kdeinit5: Aborting. Can not set permissions on socket");
+        fprintf(stderr, "Wrong permissions of socket '%s'\n", sock_file);
+        unlink(sock_file);
+        close(d.wrapper);
+        exit(255);
+    }
+
+    if (listen(d.wrapper, SOMAXCONN) < 0) {
+        perror("kdeinit5: Aborting. listen() failed");
+        unlink(sock_file);
+        close(d.wrapper);
+        exit(255);
+    }
+}
+
+/*
+ * Read 'len' bytes from 'sock' into buffer.
+ * returns 0 on success, -1 on failure.
+ */
+static int read_socket(int sock, char *buffer, int len)
+{
+    ssize_t result;
+    int bytes_left = len;
+    while (bytes_left > 0) {
+        result = read(sock, buffer, bytes_left);
+        if (result > 0) {
+            buffer += result;
+            bytes_left -= result;
+        } else if (result == 0) {
+            return -1;
+        } else if ((result == -1) && (errno != EINTR) && (errno != EAGAIN)) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+static void start_klauncher()
+{
+    if (socketpair(AF_UNIX, SOCK_STREAM, 0, d.launcher) < 0) {
+        perror("kdeinit5: socketpair() failed");
+        exit(255);
+    }
+    char args[32];
+    strcpy(args, "--fd=");
+    sprintf(args + 5, "%d", d.launcher[1]);
+    d.launcher_pid = launch(2, "klauncher", args);
+    close(d.launcher[1]);
+#ifndef NDEBUG
+    fprintf(stderr, "kdeinit5: Launched KLauncher, pid = %ld, result = %d\n",
+            (long) d.launcher_pid, d.result);
+#endif
+}
+
+static void launcher_died()
+{
+    if (!d.launcher_ok) {
+        /* This is bad. */
+        fprintf(stderr, "kdeinit5: Communication error with launcher. Exiting!\n");
+        ::exit(255);
+        return;
+    }
+
+    // KLauncher died... restart
+#ifndef NDEBUG
+    fprintf(stderr, "kdeinit5: KLauncher died unexpectedly.\n");
+#endif
+    // Make sure it's really dead.
+    if (d.launcher_pid) {
+        kill(d.launcher_pid, SIGKILL);
+        sleep(1); // Give it some time
+    }
+
+    d.launcher_ok = false;
+    d.launcher_pid = 0;
+    close(d.launcher[0]);
+    d.launcher[0] = -1;
+
+    start_klauncher();
+}
+
+static bool handle_launcher_request(int sock, const char *who)
+{
+    (void)who; // for NDEBUG
+
+    klauncher_header request_header;
+    char *request_data = 0L;
+    int result = read_socket(sock, (char *) &request_header, sizeof(request_header));
+    if (result != 0) {
+        return false;
+    }
+
+    if (request_header.arg_length != 0) {
+        request_data = (char *) malloc(request_header.arg_length + 1);
+        request_data[request_header.arg_length] = '\0';
+
+        result = read_socket(sock, request_data, request_header.arg_length);
+        if (result != 0) {
+            free(request_data);
+            return false;
+        }
+    }
+
+    //qDebug() << "Got cmd" << request_header.cmd << commandToString(request_header.cmd);
+    if (request_header.cmd == LAUNCHER_OK) {
+        d.launcher_ok = true;
+    } else if (request_header.arg_length &&
+               ((request_header.cmd == LAUNCHER_EXEC) ||
+                (request_header.cmd == LAUNCHER_EXT_EXEC) ||
+                (request_header.cmd == LAUNCHER_SHELL) ||
+                (request_header.cmd == LAUNCHER_KWRAPPER) ||
+                (request_header.cmd == LAUNCHER_EXEC_NEW))) {
+        pid_t pid;
+        klauncher_header response_header;
+        long response_data;
+        long l;
+        memcpy(&l, request_data, sizeof(long));
+        int argc = l;
+        const char *name = request_data + sizeof(long);
+        const char *args = name + strlen(name) + 1;
+        const char *cwd = 0;
+        int envc = 0;
+        const char *envs = 0;
+        const char *tty = 0;
+        int avoid_loops = 0;
+        const char *startup_id_str = "0"; // krazy:exclude=doublequote_chars
+
+#ifndef NDEBUG
+        fprintf(stderr, "kdeinit5: Got %s '%s' from %s.\n",
+                commandToString(request_header.cmd),
+                name, who);
+#endif
+
+        const char *arg_n = args;
+        for (int i = 1; i < argc; i++) {
+            arg_n = arg_n + strlen(arg_n) + 1;
+        }
+
+        if (request_header.cmd == LAUNCHER_SHELL || request_header.cmd == LAUNCHER_KWRAPPER) {
+            // Shell or kwrapper
+            cwd = arg_n; arg_n += strlen(cwd) + 1;
+        }
+        if (request_header.cmd == LAUNCHER_SHELL || request_header.cmd == LAUNCHER_KWRAPPER
+                || request_header.cmd == LAUNCHER_EXT_EXEC || request_header.cmd == LAUNCHER_EXEC_NEW) {
+            memcpy(&l, arg_n, sizeof(long));
+            envc = l;
+            arg_n += sizeof(long);
+            envs = arg_n;
+            for (int i = 0; i < envc; i++) {
+                arg_n = arg_n + strlen(arg_n) + 1;
+            }
+            if (request_header.cmd == LAUNCHER_KWRAPPER) {
+                tty = arg_n;
+                arg_n += strlen(tty) + 1;
+            }
+        }
+
+        if (request_header.cmd == LAUNCHER_SHELL || request_header.cmd == LAUNCHER_KWRAPPER
+                || request_header.cmd == LAUNCHER_EXT_EXEC || request_header.cmd == LAUNCHER_EXEC_NEW) {
+            memcpy(&l, arg_n, sizeof(long));
+            avoid_loops = l;
+            arg_n += sizeof(long);
+        }
+
+        if (request_header.cmd == LAUNCHER_SHELL || request_header.cmd == LAUNCHER_KWRAPPER
+                || request_header.cmd == LAUNCHER_EXT_EXEC) {
+            startup_id_str = arg_n;
+            arg_n += strlen(startup_id_str) + 1;
+        }
+
+        if ((request_header.arg_length > (arg_n - request_data)) &&
+                (request_header.cmd == LAUNCHER_EXT_EXEC || request_header.cmd == LAUNCHER_EXEC_NEW)) {
+            // Optional cwd
+            cwd = arg_n; arg_n += strlen(cwd) + 1;
+        }
+
+        if ((arg_n - request_data) != request_header.arg_length) {
+#ifndef NDEBUG
+            fprintf(stderr, "kdeinit5: EXEC request has invalid format.\n");
+#endif
+            free(request_data);
+            d.debug_wait = false;
+            return true; // sure?
+        }
+
+        // support for the old a bit broken way of setting DISPLAY for multihead
+        QByteArray olddisplay = qgetenv(displayEnvVarName_c());
+        QByteArray kdedisplay = qgetenv("KDE_DISPLAY");
+        bool reset_display = (! olddisplay.isEmpty() &&
+                              ! kdedisplay.isEmpty() &&
+                              olddisplay != kdedisplay);
+
+        if (reset_display) {
+            qputenv(displayEnvVarName_c(), kdedisplay);
+        }
+
+        pid = launch(argc, name, args, cwd, envc, envs,
+                     request_header.cmd == LAUNCHER_SHELL || request_header.cmd == LAUNCHER_KWRAPPER,
+                     tty, avoid_loops, startup_id_str);
+
+        if (reset_display) {
+            unsetenv("KDE_DISPLAY");
+            qputenv(displayEnvVarName_c(), olddisplay);
+        }
+
+        if (pid && (d.result == 0)) {
+            response_header.cmd = LAUNCHER_OK;
+            response_header.arg_length = sizeof(response_data);
+            response_data = pid;
+            write(sock, &response_header, sizeof(response_header));
+            write(sock, &response_data, response_header.arg_length);
+
+            /* add new child to list */
+            struct child *child = (struct child *) malloc(sizeof(struct child));
+            child->pid = pid;
+            child->sock = dup(sock);
+            child->next = children;
+            children = child;
+        } else {
+            int l = d.errorMsg.length();
+            if (l) {
+                l++;    // Include trailing null.
+            }
+            response_header.cmd = LAUNCHER_ERROR;
+            response_header.arg_length = l;
+            write(sock, &response_header, sizeof(response_header));
+            if (l) {
+                write(sock, d.errorMsg.data(), l);
+            }
+        }
+        d.debug_wait = false;
+    } else if (request_header.arg_length && request_header.cmd == LAUNCHER_SETENV) {
+        const char *env_name;
+        const char *env_value;
+        env_name = request_data;
+        env_value = env_name + strlen(env_name) + 1;
+
+#ifndef NDEBUG
+        fprintf(stderr, "kdeinit5: Got SETENV '%s=%s' from %s.\n", env_name, env_value, who);
+#endif
+
+        if (request_header.arg_length !=
+                (int)(strlen(env_name) + strlen(env_value) + 2)) {
+#ifndef NDEBUG
+            fprintf(stderr, "kdeinit5: SETENV request has invalid format.\n");
+#endif
+            free(request_data);
+            return true; // sure?
+        }
+        qputenv(env_name, env_value);
+    } else if (request_header.cmd == LAUNCHER_TERMINATE_KDE) {
+#ifndef NDEBUG
+        fprintf(stderr, "kdeinit5: terminate KDE.\n");
+#endif
+    } else if (request_header.cmd == LAUNCHER_TERMINATE_KDEINIT) {
+#ifndef NDEBUG
+        fprintf(stderr, "kdeinit5: Got termination request (PID %ld).\n", (long) getpid());
+#endif
+        if (d.launcher_pid) {
+            kill(d.launcher_pid, SIGTERM);
+            d.launcher_pid = 0;
+            close(d.launcher[0]);
+            d.launcher[0] = -1;
+        }
+        unlink(sock_file);
+        if (children) {
+            close(d.wrapper);
+            d.wrapper = -1;
+#ifndef NDEBUG
+            fprintf(stderr, "kdeinit5: Closed sockets, but not exiting until all children terminate.\n");
+#endif
+        } else {
+            raise(SIGTERM);
+        }
+    } else if (request_header.cmd == LAUNCHER_DEBUG_WAIT) {
+#ifndef NDEBUG
+        fprintf(stderr, "kdeinit5: Debug wait activated.\n");
+#endif
+        d.debug_wait = true;
+    }
+    if (request_data) {
+        free(request_data);
+    }
+    return true;
+}
+
+static void handle_requests(pid_t waitForPid)
+{
+    int max_sock = d.deadpipe[0];
+    if (d.wrapper > max_sock) {
+        max_sock = d.wrapper;
+    }
+    if (d.launcher[0] > max_sock) {
+        max_sock = d.launcher[0];
+    }
+    max_sock++;
+
+    while (1) {
+        fd_set rd_set;
+        fd_set wr_set;
+        fd_set e_set;
+        int result;
+        pid_t exit_pid;
+        int exit_status;
+        char c;
+
+        /* Flush the pipe of death */
+        while (read(d.deadpipe[0], &c, 1) == 1) {
+        }
+
+        /* Handle dying children */
+        do {
+            exit_pid = waitpid(-1, &exit_status, WNOHANG);
+            if (exit_pid > 0) {
+#ifndef NDEBUG
+                fprintf(stderr, "kdeinit5: PID %ld terminated.\n", (long) exit_pid);
+#endif
+                if (waitForPid && (exit_pid == waitForPid)) {
+                    return;
+                }
+
+                if (WIFEXITED(exit_status)) { // fix process return value
+                    exit_status = WEXITSTATUS(exit_status);
+                } else if (WIFSIGNALED(exit_status)) {
+                    exit_status = 128 + WTERMSIG(exit_status);
+                }
+                child_died(exit_pid, exit_status);
+
+                if (d.wrapper < 0 && !children) {
+#ifndef NDEBUG
+                    fprintf(stderr, "kdeinit5: Last child terminated, exiting (PID %ld).\n",
+                            (long) getpid());
+#endif
+                    raise(SIGTERM);
+                }
+            }
+        } while (exit_pid > 0);
+
+        FD_ZERO(&rd_set);
+        FD_ZERO(&wr_set);
+        FD_ZERO(&e_set);
+
+        if (d.launcher[0] >= 0) {
+            FD_SET(d.launcher[0], &rd_set);
+        }
+        if (d.wrapper >= 0) {
+            FD_SET(d.wrapper, &rd_set);
+        }
+        FD_SET(d.deadpipe[0], &rd_set);
+
+        result = select(max_sock, &rd_set, &wr_set, &e_set, 0);
+        if (result < 0) {
+            if (errno == EINTR || errno == EAGAIN) {
+                continue;
+            }
+            perror("kdeinit5: Aborting. select() failed");
+            return;
+        }
+
+        /* Handle wrapper request */
+        if (d.wrapper >= 0 && FD_ISSET(d.wrapper, &rd_set)) {
+            struct sockaddr_un client;
+            kde_socklen_t sClient = sizeof(client);
+            int sock = accept(d.wrapper, (struct sockaddr *)&client, &sClient);
+            if (sock >= 0) {
+                d.accepted_fd = sock;
+                handle_launcher_request(sock, "wrapper");
+                close(sock);
+                d.accepted_fd = -1;
+            }
+        }
+
+        /* Handle launcher request */
+        if (d.launcher[0] >= 0 && FD_ISSET(d.launcher[0], &rd_set)) {
+            if (!handle_launcher_request(d.launcher[0], "launcher")) {
+                launcher_died();
+            }
+            if (waitForPid == d.launcher_pid) {
+                return;
+            }
+        }
+
+    }
+}
+
+static void generate_socket_name()
+{
+
+    QByteArray display = qgetenv(displayEnvVarName_c());
+    int i;
+    if ((i = display.lastIndexOf('.')) > display.lastIndexOf(':') && i >= 0) {
+        display.truncate(i);
+    }
+
+    display.replace(':', '_');
+#ifdef __APPLE__
+    display.replace('/', '_');
+#endif
+    // WARNING, if you change the socket name, adjust kwrapper too
+    const QString socketFileName = QString::fromLatin1("kdeinit5_%1").arg(QLatin1String(display));
+    const QByteArray socketName = QFile::encodeName(QStandardPaths::writableLocation(QStandardPaths::RuntimeLocation) + QLatin1Char('/') + socketFileName);
+    if (socketName.length() >= MAX_SOCK_FILE) {
+        fprintf(stderr, "kdeinit5: Aborting. Socket name will be too long:\n");
+        fprintf(stderr, "         '%s'\n", socketName.data());
+        exit(255);
+    }
+    strcpy(sock_file, socketName.data());
+}
+
+/**
+ Calling CoreFoundation and other non-POSIX APIs (which is unavoidable) has always caused issues
+ with fork/exec on Mac OS X, but as of 10.5 is explicitly disallowed with an exception. As a
+ result, in the case where we would normally fork and then dlopen code, or continue
+ to run other code, we must now fork-and-exec, and even then we need to use a helper (proxy)
+ to launch the actual application we wish to launch, a proxy that will only have used POSIX APIs.
+ This probably cancels the whole idea of preloading libraries, but it is as it is.
+ Note that this function is called only when kdeinit5 is forking itself,
+ in order to disappear into the background.
+*/
+// Copied from kkernel_mac.cpp
+void
+mac_fork_and_reexec_self()
+{
+    int argc = *_NSGetArgc();
+    char **argv = *_NSGetArgv();
+    char *newargv[argc + 2];
+    char progname[PATH_MAX];
+    uint32_t buflen = PATH_MAX;
+    _NSGetExecutablePath(progname, &buflen);
+
+    for (int i = 0; i < argc; i++) {
+        newargv[i] = argv[i];
+    }
+
+    newargv[argc] = (char*)"--nofork";
+    newargv[argc + 1] = 0;
+
+    int x_fork_result = fork();
+    switch (x_fork_result) {
+
+    case -1:
+#ifndef NDEBUG
+        fprintf(stderr, "Mac OS X workaround fork() failed!\n");
+#endif
+        ::_exit(255);
+        break;
+
+    case 0:
+        // Child
+        execvp(progname, newargv);
+        break;
+
+    default:
+        // Parent
+        _exit(0);
+        break;
+
+    }
+}
+
+extern "C" {
+    // unused??
+    static void secondary_child_handler(int)
+    {
+        waitpid(-1, 0, WNOHANG);
+    }
+
+}
+
+int main(int argc, char **argv)
+{
+#ifndef _WIN32_WCE
+    setlocale(LC_ALL, "");
+    setlocale(LC_NUMERIC, "C");
+#endif
+
+    pid_t pid;
+    bool do_fork = true;
+    int launch_klauncher = 1;
+    int launch_kded = 0;
+    int keep_running = 1;
+    d.suicide = false;
+
+    /** Save arguments first... **/
+    char **safe_argv = (char **) malloc(sizeof(char *) * argc);
+    for (int i = 0; i < argc; i++) {
+        safe_argv[i] = strcpy((char *)malloc(strlen(argv[i]) + 1), argv[i]);
+        if (strcmp(safe_argv[i], "--no-klauncher") == 0) {
+            launch_klauncher = 0;
+        }
+        if (strcmp(safe_argv[i], "--kded") == 0) {
+            launch_kded = 1;
+        }
+        // allow both nofork and no-fork for compatibility with
+        // old versions (both of this and of KUniqueApplication)
+        if (strcmp(safe_argv[i], "--nofork") == 0) {
+            do_fork = false;
+        }
+        if (strcmp(safe_argv[i], "--no-fork") == 0) {
+            do_fork = false;
+        }
+        if (strcmp(safe_argv[i], "--suicide") == 0) {
+            d.suicide = true;
+        }
+        if (strcmp(safe_argv[i], "--exit") == 0) {
+            keep_running = 0;
+        }
+        if (strcmp(safe_argv[i], "--version") == 0) {
+            printf("Qt: %s\n", qVersion());
+            printf("KDE: %s\n", KINIT_VERSION_STRING);
+            exit(0);
+        }
+#if KDEINIT_OOM_PROTECT
+        if (strcmp(safe_argv[i], "--oom-pipe") == 0 && i + 1 < argc) {
+            oom_pipe = atol(argv[i + 1]);
+        }
+#endif
+        if (strcmp(safe_argv[i], "--help") == 0) {
+            printf("Usage: kdeinit5 [options]\n");
+            printf("    --no-fork         Do not fork\n");
+            // printf("    --no-klauncher    Do not start klauncher\n");
+            printf("    --kded            Start kded\n");
+            printf("    --suicide         Terminate when no KDE applications are left running\n");
+            printf("    --version         Show version information\n");
+            // printf("    --exit            Terminate when kded has run\n");
+            exit(0);
+        }
+    }
+
+    cleanup_fds();
+
+    // Redirect stdout to stderr. We have no reason to use stdout anyway.
+    // This minimizes our impact on commands used in pipes.
+    (void)dup2(2, 1);
+
+    if (do_fork) {
+        mac_fork_and_reexec_self();
+    }
+
+    /** Make process group leader (for shutting down children later) **/
+    if (keep_running) {
+        setsid();
+    }
+
+    /** Prepare to change process name **/
+#ifndef SKIP_PROCTITLE
+    proctitle_init(argc, argv);
+#endif
+
+    // don't change envvars before proctitle_init()
+    unsetenv("LD_BIND_NOW");
+    unsetenv("DYLD_BIND_AT_LAUNCH");
+    KCrash::loadedByKdeinit = true;
+
+    d.maxname = strlen(argv[0]);
+    d.launcher_pid = 0;
+    d.kded_pid = 0;
+    d.wrapper = -1;
+    d.accepted_fd = -1;
+    d.debug_wait = false;
+    d.launcher_ok = false;
+    children = NULL;
+    init_signals();
+
+    generate_socket_name();
+    if (keep_running) {
+        /*
+         * Create ~/.kde/tmp-<hostname>/kdeinit5-<display> socket for incoming wrapper
+         * requests.
+         */
+        init_kdeinit_socket();
+    }
+    if (launch_klauncher) {
+        start_klauncher();
+        handle_requests(d.launcher_pid); // Wait for klauncher to be ready
+    }
+
+    QFont::initialize();
+
+    if (launch_kded) {
+        qputenv("KDED_STARTED_BY_KDEINIT", "1");
+        pid = launch(1, KDED_EXENAME, 0);
+        unsetenv("KDED_STARTED_BY_KDEINIT");
+#ifndef NDEBUG
+        fprintf(stderr, "kdeinit5: Launched KDED, pid = %ld result = %d\n", (long) pid, d.result);
+#endif
+        d.kded_pid = pid;
+        // kded5 doesn't fork on startup anymore, so just move on.
+        //handle_requests(pid);
+    }
+
+    for (int i = 1; i < argc; i++) {
+        if (safe_argv[i][0] == '+') {
+            pid = launch(1, safe_argv[i] + 1, 0);
+#ifndef NDEBUG
+            fprintf(stderr, "kdeinit5: Launched '%s', pid = %ld result = %d\n", safe_argv[i] + 1, (long) pid, d.result);
+#endif
+            handle_requests(pid);
+        } else if (safe_argv[i][0] == '-'
+#if KDEINIT_OOM_PROTECT
+                   || isdigit(safe_argv[i][0])
+#endif
+                  ) {
+            // Ignore
+        } else {
+            pid = launch(1, safe_argv[i], 0);
+#ifndef NDEBUG
+            fprintf(stderr, "kdeinit5: Launched '%s', pid = %ld result = %d\n", safe_argv[i], (long) pid, d.result);
+#endif
+        }
+    }
+
+    /** Free arguments **/
+    for (int i = 0; i < argc; i++) {
+        free(safe_argv[i]);
+    }
+    free(safe_argv);
+
+#ifndef SKIP_PROCTITLE
+    proctitle_set("Running...");
+#endif
+
+    if (!keep_running) {
+        return 0;
+    }
+
+    if (d.initpipe[1] != -1) {
+        char c = 0;
+        write(d.initpipe[1], &c, 1); // Kdeinit is started.
+        close(d.initpipe[1]);
+        d.initpipe[1] = -1;
+    }
+
+    handle_requests(0);
+
+    return 0;
+}
+
diff --git src/klauncher/CMakeLists.txt src/klauncher/CMakeLists.txt
index 746edfa..8037053 100644
--- src/klauncher/CMakeLists.txt
+++ src/klauncher/CMakeLists.txt
@@ -23,6 +23,9 @@ target_link_libraries(kdeinit_klauncher ${X11_LIBRARIES}
    KF5::I18n   # i18n()
    Qt5::DBus
 )
+if (APPLE)
+    target_link_libraries(kdeinit_klauncher PUBLIC "-framework CoreFoundation")
+endif()
 
 install(TARGETS kdeinit_klauncher ${KF5_INSTALL_TARGETS_DEFAULT_ARGS})
 install(TARGETS klauncher DESTINATION ${CMAKE_INSTALL_FULL_LIBEXECDIR_KF5} )
diff --git src/klauncher/klauncher.cpp src/klauncher/klauncher.cpp
index 8b3d343..60871cf 100644
--- src/klauncher/klauncher.cpp
+++ src/klauncher/klauncher.cpp
@@ -571,7 +571,7 @@ KLauncher::requestStart(KLaunchRequest *request)
     }
 
     QString executable = request->name;
-#ifdef Q_OS_MAC
+#ifdef Q_OS_OSX
     const QString bundlepath = QStandardPaths::findExecutable(executable);
     if (!bundlepath.isEmpty()) {
         executable = bundlepath;
diff --git src/klauncher/klauncher.h src/klauncher/klauncher.h
index e155f72..4220c12 100644
--- src/klauncher/klauncher.h
+++ src/klauncher/klauncher.h
@@ -31,7 +31,7 @@
 #include <fixx11h.h>
 #endif
 
-#if defined(Q_OS_WIN) || defined(Q_OS_MAC)
+#if defined(Q_OS_WIN) || defined(Q_OS_OSX)
 #define USE_KPROCESS_FOR_KIOSLAVES
 #endif
 #ifdef Q_CC_MSVC
diff --git src/klauncher/klauncher_main.cpp src/klauncher/klauncher_main.cpp
index f69aaa5..6e5c189 100644
--- src/klauncher/klauncher_main.cpp
+++ src/klauncher/klauncher_main.cpp
@@ -35,6 +35,10 @@
 #include <QDBusConnectionInterface>
 #include <QThread>
 
+#ifdef Q_OS_OSX
+#include <CoreFoundation/CoreFoundation.h>
+#endif
+
 #ifndef USE_KPROCESS_FOR_KIOSLAVES
 static int sigpipe[ 2 ];
 static void sig_handler(int sig_num)
@@ -48,7 +52,7 @@ static void sig_handler(int sig_num)
 }
 #endif
 
-#if defined(Q_OS_DARWIN) || defined (Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined (Q_OS_OSX)
 // Copied from kkernel_mac.cpp
 bool dbus_initialized = false;
 
@@ -145,7 +149,19 @@ extern "C" Q_DECL_EXPORT int kdemain(int argc, char **argv)
     }
 #endif
 
-#if defined(Q_OS_DARWIN) || defined (Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined (Q_OS_OSX)
+    CFBundleRef mainBundle = CFBundleGetMainBundle();
+    if (mainBundle) {
+        // get the application's Info Dictionary. For app bundles this would live in the bundle's Info.plist,
+        // for regular executables it is obtained in another way.
+        CFMutableDictionaryRef infoDict = (CFMutableDictionaryRef) CFBundleGetInfoDictionary(mainBundle);
+        if (infoDict) {
+            // Add or set the "LSUIElement" key with/to value "1". This can simply be a CFString.
+            CFDictionarySetValue(infoDict, CFSTR("LSUIElement"), CFSTR("1"));
+            // That's it. We're now considered as an "agent" by the window server, and thus will have
+            // neither menubar nor presence in the Dock or App Switcher.
+        }
+    }
     mac_initialize_dbus();
 #endif
 
diff --git src/start_kdeinit/CMakeLists.txt src/start_kdeinit/CMakeLists.txt
index 46d6cb3..74fddc5 100644
--- src/start_kdeinit/CMakeLists.txt
+++ src/start_kdeinit/CMakeLists.txt
@@ -1,8 +1,10 @@
 add_executable(start_kdeinit start_kdeinit.c)
+ecm_mark_nongui_executable(start_kdeinit)
 if (Libcap_FOUND)
    target_link_libraries(start_kdeinit ${Libcap_LIBRARIES})
 endif()
 add_executable(start_kdeinit_wrapper start_kdeinit_wrapper.c)
+ecm_mark_nongui_executable(start_kdeinit_wrapper)
 
 install(TARGETS start_kdeinit DESTINATION ${CMAKE_INSTALL_FULL_LIBEXECDIR_KF5})
 install(TARGETS start_kdeinit_wrapper DESTINATION ${CMAKE_INSTALL_FULL_LIBEXECDIR_KF5})
diff --git src/wrapper.cpp src/wrapper.cpp
index 95b7ec2..7b09753 100644
--- src/wrapper.cpp
+++ src/wrapper.cpp
@@ -42,42 +42,43 @@
 
 extern char **environ;
 
-static char *getDisplay()
+// copied from kdeinit/kinit.cpp
+static const char* displayEnvVarName_c()
 {
-    const char *display;
-    char *result;
-    char *screen;
-    char *colon;
-    char *i;
-
-#if defined(NO_DISPLAY)
-    display = "NODISPLAY";
-#else
-    display = getenv("DISPLAY");
+    // Can't use QGuiApplication::platformName() here, there is no app instance.
+#if HAVE_X11
+    return "DISPLAY";
+#elif defined(Q_OS_OSX)
+    return "MAC_DISPLAY";
+#elif defined(Q_OS_WIN)
+    return "WIN_DISPLAY";
 #endif
-    if (!display || !*display) {
-        display = ":0";
-    }
-    result = (char *)malloc(strlen(display) + 1);
-    if (result == NULL) {
-        return NULL;
-    }
+}
 
-    strcpy(result, display);
-    screen = strrchr(result, '.');
-    colon = strrchr(result, ':');
-    if (screen && (screen > colon)) {
-        *screen = '\0';
-    }
-    while ((i = strchr(result, ':'))) {
-        *i = '_';
-    }
+// adapted from kdeinit/kinit.cpp
+// WARNING, if you change the socket name, adjust kinit.cpp too
+static const QString generate_socket_file_name()
+{
+
+    QByteArray display = qgetenv(displayEnvVarName_c());
+    if (display.isEmpty()) {
+#if HAVE_X11
+        fprintf(stderr, "Error: could not determine $%s.\n", displayEnvVarName_c());
+        return QString();
+    } else {
+#endif
+        int i;
+        if ((i = display.lastIndexOf('.')) > display.lastIndexOf(':') && i >= 0) {
+            display.truncate(i);
+        }
+
+        display.replace(':', '_');
 #ifdef __APPLE__
-    while ((i = strchr(result, '/'))) {
-        *i = '_';
-    }
+        display.replace('/', '_');
 #endif
-    return result;
+    }
+    const QString socketFileName = QString::fromLatin1("kdeinit5_%1").arg(QLatin1String(display));
+    return socketFileName;
 }
 
 /*
@@ -126,23 +127,14 @@ static int read_socket(int sock, char *buffer, int len)
 
 static int openSocket()
 {
-    char *display = getDisplay();
-#if !defined (NO_DISPLAY)
-    if (display == NULL) {
-        fprintf(stderr, "Error: Could not determine display.\n");
+    const QString socketFileName = generate_socket_file_name();
+    if (socketFileName.isEmpty()) {
         return -1;
     }
-#endif
-
-    const QString socketFileName = QString::fromLatin1("kdeinit5_%1").arg(QLatin1String(display));
     QByteArray socketName = QFile::encodeName(QStandardPaths::writableLocation(QStandardPaths::RuntimeLocation) +
                             QLatin1Char('/') + socketFileName);
     const char *sock_file = socketName.constData();
 
-#if !defined (NO_DISPLAY)
-    free(display);
-#endif
-
     struct sockaddr_un server;
     if (strlen(sock_file) >= sizeof(server.sun_path)) {
         fprintf(stderr, "Warning: Path of socketfile exceeds UNIX_PATH_MAX.\n");
@@ -252,7 +244,7 @@ static int kwrapper_run(pid_t wrapped, int sock)
 
     buffer = (char *) malloc(header.arg_length);
     if (buffer == NULL) {
-        fprintf(stderr, "Error: malloc() failed\n");
+        perror("Error: malloc() failed\n");
         exit(255);
     }
 
@@ -408,7 +400,7 @@ int main(int argc, char **argv)
 
     buffer = (char *) malloc(size);
     if (buffer == NULL) {
-        fprintf(stderr, "Error: malloc() failed.");
+        perror("Error: malloc() failed.");
         exit(255);
     }
     p = buffer;
@@ -475,7 +467,7 @@ int main(int argc, char **argv)
         long pid;
         buffer = (char *) malloc(header.arg_length);
         if (buffer == NULL) {
-            fprintf(stderr, "Error: malloc() failed\n");
+            perror("Error: malloc() failed\n");
             exit(255);
         }
         read_socket(sock, buffer, header.arg_length);
