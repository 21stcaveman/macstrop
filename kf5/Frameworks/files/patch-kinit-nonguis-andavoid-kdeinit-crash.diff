diff --git src/kdeinit/CMakeLists.txt src/kdeinit/CMakeLists.txt
index f94db71..4ffcc54 100644
--- src/kdeinit/CMakeLists.txt
+++ src/kdeinit/CMakeLists.txt
@@ -11,14 +11,7 @@ include_directories(${KInit_BINARY_DIR}) # for kinit_version.h
 # on win32 kdeinit5 has to be a console application
 # to be able to catch stderr based --verbose output
 add_executable(kdeinit5 ${kdeinit_SRCS})
-if (APPLE)
-  # this has to be GUI on OSX because it launches GUI apps and need a quartz context
-  set_target_properties(kdeinit5 PROPERTIES MACOSX_BUNDLE_INFO_PLIST ${CMAKE_CURRENT_SOURCE_DIR}/Info.plist.template)
-  set_target_properties(kdeinit5 PROPERTIES MACOSX_BUNDLE_GUI_IDENTIFIER "org.kde.kdeinit5")
-  set_target_properties(kdeinit5 PROPERTIES MACOSX_BUNDLE_BUNDLE_NAME "KDE Init")
-else ()
-  ecm_mark_nongui_executable(kdeinit5)
-endif ()
+ecm_mark_nongui_executable(kdeinit5)
 
 target_link_libraries(kdeinit5 ${kdeinit_LIBS} ${KINIT_SOCKET_LIBRARY}
     Qt5::Gui #QFont::initialize
@@ -41,6 +34,15 @@ endif()
 
 install(TARGETS kdeinit5 ${KF5_INSTALL_TARGETS_DEFAULT_ARGS} )
 
+if (APPLE)
+    ########### kdeinit5 helper app ###############
+    set(kdeinit5_proxy_SRCS kdeinit5_proxy.cpp)
+    add_executable(kdeinit5_proxy ${kdeinit5_proxy_SRCS})
+    ecm_mark_nongui_executable(kdeinit5_proxy)
+    target_link_libraries(kdeinit5_proxy Qt5::Core)
+    install(TARGETS kdeinit5_proxy DESTINATION ${CMAKE_INSTALL_FULL_LIBEXECDIR_KF5} )
+endif ()
+
 if (NOT WIN32)
   # kdeinit5_shutdown
   add_executable(kdeinit5_shutdown ../wrapper.cpp)
diff --git src/kdeinit/kdeinit5_proxy.cpp src/kdeinit/kdeinit5_proxy.cpp
new file mode 100644
index 0000000..d1ae328
--- /dev/null
+++ src/kdeinit/kdeinit5_proxy.cpp
@@ -0,0 +1,58 @@
+/*
+  This file is part of the KDE libraries
+  Copyright (c) 2009 Jeremy Lainé <sharky@macports.org>
+            (c) 2009 Jeremy Lavergne <snc@macports.org>
+            (c) 2015 René J.V. Bertin <rjvbertin@gmail.com>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Library General Public
+  License version 2 as published by the Free Software Foundation.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Library General Public License for more details.
+
+  You should have received a copy of the GNU Library General Public License
+  along with this library; see the file COPYING.LIB.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+*/
+
+#include <stdlib.h>
+
+#include <QtCore/QLibrary>
+#include <QtCore/QString>
+#include <QtCore/QFile>
+#include <QDebug>
+
+typedef int (*handler) (int, char *[]);
+
+int main(int argc, char *argv[])
+{
+    if (argc < 2) {
+        qWarning() << "Too few arguments";
+        exit(1);
+    }
+
+    QString libpath = QFile::decodeName(argv[argc-1]);
+    QLibrary l(libpath);
+
+    if (!libpath.isEmpty() && (!l.load() || !l.isLoaded())) {
+        qWarning() << "Could not open library" << libpath << ":" << l.errorString();
+        exit(1);
+    }
+
+    QFunctionPointer sym = l.resolve( "kdeinitmain");
+    if (!sym) {
+        sym = l.resolve( "kdemain" );
+        if ( !sym ) {
+            qWarning() << "Could not find the kdemain function:" << l.errorString();
+            exit(1);
+        }
+    }
+
+    handler func = (int (*)(int, char *[])) sym;
+    exit( func(argc - 1, argv)); /* Launch! */
+}
+
diff --git src/kdeinit/kinit.cpp src/kdeinit/kinit.cpp
index a18008a..fccf5cd 100644
--- src/kdeinit/kinit.cpp
+++ src/kdeinit/kinit.cpp
@@ -64,7 +64,7 @@
 #endif
 #endif
 
-#ifdef Q_OS_MAC
+#ifdef Q_OS_OSX
 #include <CoreFoundation/CFBundle.h>
 #include <CoreFoundation/CFString.h>
 #include <CoreFoundation/CFURL.h>
@@ -85,7 +85,7 @@
 #include <qstandardpaths.h>
 
 #ifdef Q_OS_UNIX
-#ifdef Q_OS_MAC
+#ifdef Q_OS_OSX
 static const char *extra_libs[] = {
     "libKF5KIOCore.5.dylib",
     "libKF5Parts.5.dylib",
@@ -126,7 +126,7 @@ static const char* displayEnvVarName_c()
     // Can't use QGuiApplication::platformName() here, there is no app instance.
 #if HAVE_X11
     return "DISPLAY";
-#elif defined(Q_OS_MACX)
+#elif defined(Q_OS_OSX)
     return "MAC_DISPLAY";
 #elif defined(Q_OS_WIN)
     return "WIN_DISPLAY";
@@ -550,8 +550,15 @@ static pid_t launch(int argc, const char *_name, const char *args,
 #endif
     // find out this path before forking, doing it afterwards
     // crashes on some platforms, notably OSX
-#ifdef Q_OS_MAC
+#ifdef Q_OS_OSX
     const QString bundlepath = QStandardPaths::findExecutable(QFile::decodeName(execpath));
+
+    // Don't run this inside the child process, it crashes on OS/X 10.6 and higher;
+    // use an additional helper proxy instead, one that will not have used any
+    // non-POSIX APIs.
+    // Find the helper using our own function that will be able to find it for us.
+    const QByteArray helperexe = execpath_avoid_loops("kdeinit5_proxy", envc, envs, avoid_loops);
+    const QString argvexe = QStandardPaths::findExecutable(QString::fromLatin1(_name));
 #endif
 
     d.errorMsg = 0;
@@ -611,17 +618,19 @@ static pid_t launch(int argc, const char *_name, const char *args,
         }
 #endif
         {
-            int r;
             QByteArray procTitle;
-            d.argv = (char **) malloc(sizeof(char *) * (argc + 1));
-            d.argv[0] = (char *) _name;
-#ifdef Q_OS_MAC
-            QString argvexe = QStandardPaths::findExecutable(QString::fromLatin1(d.argv[0]));
+#ifdef Q_OS_OSX
+            d.argv = (char **) malloc(sizeof(char *) * (argc + 2));
+            // set argv[0] to execpath instead of _name so the full path shows in `ps`
+            // this is just a convenience to users who may also be running the KDE4 klauncher.
+            d.argv[0] = (char *) execpath.constData();
             if (!argvexe.isEmpty()) {
                 QByteArray cstr = argvexe.toLocal8Bit();
-                // qDebug() << "kdeinit5: launch() setting argv: " << cstr.data();
                 d.argv[0] = strdup(cstr.data());
             }
+#else
+            d.argv = (char **) malloc(sizeof(char *) * (argc + 1));
+            d.argv[0] = (char *) _name;
 #endif
             for (int i = 1;  i < argc; i++) {
                 d.argv[i] = (char *) args;
@@ -638,7 +647,7 @@ static pid_t launch(int argc, const char *_name, const char *args,
             /** Give the process a new name **/
 #ifdef Q_OS_LINUX
             /* set the process name, so that killall works like intended */
-            r = prctl(PR_SET_NAME, (unsigned long) name.data(), 0, 0, 0);
+            int r = prctl(PR_SET_NAME, (unsigned long) name.data(), 0, 0, 0);
             if (r == 0) {
                 proctitle_set("-%s [kdeinit5]%s", name.data(), procTitle.data() ? procTitle.data() : "");
             } else {
@@ -659,6 +668,7 @@ static pid_t launch(int argc, const char *_name, const char *args,
             libpath.truncate(0);
         }
 
+#ifndef Q_OS_OSX
         QLibrary l(libpath);
 
         if (!libpath.isEmpty()) {
@@ -688,7 +698,9 @@ static pid_t launch(int argc, const char *_name, const char *args,
                 }
             }
         }
-        if (!l.isLoaded()) {
+        if (!l.isLoaded())
+#endif // Q_OS_OSX
+        {
             d.result = 2; // Try execing
             write(d.fd[1], &d.result, 1);
 
@@ -699,7 +711,7 @@ static pid_t launch(int argc, const char *_name, const char *args,
             setup_tty(tty);
 
             QByteArray executable = execpath;
-#ifdef Q_OS_MAC
+#ifdef Q_OS_OSX
             if (!bundlepath.isEmpty()) {
                 executable = QFile::encodeName(bundlepath);
             }
@@ -715,6 +727,7 @@ static pid_t launch(int argc, const char *_name, const char *args,
             exit(255);
         }
 
+#ifndef Q_OS_OSX
         QFunctionPointer sym = l.resolve("kdeinitmain");
         if (!sym) {
             sym = l.resolve("kdemain");
@@ -732,6 +745,12 @@ static pid_t launch(int argc, const char *_name, const char *args,
         close(d.fd[1]);
 
         d.func = (int (*)(int, char *[])) sym;
+#else
+        d.result = 2; // Try exec'ing
+        // We set the close on exec flag.
+        // Closing of d.fd[1] indicates that the execvp succeeded.
+        fcntl(d.fd[1], F_SETFD, FD_CLOEXEC);
+#endif
         if (d.debug_wait) {
             fprintf(stderr, "kdeinit5: Suspending process\n"
                     "kdeinit5: 'gdb kdeinit5 %d' to debug\n"
@@ -742,7 +761,24 @@ static pid_t launch(int argc, const char *_name, const char *args,
             setup_tty(tty);
         }
 
+#ifndef Q_OS_OSX
         exit(d.func(argc, d.argv));  /* Launch! */
+#else
+        QByteArray libpathbytes = QFile::encodeName(libpath);
+        d.argv[argc] = libpathbytes.data();
+        d.argv[argc+1] = 0;
+
+        if (!helperexe.isEmpty()) {
+            execvp(helperexe.constData(), d.argv);
+        } else {
+            qWarning() << "Failed to find kdeinit5 helper application \"kdeinit5_proxy\"";
+        }
+
+        d.result = 1; // Error
+        write(d.fd[1], &d.result, 1);
+        close(d.fd[1]);
+        exit(255);
+#endif
 
         break;
     }
@@ -1576,14 +1612,16 @@ static QString findSharedLib(const QString &lib)
     return QString();
 }
 
-#ifdef Q_OS_MAC
+#ifdef Q_OS_OSX
 /**
- Calling CoreFoundation APIs (which is unavoidable in Qt/Mac) has always had issues
- on Mac OS X, but as of 10.5 is explicitly disallowed with an exception.  As a
+ Calling CoreFoundation and other non-POSIX APIs (which is unavoidable) has always caused issues
+ with fork/exec on Mac OS X, but as of 10.5 is explicitly disallowed with an exception. As a
  result, in the case where we would normally fork and then dlopen code, or continue
- to run other code, we must now fork-and-exec.
-
- See "CoreFoundation and fork()" at http://developer.apple.com/releasenotes/CoreFoundation/CoreFoundation.html
+ to run other code, we must now fork-and-exec, and even then we need to use a helper (proxy)
+ to launch the actual application we wish to launch, a proxy that will only have used POSIX APIs.
+ This probably cancels the whole idea of preloading libraries, but it is as it is.
+ Note that this function is called only when kdeinit5 is forking itself,
+ in order to disappear into the background.
 */
 // Copied from kkernel_mac.cpp
 void
@@ -1595,14 +1633,13 @@ mac_fork_and_reexec_self()
     char progname[PATH_MAX];
     uint32_t buflen = PATH_MAX;
     _NSGetExecutablePath(progname, &buflen);
-    bool found_psn = false;
 
     for (int i = 0; i < argc; i++) {
         newargv[i] = argv[i];
     }
 
-    newargv[argc] = "--nofork";
-    newargv[argc + 1] = NULL;
+    newargv[argc] = (char*)"--nofork";
+    newargv[argc + 1] = 0;
 
     int x_fork_result = fork();
     switch (x_fork_result) {
@@ -1704,7 +1741,7 @@ int main(int argc, char **argv)
     (void)dup2(2, 1);
 
     if (do_fork) {
-#ifdef Q_OS_MAC
+#ifdef Q_OS_OSX
         mac_fork_and_reexec_self();
 #else
         if (pipe(d.initpipe) != 0) {
diff --git src/klauncher/CMakeLists.txt src/klauncher/CMakeLists.txt
index 746edfa..8037053 100644
--- src/klauncher/CMakeLists.txt
+++ src/klauncher/CMakeLists.txt
@@ -23,6 +23,9 @@ target_link_libraries(kdeinit_klauncher ${X11_LIBRARIES}
    KF5::I18n   # i18n()
    Qt5::DBus
 )
+if (APPLE)
+    target_link_libraries(kdeinit_klauncher "-framework CoreFoundation")
+endif()
 
 install(TARGETS kdeinit_klauncher ${KF5_INSTALL_TARGETS_DEFAULT_ARGS})
 install(TARGETS klauncher DESTINATION ${CMAKE_INSTALL_FULL_LIBEXECDIR_KF5} )
diff --git src/klauncher/klauncher.cpp src/klauncher/klauncher.cpp
index 8b3d343..60871cf 100644
--- src/klauncher/klauncher.cpp
+++ src/klauncher/klauncher.cpp
@@ -571,7 +571,7 @@ KLauncher::requestStart(KLaunchRequest *request)
     }
 
     QString executable = request->name;
-#ifdef Q_OS_MAC
+#ifdef Q_OS_OSX
     const QString bundlepath = QStandardPaths::findExecutable(executable);
     if (!bundlepath.isEmpty()) {
         executable = bundlepath;
diff --git src/klauncher/klauncher.h src/klauncher/klauncher.h
index e155f72..4220c12 100644
--- src/klauncher/klauncher.h
+++ src/klauncher/klauncher.h
@@ -31,7 +31,7 @@
 #include <fixx11h.h>
 #endif
 
-#if defined(Q_OS_WIN) || defined(Q_OS_MAC)
+#if defined(Q_OS_WIN) || defined(Q_OS_OSX)
 #define USE_KPROCESS_FOR_KIOSLAVES
 #endif
 #ifdef Q_CC_MSVC
diff --git src/klauncher/klauncher_main.cpp src/klauncher/klauncher_main.cpp
index f69aaa5..6e5c189 100644
--- src/klauncher/klauncher_main.cpp
+++ src/klauncher/klauncher_main.cpp
@@ -35,6 +35,10 @@
 #include <QDBusConnectionInterface>
 #include <QThread>
 
+#ifdef Q_OS_OSX
+#include <CoreFoundation/CoreFoundation.h>
+#endif
+
 #ifndef USE_KPROCESS_FOR_KIOSLAVES
 static int sigpipe[ 2 ];
 static void sig_handler(int sig_num)
@@ -48,7 +52,7 @@ static void sig_handler(int sig_num)
 }
 #endif
 
-#if defined(Q_OS_DARWIN) || defined (Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined (Q_OS_OSX)
 // Copied from kkernel_mac.cpp
 bool dbus_initialized = false;
 
@@ -145,7 +149,19 @@ extern "C" Q_DECL_EXPORT int kdemain(int argc, char **argv)
     }
 #endif
 
-#if defined(Q_OS_DARWIN) || defined (Q_OS_MAC)
+#if defined(Q_OS_DARWIN) || defined (Q_OS_OSX)
+    CFBundleRef mainBundle = CFBundleGetMainBundle();
+    if (mainBundle) {
+        // get the application's Info Dictionary. For app bundles this would live in the bundle's Info.plist,
+        // for regular executables it is obtained in another way.
+        CFMutableDictionaryRef infoDict = (CFMutableDictionaryRef) CFBundleGetInfoDictionary(mainBundle);
+        if (infoDict) {
+            // Add or set the "LSUIElement" key with/to value "1". This can simply be a CFString.
+            CFDictionarySetValue(infoDict, CFSTR("LSUIElement"), CFSTR("1"));
+            // That's it. We're now considered as an "agent" by the window server, and thus will have
+            // neither menubar nor presence in the Dock or App Switcher.
+        }
+    }
     mac_initialize_dbus();
 #endif
 
diff --git src/start_kdeinit/CMakeLists.txt src/start_kdeinit/CMakeLists.txt
index 46d6cb3..74fddc5 100644
--- src/start_kdeinit/CMakeLists.txt
+++ src/start_kdeinit/CMakeLists.txt
@@ -1,8 +1,10 @@
 add_executable(start_kdeinit start_kdeinit.c)
+ecm_mark_nongui_executable(start_kdeinit)
 if (Libcap_FOUND)
    target_link_libraries(start_kdeinit ${Libcap_LIBRARIES})
 endif()
 add_executable(start_kdeinit_wrapper start_kdeinit_wrapper.c)
+ecm_mark_nongui_executable(start_kdeinit_wrapper)
 
 install(TARGETS start_kdeinit DESTINATION ${CMAKE_INSTALL_FULL_LIBEXECDIR_KF5})
 install(TARGETS start_kdeinit_wrapper DESTINATION ${CMAKE_INSTALL_FULL_LIBEXECDIR_KF5})
diff --git src/wrapper.cpp src/wrapper.cpp
index 95b7ec2..7b09753 100644
--- src/wrapper.cpp
+++ src/wrapper.cpp
@@ -42,42 +42,43 @@
 
 extern char **environ;
 
-static char *getDisplay()
+// copied from kdeinit/kinit.cpp
+static const char* displayEnvVarName_c()
 {
-    const char *display;
-    char *result;
-    char *screen;
-    char *colon;
-    char *i;
-
-#if defined(NO_DISPLAY)
-    display = "NODISPLAY";
-#else
-    display = getenv("DISPLAY");
+    // Can't use QGuiApplication::platformName() here, there is no app instance.
+#if HAVE_X11
+    return "DISPLAY";
+#elif defined(Q_OS_OSX)
+    return "MAC_DISPLAY";
+#elif defined(Q_OS_WIN)
+    return "WIN_DISPLAY";
 #endif
-    if (!display || !*display) {
-        display = ":0";
-    }
-    result = (char *)malloc(strlen(display) + 1);
-    if (result == NULL) {
-        return NULL;
-    }
+}
 
-    strcpy(result, display);
-    screen = strrchr(result, '.');
-    colon = strrchr(result, ':');
-    if (screen && (screen > colon)) {
-        *screen = '\0';
-    }
-    while ((i = strchr(result, ':'))) {
-        *i = '_';
-    }
+// adapted from kdeinit/kinit.cpp
+// WARNING, if you change the socket name, adjust kinit.cpp too
+static const QString generate_socket_file_name()
+{
+
+    QByteArray display = qgetenv(displayEnvVarName_c());
+    if (display.isEmpty()) {
+#if HAVE_X11
+        fprintf(stderr, "Error: could not determine $%s.\n", displayEnvVarName_c());
+        return QString();
+    } else {
+#endif
+        int i;
+        if ((i = display.lastIndexOf('.')) > display.lastIndexOf(':') && i >= 0) {
+            display.truncate(i);
+        }
+
+        display.replace(':', '_');
 #ifdef __APPLE__
-    while ((i = strchr(result, '/'))) {
-        *i = '_';
-    }
+        display.replace('/', '_');
 #endif
-    return result;
+    }
+    const QString socketFileName = QString::fromLatin1("kdeinit5_%1").arg(QLatin1String(display));
+    return socketFileName;
 }
 
 /*
@@ -126,23 +127,14 @@ static int read_socket(int sock, char *buffer, int len)
 
 static int openSocket()
 {
-    char *display = getDisplay();
-#if !defined (NO_DISPLAY)
-    if (display == NULL) {
-        fprintf(stderr, "Error: Could not determine display.\n");
+    const QString socketFileName = generate_socket_file_name();
+    if (socketFileName.isEmpty()) {
         return -1;
     }
-#endif
-
-    const QString socketFileName = QString::fromLatin1("kdeinit5_%1").arg(QLatin1String(display));
     QByteArray socketName = QFile::encodeName(QStandardPaths::writableLocation(QStandardPaths::RuntimeLocation) +
                             QLatin1Char('/') + socketFileName);
     const char *sock_file = socketName.constData();
 
-#if !defined (NO_DISPLAY)
-    free(display);
-#endif
-
     struct sockaddr_un server;
     if (strlen(sock_file) >= sizeof(server.sun_path)) {
         fprintf(stderr, "Warning: Path of socketfile exceeds UNIX_PATH_MAX.\n");
@@ -252,7 +244,7 @@ static int kwrapper_run(pid_t wrapped, int sock)
 
     buffer = (char *) malloc(header.arg_length);
     if (buffer == NULL) {
-        fprintf(stderr, "Error: malloc() failed\n");
+        perror("Error: malloc() failed\n");
         exit(255);
     }
 
@@ -408,7 +400,7 @@ int main(int argc, char **argv)
 
     buffer = (char *) malloc(size);
     if (buffer == NULL) {
-        fprintf(stderr, "Error: malloc() failed.");
+        perror("Error: malloc() failed.");
         exit(255);
     }
     p = buffer;
@@ -475,7 +467,7 @@ int main(int argc, char **argv)
         long pid;
         buffer = (char *) malloc(header.arg_length);
         if (buffer == NULL) {
-            fprintf(stderr, "Error: malloc() failed\n");
+            perror("Error: malloc() failed\n");
             exit(255);
         }
         read_socket(sock, buffer, header.arg_length);
