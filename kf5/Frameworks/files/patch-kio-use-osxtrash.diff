diff --git src/ioslaves/trash/CMakeLists.txt src/ioslaves/trash/CMakeLists.txt
index 05161cd..a52380c 100644
--- src/ioslaves/trash/CMakeLists.txt
+++ src/ioslaves/trash/CMakeLists.txt
@@ -37,6 +37,9 @@ target_link_libraries(kio_trash
   KF5::ConfigCore
   KF5::ConfigGui
 )
+if(APPLE)
+    target_link_libraries(kio_trash "-framework DiskArbitration -framework CoreFoundation")
+endif(APPLE)
 set_target_properties(kio_trash PROPERTIES OUTPUT_NAME "trash")
 install(TARGETS kio_trash  DESTINATION ${KDE_INSTALL_PLUGINDIR}/kf5/kio )
 
@@ -67,6 +70,9 @@ if(NOT WIN32 AND NOT KIOCORE_ONLY)
        KF5::ConfigWidgets
        KF5::KIOCore
        KF5::Solid)
+    if(APPLE)
+        target_link_libraries(kcm_trash "-framework DiskArbitration -framework CoreFoundation")
+    endif(APPLE)
 
     install(TARGETS kcm_trash DESTINATION ${KDE_INSTALL_PLUGINDIR})
 endif()
diff --git src/ioslaves/trash/kcmtrash.cpp src/ioslaves/trash/kcmtrash.cpp
index 79c2ca7..63e2769 100644
--- src/ioslaves/trash/kcmtrash.cpp
+++ src/ioslaves/trash/kcmtrash.cpp
@@ -217,6 +217,16 @@ void TrashConfigModule::setupGui()
 {
     QVBoxLayout *layout = new QVBoxLayout(this);
 
+#ifdef Q_OS_OSX
+    QLabel *infoText = new QLabel( i18n( "<para>KDE's wastebin is configured to use the <b>Finder</b>'s Trash.<br></para>" ) );
+    infoText->setWhatsThis( i18nc( "@info:whatsthis",
+                                        "<para>Emptying KDE's wastebin will remove only KDE's trash items, while<br>"
+                                        "emptying the Trash through the Finder will delete everything.</para>"
+                                        "<para>KDE's trash items will show up in a folder called KDE.trash, in the Trash can.</para>"
+                                        ) );
+    layout->addWidget( infoText );
+#endif
+
     TrashImpl::TrashDirMap map = mTrashImpl->trashDirectories();
     if (map.count() != 1) {
         // If we have multiple trashes, we setup a widget to choose
diff --git src/ioslaves/trash/tests/CMakeLists.txt src/ioslaves/trash/tests/CMakeLists.txt
index 3e138f7..c6aa4ae 100644
--- src/ioslaves/trash/tests/CMakeLists.txt
+++ src/ioslaves/trash/tests/CMakeLists.txt
@@ -21,10 +21,14 @@ target_link_libraries(testtrash
    KF5::Solid
    Qt5::Test
 )
+if(APPLE)
+    target_link_libraries(testtrash "-framework DiskArbitration -framework CoreFoundation")
+endif(APPLE)
+ecm_mark_nongui_executable(testtrash)
 
 ### next target ###
 
 add_executable(lockingtest lockingtest.cpp ../kinterprocesslock.cpp)
 ecm_mark_nongui_executable(lockingtest)
 
-target_link_libraries(lockingtest Qt5::Core Qt5::DBus)
+target_link_libraries(lockingtest Qt5::Core Qt5::DBus Qt5::QspXDG)
diff --git src/ioslaves/trash/tests/testtrash.cpp src/ioslaves/trash/tests/testtrash.cpp
index 339aa19..22d850f 100644
--- src/ioslaves/trash/tests/testtrash.cpp
+++ src/ioslaves/trash/tests/testtrash.cpp
@@ -137,12 +137,18 @@ void TestTrash::initTestCase()
 
     QStandardPaths::setTestModeEnabled(true);
 
+#ifndef Q_OS_OSX
     m_trashDir = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1String("/Trash");
     qDebug() << "setup: using trash directory " << m_trashDir;
+#endif
 
     // Look for another writable partition than $HOME (not mandatory)
     TrashImpl impl;
     impl.init();
+#ifdef Q_OS_OSX
+    m_trashDir = impl.trashDirectories()[0];
+    qDebug() << "setup: using trash directory " << m_trashDir;
+#endif
 
     TrashImpl::TrashDirMap trashDirs = impl.trashDirectories();
     TrashImpl::TrashDirMap topDirs = impl.topDirectories();
diff --git src/ioslaves/trash/trashimpl.cpp src/ioslaves/trash/trashimpl.cpp
index 26d9ea8..db1a054 100644
--- src/ioslaves/trash/trashimpl.cpp
+++ src/ioslaves/trash/trashimpl.cpp
@@ -126,6 +126,47 @@ int TrashImpl::testDir(const QString &_name) const
     return 0; // success
 }
 
+void TrashImpl::deleteEmptyTrashInfraStructure()
+{
+#ifdef Q_OS_OSX
+    // For each known trash directory...
+    if ( !m_trashDirectoriesScanned ) {
+        scanTrashDirectories();
+    }
+    TrashDirMap::const_iterator it = m_trashDirectories.constBegin();
+    for ( ; it != m_trashDirectories.constEnd() ; ++it ) {
+        const QString trashPath = it.value();
+        QString infoPath = trashPath + QLatin1String("/info");
+
+        qDebug() << "empty Trash" << trashPath << "; removing infrastructure";
+        synchronousDel(infoPath, false, true);
+        synchronousDel(trashPath + QLatin1String("/files"), false, true);
+        if ( trashPath.endsWith(QLatin1String("/KDE.trash")) ) {
+            synchronousDel(trashPath, false, true);
+        }
+    }
+#endif
+}
+
+bool TrashImpl::createTrashInfraStructure(int trashId, const QString &path)
+{
+    int err;
+    QString trashDir = (path.isEmpty())? trashDirectoryPath(trashId) : path;
+    if ( ( err = testDir( trashDir ) ) ) {
+        error( err, trashDir );
+        return false;
+    }
+    if ( ( err = testDir( trashDir + QLatin1String("/info") ) ) ) {
+        error( err, trashDir + QLatin1String("/info") );
+        return false;
+    }
+    if ( ( err = testDir( trashDir + QLatin1String("/files") ) ) ) {
+        error( err, trashDir + QLatin1String("/files") );
+        return false;
+    }
+    return true;
+}
+
 bool TrashImpl::init()
 {
     if (m_initStatus == InitOK) {
@@ -138,6 +179,7 @@ bool TrashImpl::init()
     // Check the trash directory and its info and files subdirs
     // see also kdesktop/init.cc for first time initialization
     m_initStatus = InitError;
+#ifndef Q_OS_MAC
     // $XDG_DATA_HOME/Trash, i.e. ~/.local/share/Trash by default.
     const QString xdgDataDir = QStandardPaths::writableLocation(QStandardPaths::GenericDataLocation) + QLatin1Char('/');
     if (!QDir().mkpath(xdgDataDir)) {
@@ -146,19 +188,19 @@ bool TrashImpl::init()
     }
 
     const QString trashDir = xdgDataDir + QLatin1String("Trash");
-    int err;
-    if ((err = testDir(trashDir))) {
-        error(err, trashDir);
-        return false;
-    }
-    if ((err = testDir(trashDir + QLatin1String("/info")))) {
-        error(err, trashDir + QLatin1String("/info"));
+    if (!createTrashInfraStructure(0, trashDir)) {
         return false;
     }
-    if ((err = testDir(trashDir + QLatin1String("/files")))) {
-        error(err, trashDir + QLatin1String("/files"));
+#else
+    // we DO NOT create ~/.Trash on OS X, that's the operating system's privilege
+    QString trashDir = QDir::homePath() + QLatin1String("/.Trash");
+    if (!QFileInfo(trashDir).isDir()) {
+        error( KIO::ERR_DOES_NOT_EXIST, trashDir );
         return false;
     }
+    trashDir += QLatin1String("/KDE.trash");
+    // we don't have to call createTrashInfraStructure() here because it'll be called when needed.
+#endif
     m_trashDirectories.insert(0, trashDir);
     m_initStatus = InitOK;
     qDebug() << "initialization OK, home trash dir:" << trashDir;
@@ -245,6 +287,9 @@ bool TrashImpl::createInfo(const QString &origPath, int &trashId, QString &fileI
     const QString origFileName = url.fileName();
 
     // Make destination file in info/
+#ifdef Q_OS_OSX
+    createTrashInfraStructure(trashId);
+#endif
     url.setPath(infoPath(trashId, origFileName));     // we first try with origFileName
     QUrl baseDirectory = QUrl::fromLocalFile(url.path());
     // Here we need to use O_EXCL to avoid race conditions with other kioslave processes
@@ -355,6 +400,9 @@ QString TrashImpl::filesPath(int trashId, const QString &fileId) const
 
 bool TrashImpl::deleteInfo(int trashId, const QString &fileId)
 {
+#ifdef Q_OS_OSX
+    createTrashInfraStructure(trashId);
+#endif
     bool ok = QFile::remove(infoPath(trashId, fileId));
     if (ok) {
         fileRemoved();
@@ -371,6 +419,9 @@ bool TrashImpl::moveToTrash(const QString &origPath, int trashId, const QString
 
     const qulonglong pathSize = DiscSpaceUtil::sizeOfPath(origPath);
 
+#ifdef Q_OS_OSX
+    createTrashInfraStructure(trashId);
+#endif
     const QString dest = filesPath(trashId, fileId);
     if (!move(origPath, dest)) {
         // Maybe the move failed due to no permissions to delete source.
@@ -451,6 +502,9 @@ bool TrashImpl::copyToTrash(const QString &origPath, int trashId, const QString
 
     const qulonglong pathSize = DiscSpaceUtil::sizeOfPath(origPath);
 
+#ifdef Q_OS_OSX
+    createTrashInfraStructure(trashId);
+#endif
     const QString dest = filesPath(trashId, fileId);
     if (!copy(origPath, dest)) {
         return false;
@@ -539,6 +593,10 @@ bool TrashImplKDE_mkdir(int trashId, const QString &fileId, int permissions)
 
 bool TrashImpl::del(int trashId, const QString &fileId)
 {
+#ifdef Q_OS_OSX
+    createTrashInfraStructure(trashId);
+#endif
+
     QString info = infoPath(trashId, fileId);
     QString file = filesPath(trashId, fileId);
 
@@ -837,6 +895,9 @@ void TrashImpl::fileAdded()
 void TrashImpl::fileRemoved()
 {
     if (isEmpty()) {
+#ifdef Q_OS_OSX
+        deleteEmptyTrashInfraStructure();
+#endif
         KConfigGroup group = m_config.group("Status");
         group.writeEntry("Empty", true);
         m_config.sync();
@@ -846,6 +907,54 @@ void TrashImpl::fileRemoved()
     // which will be done by the job soon after this.
 }
 
+#ifdef Q_OS_OSX
+#include <CoreFoundation/CoreFoundation.h>
+#include <DiskArbitration/DiskArbitration.h>
+#include <sys/param.h>
+#include <sys/mount.h>
+
+int TrashImpl::idForMountPoint(const QString &mountPoint) const
+{
+    DADiskRef disk;
+    CFDictionaryRef descDict;
+    DASessionRef session = DASessionCreate(NULL);
+    int devId = -1;
+    if (session) {
+        QByteArray mp = QFile::encodeName(mountPoint);
+        struct statfs statFS;
+        statfs(mp.constData(), &statFS);
+        disk = DADiskCreateFromBSDName(kCFAllocatorDefault, session, statFS.f_mntfromname);
+        if (disk) {
+            descDict = DADiskCopyDescription(disk);
+            if (descDict) {
+                CFNumberRef cfMajor = (CFNumberRef)CFDictionaryGetValue(descDict, kDADiskDescriptionMediaBSDMajorKey);
+                CFNumberRef cfMinor = (CFNumberRef)CFDictionaryGetValue(descDict, kDADiskDescriptionMediaBSDMinorKey);
+                int major, minor;
+                if ( CFNumberGetValue(cfMajor, kCFNumberIntType, &major) && CFNumberGetValue(cfMinor, kCFNumberIntType, &minor) ) {
+                    qDebug() << "major=" << major << " minor=" << minor;
+                    devId = 1000 * major + minor;
+                }
+                CFRelease(cfMajor);
+                CFRelease(cfMinor);
+            }
+            else {
+                qDebug() << "couldn't get DADiskCopyDescription from" << disk;
+            }
+            CFRelease(disk);
+        }
+        else {
+            qDebug() << "DADiskCreateFromBSDName failed on statfs from" << mp;
+        }
+        CFRelease(session);
+    }
+    else {
+        qDebug() << "couldn't create DASession";
+    }
+    return devId;
+}
+
+#else
+
 int TrashImpl::idForDevice(const Solid::Device &device) const
 {
     const Solid::Block *block = device.as<Solid::Block>();
@@ -893,6 +1002,7 @@ void TrashImpl::refreshDevices() const
     // otherwise we risk getting old device list
     qApp->processEvents(QEventLoop::ExcludeUserInputEvents);
 }
+#endif
 
 int TrashImpl::findTrashDirectory(const QString &origPath)
 {
@@ -912,9 +1022,11 @@ int TrashImpl::findTrashDirectory(const QString &origPath)
     QString mountPoint = mp->mountPoint();
     const QString trashDir = trashForMountPoint(mountPoint, true);
     qDebug() << "mountPoint=" << mountPoint << "trashDir=" << trashDir;
+#ifndef Q_OS_OSX
     if (trashDir.isEmpty()) {
         return 0;    // no trash available on partition
     }
+#endif
     int id = idForTrashDirectory(trashDir);
     if (id > -1) {
         qDebug() << "known with id" << id;
@@ -933,6 +1045,9 @@ int TrashImpl::findTrashDirectory(const QString &origPath)
     return m_lastId;
 #endif
 
+#ifdef Q_OS_OSX
+    id = idForMountPoint(mountPoint);
+#else
     refreshDevices();
     const QString query = QLatin1String("[StorageAccess.accessible == true AND StorageAccess.filePath == '") + mountPoint + QLatin1String("']");
     //qDebug() << "doing solid query:" << query;
@@ -946,6 +1061,7 @@ int TrashImpl::findTrashDirectory(const QString &origPath)
 
     // new trash dir found, register it
     id = idForDevice(device);
+#endif
     if (id == -1) {
         return 0;
     }
@@ -961,7 +1077,9 @@ int TrashImpl::findTrashDirectory(const QString &origPath)
 
 void TrashImpl::scanTrashDirectories() const
 {
+#ifndef Q_OS_OSX
     refreshDevices();
+#endif
 
     const QList<Solid::Device> lst = Solid::Device::listFromQuery(QStringLiteral("StorageAccess.accessible == true"));
     for (QList<Solid::Device>::ConstIterator it = lst.begin(); it != lst.end(); ++it) {
@@ -972,7 +1090,11 @@ void TrashImpl::scanTrashDirectories() const
             int trashId = idForTrashDirectory(trashDir);
             if (trashId == -1) {
                 // new trash dir found, register it
+#ifdef Q_OS_OSX
+                trashId = idForMountPoint(topdir);
+#else
                 trashId = idForDevice(*it);
+#endif
                 if (trashId == -1) {
                     continue;
                 }
@@ -1008,7 +1130,11 @@ QString TrashImpl::trashForMountPoint(const QString &topdir, bool createIfNeeded
 {
     // (1) Administrator-created $topdir/.Trash directory
 
+#ifndef Q_OS_OSX
     const QString rootTrashDir = topdir + QLatin1String("/.Trash");
+#else
+    const QString rootTrashDir = topdir + QLatin1String("/.Trashes");
+#endif
     const QByteArray rootTrashDir_c = QFile::encodeName(rootTrashDir);
     // Can't use QFileInfo here since we need to test for the sticky bit
     uid_t uid = getuid();
@@ -1020,13 +1146,20 @@ QString TrashImpl::trashForMountPoint(const QString &topdir, bool createIfNeeded
                 && ((buff.st_mode & requiredBits) == requiredBits)
                 && (::access(rootTrashDir_c, W_OK) == 0) // must be user-writable
            ) {
+#ifndef Q_OS_OSX
             const QString trashDir = rootTrashDir + QLatin1Char('/') + QString::number(uid);
+#else
+            QString trashDir = rootTrashDir + QLatin1Char('/') + QString::number(uid);
+#endif
             const QByteArray trashDir_c = QFile::encodeName(trashDir);
             if (QT_LSTAT(trashDir_c, &buff) == 0) {
                 if ((buff.st_uid == uid)  // must be owned by user
                         && (S_ISDIR(buff.st_mode)) // must be a dir
                         && (!S_ISLNK(buff.st_mode)) // not a symlink
                         && (buff.st_mode & 0777) == 0700) {  // rwx for user
+#ifdef Q_OS_OSX
+                    trashDir = trashDir + QLatin1String("/KDE.trash");
+#endif
                     return trashDir;
                 }
                 qDebug() << "Directory" << trashDir << "exists but didn't pass the security checks, can't use it";
@@ -1038,6 +1171,7 @@ QString TrashImpl::trashForMountPoint(const QString &topdir, bool createIfNeeded
         }
     }
 
+#ifndef Q_OS_OSX
     // (2) $topdir/.Trash-$uid
     const QString trashDir = topdir + QLatin1String("/.Trash-") + QString::number(uid);
     const QByteArray trashDir_c = QFile::encodeName(trashDir);
@@ -1058,6 +1192,7 @@ QString TrashImpl::trashForMountPoint(const QString &topdir, bool createIfNeeded
     if (createIfNeeded && initTrashDirectory(trashDir_c)) {
         return trashDir;
     }
+#endif
     return QString();
 }
 
@@ -1225,6 +1360,9 @@ bool TrashImpl::adaptTrashSize(const QString &origPath, int trashId)
         // calculate size of the files to be put into the trash
         qulonglong additionalSize = DiscSpaceUtil::sizeOfPath(origPath);
 
+#ifdef Q_OS_OSX
+        createTrashInfraStructure(trashId);
+#endif
         TrashSizeCache trashSize(trashPath);
         DiscSpaceUtil util(trashPath + QLatin1String("/files/"));
         if (util.usage(trashSize.calculateSize() + additionalSize) >= percent) {
diff --git src/ioslaves/trash/trashimpl.h src/ioslaves/trash/trashimpl.h
index 9886011..054a144 100644
--- src/ioslaves/trash/trashimpl.h
+++ src/ioslaves/trash/trashimpl.h
@@ -152,7 +152,11 @@ private:
     QString infoPath(int trashId, const QString &fileId) const;
     QString filesPath(int trashId, const QString &fileId) const;
 
+#ifdef Q_OS_OSX
+    int idForMountPoint(const QString &mountPoint) const;
+#else
     int idForDevice(const Solid::Device &device) const;
+#endif
     void refreshDevices() const;
 
     /// Find the trash dir to use for a given file to delete, based on original path
@@ -177,6 +181,14 @@ private Q_SLOTS:
     void jobFinished(KJob *job);
 
 private:
+    // delete the files and info subdirectories from all known trash directories
+    // (supposed to be empty!) to make sure OS X sees the trash as empty too.
+    // Stub except on OS X.
+    void deleteEmptyTrashInfraStructure();
+    // create the trash infrastructure; also called
+    // to recreate it on OS X.
+    bool createTrashInfraStructure(int trashId, const QString &path = QString());
+
     /// Last error code stored in class to simplify API.
     /// Note that this means almost no method can be const.
     int m_lastErrorCode;
