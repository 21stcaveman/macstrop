diff --git CMakeLists.txt CMakeLists.txt
index 6ea1cba..788183b 100644
--- CMakeLists.txt
+++ CMakeLists.txt
@@ -20,7 +20,7 @@ include(KDEInstallDirs)
 include(KDEFrameworkCompilerSettings NO_POLICY_SCOPE)
 include(KDECMakeSettings)
 
-set(REQUIRED_QT_VERSION 5.4.0)
+set(REQUIRED_QT_VERSION 5.5.0)
 find_package(Qt5 ${REQUIRED_QT_VERSION} CONFIG REQUIRED Widgets)
 
 set(KF5_VERSION "5.22.0") # handled by release scripts
@@ -36,6 +36,15 @@ find_package(KF5ConfigWidgets ${KF5_DEP_VERSION} REQUIRED)
 find_package(KF5IconThemes ${KF5_DEP_VERSION} REQUIRED)
 find_package(KF5Notifications ${KF5_DEP_VERSION} REQUIRED)
 find_package(KF5WidgetsAddons ${KF5_DEP_VERSION} REQUIRED)
+if(APPLE)
+    find_package(Qt5 ${REQUIRED_QT_VERSION} CONFIG REQUIRED DBus)
+    find_package(KF518n ${KF5_DEP_VERSION} REQUIRED)
+    find_package(KF5IO ${KF5_DEP_VERSION} REQUIRED)
+    add_definitions(-DTRANSLATION_DOMAIN=\"frameworkintegration5\")
+    if (IS_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}/po")
+        ki18n_install(po)
+    endif()
+endif()
 
 add_subdirectory(src)
 add_subdirectory(autotests)
diff --git src/CMakeLists.txt src/CMakeLists.txt
index 1c54eb2..9009c8f 100644
--- src/CMakeLists.txt
+++ src/CMakeLists.txt
@@ -1,3 +1,6 @@
 add_subdirectory(integrationplugin)
 add_subdirectory(kstyle)
 add_subdirectory(infopage)
+if(APPLE)
+    add_subdirectory(platformtheme)
+endif()
diff --git src/platformtheme/CMakeLists.txt src/platformtheme/CMakeLists.txt
new file mode 100644
index 0000000..2bb10cf
--- /dev/null
+++ src/platformtheme/CMakeLists.txt
@@ -0,0 +1,50 @@
+configure_file(config-platformtheme.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/config-platformtheme.h )
+
+set(platformtheme_SRCS
+    kdeplatformtheme.cpp
+    kfontsettingsdata.cpp
+    khintssettings.cpp
+    kdeplatformfiledialoghelper.cpp
+    kdeplatformfiledialogbase.cpp
+    kdeplatformsystemtrayicon.cpp
+    kfiletreeview.cpp
+    kdirselectdialog.cpp
+    kdemactheme.mm
+    kfontsettingsdatamac.mm
+    khintssettingsmac.mm
+    main_mac.cpp
+)
+
+include_directories(
+    ${Qt5Gui_PRIVATE_INCLUDE_DIRS}
+)
+# remove?
+# remove_definitions(-DQT_NO_CAST_FROM_ASCII)
+
+# rename to KDEMacTheme?
+add_library(KDEPlatformTheme MODULE ${platformtheme_SRCS})
+
+# add KF5:WindowSystem?
+target_link_libraries(KDEPlatformTheme
+    PRIVATE
+        Qt5::DBus
+        KF5::ConfigWidgets
+        KF5::ConfigCore
+        KF5::IconThemes
+        KF5::KIOFileWidgets # KFileFilterCombo, KDirSortFilterProxyModel, KRecentDirs
+        KF5::KIOWidgets
+        KF5::XmlGui
+        KF5::I18n
+        KF5::Notifications
+)
+
+target_link_libraries(KDEPlatformTheme PRIVATE "-framework AppKit")
+
+install(TARGETS KDEPlatformTheme DESTINATION ${KDE_INSTALL_QTPLUGINDIR}/platformthemes)
+
+install(FILES frameworksintegration-5.16-font.upd
+  DESTINATION ${KDE_INSTALL_KCONFUPDATEDIR}
+  )
+install(PROGRAMS frameworksintegration-5.16-font.sh
+  DESTINATION ${KDE_INSTALL_KCONFUPDATEDIR}
+  )
diff --git src/platformtheme/config-platformtheme.h.cmake src/platformtheme/config-platformtheme.h.cmake
new file mode 100644
index 0000000..808d898
--- /dev/null
+++ src/platformtheme/config-platformtheme.h.cmake
@@ -0,0 +1,2 @@
+#cmakedefine01 HAVE_X11
+#define BREEZE_STYLE_NAME "${BREEZE_STYLE_NAME}"
diff --git src/platformtheme/frameworksintegration-5.16-font.sh src/platformtheme/frameworksintegration-5.16-font.sh
new file mode 100644
index 0000000..9a202a1
--- /dev/null
+++ src/platformtheme/frameworksintegration-5.16-font.sh
@@ -0,0 +1,3 @@
+#!/bin/sh
+
+sed -i "s/Oxygen-Sans/Noto Sans/" `kf5-config --path config --locate kdeglobals`
diff --git src/platformtheme/frameworksintegration-5.16-font.upd src/platformtheme/frameworksintegration-5.16-font.upd
new file mode 100644
index 0000000..ae7f797
--- /dev/null
+++ src/platformtheme/frameworksintegration-5.16-font.upd
@@ -0,0 +1,5 @@
+Version=5
+
+# Update entry in kdeglobals for new font requested by VDG
+Id=frameworksintegration-5.16-font.sh
+Script=frameworksintegration-5.16-font.sh,sh
diff --git src/platformtheme/kdemactheme.h src/platformtheme/kdemactheme.h
new file mode 100644
index 0000000..9d3e7ad
--- /dev/null
+++ src/platformtheme/kdemactheme.h
@@ -0,0 +1,65 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Kevin Ottens <ervin+bluesystems@kde.org>
+ *  Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KDEMACTHEME_H
+#define KDEMACTHEME_H
+
+#include "kdeplatformtheme.h"
+#include "kfontsettingsdatamac.h"
+
+class KHintsSettingsMac;
+class QIconEngine;
+
+class KdeMacTheme : public KdePlatformTheme
+{
+public:
+    KdeMacTheme();
+    ~KdeMacTheme();
+
+    // KdeMacTheme must provide platform menu methods or else there will be no menus
+    QPlatformMenuItem* createPlatformMenuItem() const Q_DECL_OVERRIDE;
+    QPlatformMenu* createPlatformMenu() const Q_DECL_OVERRIDE;
+    QPlatformMenuBar* createPlatformMenuBar() const Q_DECL_OVERRIDE;
+
+    QVariant themeHint(ThemeHint hint) const Q_DECL_OVERRIDE;
+    const QPalette *palette(Palette type = SystemPalette) const Q_DECL_OVERRIDE;
+    const QFont *font(Font type) const Q_DECL_OVERRIDE;
+    QList<QKeySequence> keyBindings(QKeySequence::StandardKey key) const Q_DECL_OVERRIDE;
+
+    QPlatformDialogHelper *createPlatformDialogHelper(DialogType type) const Q_DECL_OVERRIDE;
+    bool usePlatformNativeDialog(DialogType type) const Q_DECL_OVERRIDE;
+
+    QString standardButtonText(int button) const Q_DECL_OVERRIDE;
+
+    QPlatformSystemTrayIcon *createPlatformSystemTrayIcon() const Q_DECL_OVERRIDE;
+
+protected:
+    void loadSettings();
+    KFontSettingsDataMac::FontTypes fontType(Font type) const;
+
+private:
+    KHintsSettingsMac *m_hints;
+    KFontSettingsDataMac *m_fontsData;
+    // this will hold the instance of the native theme that will be used as a fallback
+    QPlatformTheme *nativeTheme;
+};
+
+#endif // KDEMACTHEME_H
diff --git src/platformtheme/kdemactheme.mm src/platformtheme/kdemactheme.mm
new file mode 100644
index 0000000..de221f1
--- /dev/null
+++ src/platformtheme/kdemactheme.mm
@@ -0,0 +1,274 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Kevin Ottens <ervin+bluesystems@kde.org>
+ *  Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+ *  Copyright 2014 Lukáš Tinkl <ltinkl@redhat.com>
+ *  Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include "kdemactheme.h"
+#include "kfontsettingsdatamac.h"
+#include "khintssettingsmac.h"
+#include "kdeplatformfiledialoghelper.h"
+#include "kdeplatformsystemtrayicon.h"
+
+#include <QCoreApplication>
+#include <QMessageBox>
+#include <QFont>
+#include <QPalette>
+#include <QString>
+#include <QStringList>
+#include <QVariant>
+#include <QDebug>
+
+// instantiating the natice platform theme requires the use of private APIs
+#include <QtGui/private/qguiapplication_p.h>
+#include <QtGui/qpa/qplatformintegration.h>
+
+
+#include <kiconengine.h>
+#include <kiconloader.h>
+#include <kstandardshortcut.h>
+#include <KStandardGuiItem>
+#include <KLocalizedString>
+
+#include <AppKit/AppKit.h>
+
+static void warnNoNativeTheme()
+{
+    const char *msg = "The KdePlatformThemePlugin is being used and the native Cocoa theme failed to load.\n"
+                    "Applications will function but lack functionality available only through the native theme,\n"
+                    "including the menu bar at the top of the screen(s).";
+    // Make sure the warning appears somewhere. qWarning() isn't guaranteed to be of use when we're
+    // not called from a terminal session.
+    NSLog(@"%s", msg);
+}
+
+KdeMacTheme::KdeMacTheme()
+{
+    if (strcasecmp(QT_VERSION_STR, qVersion())) {
+        NSLog(@"Warning: the KDE Platform Plugin for Mac was built against Qt %s but is running with Qt %s!",
+            QT_VERSION_STR, qVersion());
+    }
+    QPlatformIntegration *pi = QGuiApplicationPrivate::platformIntegration();
+    if (pi) {
+        nativeTheme = pi->createPlatformTheme(QString::fromLatin1("cocoa"));
+    } else {
+        nativeTheme = Q_NULLPTR;
+    }
+    if (!nativeTheme) {
+        warnNoNativeTheme();
+    }
+    m_fontsData = Q_NULLPTR;
+    m_hints = Q_NULLPTR;
+    loadSettings();
+}
+
+KdeMacTheme::~KdeMacTheme()
+{
+//     delete m_fontsData;
+//     delete m_hints;
+    delete nativeTheme;
+}
+
+QPlatformMenuItem* KdeMacTheme::createPlatformMenuItem() const
+{
+    if (nativeTheme) {
+        return nativeTheme->createPlatformMenuItem();
+    } else {
+        warnNoNativeTheme();
+        return QPlatformTheme::createPlatformMenuItem();
+    }
+}
+
+QPlatformMenu* KdeMacTheme::createPlatformMenu() const
+{
+    if (nativeTheme) {
+        return nativeTheme->createPlatformMenu();
+    } else {
+        warnNoNativeTheme();
+        return QPlatformTheme::createPlatformMenu();
+    }
+}
+
+QPlatformMenuBar* KdeMacTheme::createPlatformMenuBar() const
+{
+    if (nativeTheme) {
+        return nativeTheme->createPlatformMenuBar();
+    } else {
+        warnNoNativeTheme();
+        return QPlatformTheme::createPlatformMenuBar();
+    }
+}
+
+QVariant KdeMacTheme::themeHint(QPlatformTheme::ThemeHint hintType) const
+{
+    QVariant hint = m_hints->hint(hintType);
+    if (hint.isValid()) {
+        return hint;
+    } else {
+        if (nativeTheme) {
+            return nativeTheme->themeHint(hintType);
+        }
+        return QPlatformTheme::themeHint(hintType);
+    }
+}
+
+const QPalette *KdeMacTheme::palette(Palette type) const
+{
+    QPalette *palette = m_hints->palette(type);
+    if (palette) {
+        return palette;
+    } else {
+        if (nativeTheme) {
+            return nativeTheme->palette(type);
+        }
+        return QPlatformTheme::palette(type);
+    }
+}
+
+KFontSettingsDataMac::FontTypes KdeMacTheme::fontType(QPlatformTheme::Font type) const
+{
+    KFontSettingsDataMac::FontTypes ftype;
+    switch (type) {
+        default:
+            ftype = KFontSettingsDataMac::FontTypes(KdePlatformTheme::fontType(type));
+            break;
+        case MessageBoxFont:
+            ftype = KFontSettingsDataMac::MessageBoxFont;
+            break;
+    }
+    return ftype;
+}
+
+const QFont *KdeMacTheme::font(Font type) const
+{
+    // when using the platform-default fonts, try returning a bold version of the 
+    // standard system font; it's the only one where Qt/OS X really deviates.
+    return m_fontsData->font(fontType(type));
+}
+
+void KdeMacTheme::loadSettings()
+{
+    if (!m_fontsData) {
+        m_fontsData = new KFontSettingsDataMac;
+        m_hints = new KHintsSettingsMac;
+    }
+}
+
+QList<QKeySequence> KdeMacTheme::keyBindings(QKeySequence::StandardKey key) const
+{
+    // return a native keybinding if we can determine what that is
+    if (nativeTheme) {
+        return nativeTheme->keyBindings(key);
+    }
+    // or else we return whatever KDE applications expect elsewhere
+    return KdePlatformTheme::keyBindings(key);
+}
+
+bool KdeMacTheme::usePlatformNativeDialog(QPlatformTheme::DialogType type) const
+{
+    if (nativeTheme) {
+        return nativeTheme->usePlatformNativeDialog(type);
+    }
+    return type == QPlatformTheme::FileDialog;
+}
+
+QString KdeMacTheme::standardButtonText(int button) const
+{
+    // assume that button text is a domain where cross-platform application
+    // coherence primes over native platform look and feel. IOW, function over form.
+    // It's impossible to use the parent's method since we use
+    // the nativeTheme in the default case
+    switch (static_cast<QPlatformDialogHelper::StandardButton>(button)) {
+    case QPlatformDialogHelper::NoButton:
+        qWarning() << Q_FUNC_INFO << "Unsupported standard button:" << button;
+        return QString();
+    case QPlatformDialogHelper::Ok:
+        return KStandardGuiItem::ok().text();
+    case QPlatformDialogHelper::Save:
+        return KStandardGuiItem::save().text();
+    case QPlatformDialogHelper::SaveAll:
+        return i18nc("@action:button", "Save All");
+    case QPlatformDialogHelper::Open:
+        return KStandardGuiItem::open().text();
+    case QPlatformDialogHelper::Yes:
+        return KStandardGuiItem::yes().text();
+    case QPlatformDialogHelper::YesToAll:
+        return i18nc("@action:button", "Yes to All");
+    case QPlatformDialogHelper::No:
+        return KStandardGuiItem::no().text();
+    case QPlatformDialogHelper::NoToAll:
+        return i18nc("@action:button", "No to All");
+    case QPlatformDialogHelper::Abort:
+        // FIXME KStandardGuiItem::stop() doesn't seem right here
+        return i18nc("@action:button", "Abort");
+    case QPlatformDialogHelper::Retry:
+        return i18nc("@action:button", "Retry");
+    case QPlatformDialogHelper::Ignore:
+        return i18nc("@action:button", "Ignore");
+    case QPlatformDialogHelper::Close:
+        return KStandardGuiItem::close().text();
+    case QPlatformDialogHelper::Cancel:
+        return KStandardGuiItem::cancel().text();
+    case QPlatformDialogHelper::Discard:
+        return KStandardGuiItem::discard().text();
+    case QPlatformDialogHelper::Help:
+        return KStandardGuiItem::help().text();
+    case QPlatformDialogHelper::Apply:
+        return KStandardGuiItem::apply().text();
+    case QPlatformDialogHelper::Reset:
+        return KStandardGuiItem::reset().text();
+    case QPlatformDialogHelper::RestoreDefaults:
+        return KStandardGuiItem::defaults().text();
+    default:
+        if (nativeTheme) {
+            // something not foreseen by Qt/KDE: now see if OS X
+            // has an opinion about the text.
+            return nativeTheme->standardButtonText(button);
+        }
+        return QPlatformTheme::defaultStandardButtonText(button);
+    }
+}
+
+QPlatformDialogHelper *KdeMacTheme::createPlatformDialogHelper(QPlatformTheme::DialogType type) const
+{
+    // always prefer native dialogs
+    // NOTE: somehow, the "don't use native dialog" option that Qt's example "standarddialogs"
+    // provides does not modify our usePlatformNativeDialog() return value, but *does* cause
+    // a Qt dialog to be created instead of the native one. Weird.
+    if (nativeTheme) {
+        return nativeTheme->createPlatformDialogHelper(type);
+    }
+    QPlatformDialogHelper *helper = KdePlatformTheme::createPlatformDialogHelper(type);
+    if (helper) {
+        return helper;
+    } else {
+        return QPlatformTheme::createPlatformDialogHelper(type);
+    }
+}
+
+QPlatformSystemTrayIcon *KdeMacTheme::createPlatformSystemTrayIcon() const
+{
+    if (nativeTheme) {
+        return nativeTheme->createPlatformSystemTrayIcon();
+    }
+    // TODO: figure out if it makes sense to return something other than 
+    // nativeTheme->createPlatformSystemTrayIcon() or even NULL
+    return KdePlatformTheme::createPlatformSystemTrayIcon();
+}
diff --git src/platformtheme/kdeplatformfiledialogbase.cpp src/platformtheme/kdeplatformfiledialogbase.cpp
new file mode 100644
index 0000000..856c052
--- /dev/null
+++ src/platformtheme/kdeplatformfiledialogbase.cpp
@@ -0,0 +1,47 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include "kdeplatformfiledialogbase_p.h"
+
+KDEPlatformFileDialogBase::KDEPlatformFileDialogBase()
+{
+    m_timer.setInterval(0);
+    m_timer.setSingleShot(true);
+    connect(&m_timer, &QTimer::timeout, this, &KDEPlatformFileDialogBase::show);
+}
+
+void KDEPlatformFileDialogBase::delayedShow()
+{
+    m_timer.start();
+}
+
+void KDEPlatformFileDialogBase::discardDelayedShow()
+{
+    // this is used when hide() is called before timer triggers.
+    m_timer.stop();
+}
+
+void KDEPlatformFileDialogBase::closeEvent(QCloseEvent *e)
+{
+    Q_EMIT closed();
+    QDialog::closeEvent(e);
+}
+
+#include "moc_kdeplatformfiledialogbase_p.cpp"
diff --git src/platformtheme/kdeplatformfiledialogbase_p.h src/platformtheme/kdeplatformfiledialogbase_p.h
new file mode 100644
index 0000000..3191027
--- /dev/null
+++ src/platformtheme/kdeplatformfiledialogbase_p.h
@@ -0,0 +1,61 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KDEPLATFORMFILEDIALOGBASE_H
+#define KDEPLATFORMFILEDIALOGBASE_H
+
+#include <QDialog>
+#include <QUrl>
+#include <QTimer>
+
+class KFileWidget;
+class QDialogButtonBox;
+class KDEPlatformFileDialogBase : public QDialog
+{
+    Q_OBJECT
+public:
+    friend class KDEPlatformFileDialogHelper;
+
+    explicit KDEPlatformFileDialogBase();
+    virtual QUrl directory() = 0;
+    virtual void selectNameFilter(const QString &filter) = 0;
+    virtual void setDirectory(const QUrl &directory) = 0;
+    virtual void selectFile(const QUrl &filename) = 0;
+    virtual QString selectedNameFilter() = 0;
+    virtual QList<QUrl> selectedFiles() = 0;
+
+    void delayedShow();
+    void discardDelayedShow();
+
+Q_SIGNALS:
+    void closed();
+    void fileSelected(const QUrl &file);
+    void filesSelected(const QList<QUrl> &files);
+    void currentChanged(const QUrl &path);
+    void directoryEntered(const QUrl &directory);
+    void filterSelected(const QString &filter);
+
+protected:
+    void closeEvent(QCloseEvent *e) Q_DECL_OVERRIDE;
+    QDialogButtonBox *m_buttons;
+    QTimer m_timer;
+};
+
+#endif
diff --git src/platformtheme/kdeplatformfiledialoghelper.cpp src/platformtheme/kdeplatformfiledialoghelper.cpp
new file mode 100644
index 0000000..139c35d
--- /dev/null
+++ src/platformtheme/kdeplatformfiledialoghelper.cpp
@@ -0,0 +1,381 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+ *  Copyright 2014 Martin Klapetek <mklapetek@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include "kdeplatformfiledialoghelper.h"
+#include "kdeplatformfiledialogbase_p.h"
+#include "kdirselectdialog_p.h"
+
+#include <kfilefiltercombo.h>
+#include <kfilewidget.h>
+#include <klocalizedstring.h>
+#include <kdiroperator.h>
+#include <KUrlComboBox>
+#include <KSharedConfig>
+#include <KWindowConfig>
+#include <KProtocolInfo>
+#include <QVBoxLayout>
+#include <QDialogButtonBox>
+#include <QPushButton>
+#include <QWindow>
+
+#include <KIO/StatJob>
+#include <KJobWidgets>
+
+#include <QTextStream>
+
+namespace
+{
+
+/*
+ * Map a Qt filter string into a KDE one.
+ */
+static QString qt2KdeFilter(const QStringList &f)
+{
+    QString               filter;
+    QTextStream           str(&filter, QIODevice::WriteOnly);
+    QStringList           list(f);
+    list.replaceInStrings(QStringLiteral("/"), QStringLiteral("\\/"));
+    QStringList::const_iterator it(list.constBegin()), end(list.constEnd());
+    bool                  first = true;
+
+    for (; it != end; ++it) {
+        int ob = it->lastIndexOf(QLatin1Char('(')),
+            cb = it->lastIndexOf(QLatin1Char(')'));
+
+        if (-1 != cb && ob < cb) {
+            if (first) {
+                first = false;
+            } else {
+                str << '\n';
+            }
+            str << it->mid(ob + 1, (cb - ob) - 1) << '|' << it->mid(0, ob);
+        }
+    }
+
+    return filter;
+}
+
+/*
+ * Map a KDE filter string into a Qt one.
+ */
+static QString kde2QtFilter(const QStringList &list, const QString &kde)
+{
+    QStringList::const_iterator it(list.constBegin()), end(list.constEnd());
+    int                   pos;
+
+    for (; it != end; ++it) {
+        if (-1 != (pos = it->indexOf(kde)) && pos > 0 &&
+                (QLatin1Char('(') == (*it)[pos - 1] || QLatin1Char(' ') == (*it)[pos - 1]) &&
+                it->length() >= kde.length() + pos &&
+                (QLatin1Char(')') == (*it)[pos + kde.length()] || QLatin1Char(' ') == (*it)[pos + kde.length()])) {
+            return *it;
+        }
+    }
+    return QString();
+}
+}
+
+KDEPlatformFileDialog::KDEPlatformFileDialog()
+    : KDEPlatformFileDialogBase()
+    , m_fileWidget(new KFileWidget(QUrl(), this))
+{
+    setLayout(new QVBoxLayout);
+    connect(m_fileWidget, SIGNAL(filterChanged(QString)), SIGNAL(filterSelected(QString)));
+    layout()->addWidget(m_fileWidget);
+
+    m_buttons = new QDialogButtonBox(this);
+    m_buttons->addButton(m_fileWidget->okButton(), QDialogButtonBox::AcceptRole);
+    m_buttons->addButton(m_fileWidget->cancelButton(), QDialogButtonBox::RejectRole);
+    connect(m_buttons, SIGNAL(rejected()), m_fileWidget, SLOT(slotCancel()));
+    connect(m_fileWidget->okButton(), SIGNAL(clicked(bool)), m_fileWidget, SLOT(slotOk()));
+    connect(m_fileWidget, SIGNAL(accepted()), m_fileWidget, SLOT(accept()));
+    connect(m_fileWidget, SIGNAL(accepted()), SLOT(accept()));
+    connect(m_fileWidget->cancelButton(), SIGNAL(clicked(bool)), SLOT(reject()));
+    layout()->addWidget(m_buttons);
+}
+
+QUrl KDEPlatformFileDialog::directory()
+{
+    return m_fileWidget->baseUrl();
+}
+
+QList<QUrl> KDEPlatformFileDialog::selectedFiles()
+{
+    return m_fileWidget->selectedUrls();
+}
+
+void KDEPlatformFileDialog::selectFile(const QUrl &filename)
+{
+    QUrl dirUrl = filename.adjusted(QUrl::RemoveFilename);
+    m_fileWidget->setUrl(dirUrl);
+    m_fileWidget->setSelection(filename.fileName());
+}
+
+void KDEPlatformFileDialog::setViewMode(QFileDialogOptions::ViewMode view)
+{
+    switch (view) {
+    case QFileDialogOptions::ViewMode::Detail:
+        m_fileWidget->setViewMode(KFile::FileView::Detail);
+        break;
+    case QFileDialogOptions::ViewMode::List:
+        m_fileWidget->setViewMode(KFile::FileView::Simple);
+        break;
+    default:
+        m_fileWidget->setViewMode(KFile::FileView::Default);
+        break;
+    }
+}
+
+void KDEPlatformFileDialog::setFileMode(QFileDialogOptions::FileMode mode)
+{
+    switch (mode) {
+    case QFileDialogOptions::FileMode::AnyFile:
+        m_fileWidget->setMode(KFile::File);
+        break;
+    case QFileDialogOptions::FileMode::ExistingFile:
+        m_fileWidget->setMode(KFile::Mode::File | KFile::Mode::ExistingOnly);
+        break;
+    case QFileDialogOptions::FileMode::Directory:
+        m_fileWidget->setMode(KFile::Mode::Directory | KFile::Mode::ExistingOnly);
+        break;
+    case QFileDialogOptions::FileMode::ExistingFiles:
+        m_fileWidget->setMode(KFile::Mode::Files | KFile::Mode::ExistingOnly);
+        break;
+    default:
+        m_fileWidget->setMode(KFile::File);
+        break;
+    }
+}
+
+void KDEPlatformFileDialog::setCustomLabel(QFileDialogOptions::DialogLabel label, const QString &text)
+{
+    if (label == QFileDialogOptions::Accept) { // OK button
+        m_fileWidget->okButton()->setText(text);
+    } else if (label == QFileDialogOptions::Reject) { // Cancel button
+        m_fileWidget->cancelButton()->setText(text);
+    } else if (label == QFileDialogOptions::LookIn) { // Location label
+        m_fileWidget->setLocationLabel(text);
+    }
+}
+
+QString KDEPlatformFileDialog::selectedNameFilter()
+{
+    return m_fileWidget->filterWidget()->currentFilter();
+}
+
+void KDEPlatformFileDialog::selectNameFilter(const QString &filter)
+{
+    m_fileWidget->filterWidget()->setCurrentFilter(filter);
+}
+
+void KDEPlatformFileDialog::setDirectory(const QUrl &directory)
+{
+    if (!directory.isLocalFile())  {
+        // Qt can not determine if the remote URL points to a file or a
+        // directory, that is why options()->initialDirectory() always returns
+        // the full URL.
+        KIO::StatJob *job = KIO::stat(directory);
+        KJobWidgets::setWindow(job, this);
+        if (job->exec()) {
+            KIO::UDSEntry entry = job->statResult();
+            if (!entry.isDir()) {
+                // this is probably a file remove the file part
+                m_fileWidget->setUrl(directory.adjusted(QUrl::RemoveFilename));
+                m_fileWidget->setSelection(directory.fileName());
+            }
+            else {
+                m_fileWidget->setUrl(directory);
+            }
+        }
+    }
+    else {
+        m_fileWidget->setUrl(directory);
+    }
+}
+
+bool KDEPlatformFileDialogHelper::isSupportedUrl(const QUrl& url) const
+{
+    return KProtocolInfo::protocols().contains(url.scheme());
+}
+
+////////////////////////////////////////////////
+
+KDEPlatformFileDialogHelper::KDEPlatformFileDialogHelper()
+    : QPlatformFileDialogHelper()
+    , m_dialog(new KDEPlatformFileDialog)
+{
+    connect(m_dialog, SIGNAL(closed()), SLOT(saveSize()));
+    connect(m_dialog, SIGNAL(finished(int)), SLOT(saveSize()));
+    connect(m_dialog, SIGNAL(currentChanged(QUrl)), SIGNAL(currentChanged(QUrl)));
+    connect(m_dialog, SIGNAL(directoryEntered(QUrl)), SIGNAL(directoryEntered(QUrl)));
+    connect(m_dialog, SIGNAL(fileSelected(QUrl)), SIGNAL(fileSelected(QUrl)));
+    connect(m_dialog, SIGNAL(filesSelected(QList<QUrl>)), SIGNAL(filesSelected(QList<QUrl>)));
+    connect(m_dialog, SIGNAL(filterSelected(QString)), SIGNAL(filterSelected(QString)));
+    connect(m_dialog, SIGNAL(accepted()), SIGNAL(accept()));
+    connect(m_dialog, SIGNAL(rejected()), SIGNAL(reject()));
+}
+
+KDEPlatformFileDialogHelper::~KDEPlatformFileDialogHelper()
+{
+    saveSize();
+    delete m_dialog;
+}
+
+void KDEPlatformFileDialogHelper::initializeDialog()
+{
+    if (options()->testOption(QFileDialogOptions::ShowDirsOnly)) {
+        m_dialog->deleteLater();
+        m_dialog = new KDirSelectDialog(options()->initialDirectory());
+        connect(m_dialog, SIGNAL(accepted()), SIGNAL(accept()));
+        connect(m_dialog, SIGNAL(rejected()), SIGNAL(reject()));
+        if (!options()->windowTitle().isEmpty())
+            m_dialog->setWindowTitle(options()->windowTitle());
+    } else {
+        // needed for accessing m_fileWidget
+        KDEPlatformFileDialog *dialog = qobject_cast<KDEPlatformFileDialog*>(m_dialog);
+        dialog->m_fileWidget->setOperationMode(options()->acceptMode() == QFileDialogOptions::AcceptOpen ? KFileWidget::Opening : KFileWidget::Saving);
+        if (options()->windowTitle().isEmpty()) {
+            dialog->setWindowTitle(options()->acceptMode() == QFileDialogOptions::AcceptOpen ? i18nc("@title:window", "Open File") : i18nc("@title:window", "Save File"));
+        } else {
+            dialog->setWindowTitle(options()->windowTitle());
+        }
+        setDirectory(options()->initialDirectory());
+        //dialog->setViewMode(options()->viewMode()); // don't override our options, fixes remembering the chosen view mode and sizes!
+        dialog->setFileMode(options()->fileMode());
+
+        // custom labels
+        if (options()->isLabelExplicitlySet(QFileDialogOptions::Accept)) { // OK button
+            dialog->setCustomLabel(QFileDialogOptions::Accept, options()->labelText(QFileDialogOptions::Accept));
+        } else if (options()->isLabelExplicitlySet(QFileDialogOptions::Reject)) { // Cancel button
+            dialog->setCustomLabel(QFileDialogOptions::Reject, options()->labelText(QFileDialogOptions::Reject));
+        } else if (options()->isLabelExplicitlySet(QFileDialogOptions::LookIn)) { // Location label
+            dialog->setCustomLabel(QFileDialogOptions::LookIn, options()->labelText(QFileDialogOptions::LookIn));
+        }
+
+        const QStringList mimeFilters = options()->mimeTypeFilters();
+        const QStringList nameFilters = options()->nameFilters();
+        if (!mimeFilters.isEmpty()) {
+            dialog->m_fileWidget->setMimeFilter(mimeFilters);
+
+            if ( mimeFilters.contains( QStringLiteral("inode/directory") ) )
+                dialog->m_fileWidget->setMode( dialog->m_fileWidget->mode() | KFile::Directory );
+        } else if (!nameFilters.isEmpty()) {
+            dialog->m_fileWidget->setFilter(qt2KdeFilter(nameFilters));
+        }
+
+        if (!options()->initiallySelectedNameFilter().isEmpty()) {
+            selectNameFilter(options()->initiallySelectedNameFilter());
+        }
+
+        // overwrite option
+        if (options()->testOption(QFileDialogOptions::FileDialogOption::DontConfirmOverwrite)) {
+            dialog->m_fileWidget->setConfirmOverwrite(false);
+        }
+    }
+}
+
+void KDEPlatformFileDialogHelper::exec()
+{
+    restoreSize();
+    // KDEPlatformFileDialog::show() will always be called during QFileDialog::exec()
+    // discard the delayed show() it and use exec() and it will call show() for us.
+    // We can't hide and show it here because of https://bugreports.qt.io/browse/QTBUG-48248
+    m_dialog->discardDelayedShow();
+    m_dialog->exec();
+}
+
+void KDEPlatformFileDialogHelper::hide()
+{
+    m_dialog->discardDelayedShow();
+    m_dialog->hide();
+}
+
+void KDEPlatformFileDialogHelper::saveSize()
+{
+    KSharedConfig::Ptr conf = KSharedConfig::openConfig();
+    KConfigGroup group = conf->group("FileDialogSize");
+    KWindowConfig::saveWindowSize(m_dialog->windowHandle(), group);
+}
+
+void KDEPlatformFileDialogHelper::restoreSize()
+{
+    m_dialog->winId(); // ensure there's a window created
+    KSharedConfig::Ptr conf = KSharedConfig::openConfig();
+    KWindowConfig::restoreWindowSize(m_dialog->windowHandle(), conf->group("FileDialogSize"));
+    // NOTICE: QWindow::setGeometry() does NOT impact the backing QWidget geometry even if the platform
+    // window was created -> QTBUG-40584. We therefore copy the size here.
+    // TODO: remove once this was resolved in QWidget QPA
+    m_dialog->resize(m_dialog->windowHandle()->size());
+}
+
+bool KDEPlatformFileDialogHelper::show(Qt::WindowFlags windowFlags, Qt::WindowModality windowModality, QWindow *parent)
+{
+    Q_UNUSED(parent)
+    initializeDialog();
+    m_dialog->setWindowFlags(windowFlags);
+    m_dialog->setWindowModality(windowModality);
+    restoreSize();
+    // Use a delayed show here to delay show() after the internal Qt invisible QDialog.
+    // The delayed call shouldn't matter, because for other "real" native QPlatformDialog
+    // implementation like Mac and Windows, the native dialog is not necessarily
+    // show up immediately.
+    m_dialog->delayedShow();
+    return true;
+}
+
+QList<QUrl> KDEPlatformFileDialogHelper::selectedFiles() const
+{
+    return m_dialog->selectedFiles();
+}
+
+QString KDEPlatformFileDialogHelper::selectedNameFilter() const
+{
+    return kde2QtFilter(options()->nameFilters(), m_dialog->selectedNameFilter());
+}
+
+QUrl KDEPlatformFileDialogHelper::directory() const
+{
+    return m_dialog->directory();
+}
+
+void KDEPlatformFileDialogHelper::selectFile(const QUrl &filename)
+{
+    m_dialog->selectFile(filename);
+}
+
+void KDEPlatformFileDialogHelper::setDirectory(const QUrl &directory)
+{
+    m_dialog->setDirectory(directory);
+}
+
+void KDEPlatformFileDialogHelper::selectNameFilter(const QString &filter)
+{
+    m_dialog->selectNameFilter(qt2KdeFilter(QStringList(filter)));
+}
+
+void KDEPlatformFileDialogHelper::setFilter()
+{
+}
+
+bool KDEPlatformFileDialogHelper::defaultNameFilterDisables() const
+{
+    return false;
+}
diff --git src/platformtheme/kdeplatformfiledialoghelper.h src/platformtheme/kdeplatformfiledialoghelper.h
new file mode 100644
index 0000000..f80b8c7
--- /dev/null
+++ src/platformtheme/kdeplatformfiledialoghelper.h
@@ -0,0 +1,81 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KDEPLATFORMFILEDIALOGHELPER_H
+#define KDEPLATFORMFILEDIALOGHELPER_H
+
+#include <qpa/qplatformdialoghelper.h>
+#include "kdeplatformfiledialogbase_p.h"
+
+class KFileWidget;
+class QDialogButtonBox;
+class KDEPlatformFileDialog : public KDEPlatformFileDialogBase
+{
+    Q_OBJECT
+public:
+    friend class KDEPlatformFileDialogHelper;
+
+    explicit KDEPlatformFileDialog();
+    QUrl directory() Q_DECL_OVERRIDE;
+    void selectNameFilter(const QString &filter) Q_DECL_OVERRIDE;
+    void setDirectory(const QUrl &directory) Q_DECL_OVERRIDE;
+    void selectFile(const QUrl &filename) Q_DECL_OVERRIDE;
+    void setViewMode(QFileDialogOptions::ViewMode view);
+    void setFileMode(QFileDialogOptions::FileMode mode);
+    void setCustomLabel(QFileDialogOptions::DialogLabel label, const QString & text);
+    QString selectedNameFilter() Q_DECL_OVERRIDE;
+    QList<QUrl> selectedFiles() Q_DECL_OVERRIDE;
+
+protected:
+    KFileWidget *m_fileWidget;
+};
+
+class KDEPlatformFileDialogHelper : public QPlatformFileDialogHelper
+{
+    Q_OBJECT
+public:
+    KDEPlatformFileDialogHelper();
+    virtual ~KDEPlatformFileDialogHelper();
+
+    void initializeDialog();
+
+    bool defaultNameFilterDisables() const Q_DECL_OVERRIDE;
+    QUrl directory() const Q_DECL_OVERRIDE;
+    QList<QUrl> selectedFiles() const Q_DECL_OVERRIDE;
+    QString selectedNameFilter() const Q_DECL_OVERRIDE;
+    void selectNameFilter(const QString &filter) Q_DECL_OVERRIDE;
+    void selectFile(const QUrl &filename) Q_DECL_OVERRIDE;
+    void setFilter() Q_DECL_OVERRIDE;
+    void setDirectory(const QUrl &directory) Q_DECL_OVERRIDE;
+    bool isSupportedUrl(const QUrl& url) const Q_DECL_OVERRIDE;
+
+    void exec() Q_DECL_OVERRIDE;
+    void hide() Q_DECL_OVERRIDE;
+    bool show(Qt::WindowFlags windowFlags, Qt::WindowModality windowModality, QWindow *parent) Q_DECL_OVERRIDE;
+
+private Q_SLOTS:
+    void saveSize();
+
+private:
+    void restoreSize();
+    KDEPlatformFileDialogBase *m_dialog;
+};
+
+#endif // KDEPLATFORMFILEDIALOGHELPER_H
diff --git src/platformtheme/kdeplatformsystemtrayicon.cpp src/platformtheme/kdeplatformsystemtrayicon.cpp
new file mode 100644
index 0000000..6bd0d4a
--- /dev/null
+++ src/platformtheme/kdeplatformsystemtrayicon.cpp
@@ -0,0 +1,355 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2014 Martin Gr��lin <mgraesslin@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+#include "kdeplatformsystemtrayicon.h"
+#include <kstatusnotifieritem.h>
+#include <QAction>
+#include <QIcon>
+#include <QMenu>
+#include <QRect>
+#include <QApplication>
+#include <QDBusInterface>
+
+SystemTrayMenu::SystemTrayMenu()
+    : QPlatformMenu()
+    , m_tag(0)
+    , m_menu(new QMenu())
+{
+    connect(m_menu.data(), &QMenu::aboutToShow, this, &QPlatformMenu::aboutToShow);
+    connect(m_menu.data(), &QMenu::aboutToHide, this, &QPlatformMenu::aboutToHide);
+}
+
+SystemTrayMenu::~SystemTrayMenu()
+{
+    if (m_menu) {
+        m_menu->deleteLater();
+    }
+}
+
+QPlatformMenuItem *SystemTrayMenu::createMenuItem() const
+{
+    return new SystemTrayMenuItem();
+}
+
+void SystemTrayMenu::insertMenuItem(QPlatformMenuItem *menuItem, QPlatformMenuItem *before)
+{
+    if (SystemTrayMenuItem *ours = qobject_cast<SystemTrayMenuItem*>(menuItem)) {
+        bool inserted = false;
+        if (SystemTrayMenuItem *oursBefore = qobject_cast<SystemTrayMenuItem*>(before)) {
+            for (auto it = m_items.begin(); it != m_items.end(); ++it) {
+                if (*it == oursBefore) {
+                    m_items.insert(it, ours);
+                    if (m_menu) {
+                        m_menu->insertAction(oursBefore->action(), ours->action());
+                    }
+                    inserted = true;
+                    break;
+                }
+            }
+        }
+        if (!inserted) {
+            m_items.append(ours);
+            if (m_menu) {
+                m_menu->addAction(ours->action());
+            }
+        }
+    }
+}
+
+QPlatformMenuItem *SystemTrayMenu::menuItemAt(int position) const
+{
+    if (position < m_items.size()) {
+        return m_items.at(position);
+    }
+    return Q_NULLPTR;
+}
+
+QPlatformMenuItem *SystemTrayMenu::menuItemForTag(quintptr tag) const
+{
+    auto it = std::find_if(m_items.constBegin(), m_items.constEnd(), [tag](SystemTrayMenuItem *item) {
+        return item->tag() == tag;
+    });
+    if (it != m_items.constEnd()) {
+        return *it;
+    }
+    return Q_NULLPTR;
+}
+
+void SystemTrayMenu::removeMenuItem(QPlatformMenuItem *menuItem)
+{
+    if (SystemTrayMenuItem *ours = qobject_cast<SystemTrayMenuItem*>(menuItem)) {
+        m_items.removeOne(ours);
+        if (ours->action() && m_menu) {
+            m_menu->removeAction(ours->action());
+        }
+    }
+}
+
+void SystemTrayMenu::setEnabled(bool enabled)
+{
+    if (!m_menu) {
+        return;
+    }
+    m_menu->setEnabled(enabled);
+}
+
+void SystemTrayMenu::setIcon(const QIcon &icon)
+{
+    if (!m_menu) {
+        return;
+    }
+    m_menu->setIcon(icon);
+}
+
+void SystemTrayMenu::setTag(quintptr tag)
+{
+    m_tag = tag;
+}
+
+void SystemTrayMenu::setText(const QString &text)
+{
+    if (!m_menu) {
+        return;
+    }
+    m_menu->setTitle(text);
+}
+
+void SystemTrayMenu::setVisible(bool visible)
+{
+    if (!m_menu) {
+        return;
+    }
+    m_menu->setVisible(visible);
+}
+
+void SystemTrayMenu::syncMenuItem(QPlatformMenuItem *menuItem)
+{
+    Q_UNUSED(menuItem)
+    // nothing to do
+}
+
+void SystemTrayMenu::syncSeparatorsCollapsible(bool enable)
+{
+    if (!m_menu) {
+        return;
+    }
+    m_menu->setSeparatorsCollapsible(enable);
+}
+
+quintptr SystemTrayMenu::tag() const
+{
+    return m_tag;
+}
+
+QMenu *SystemTrayMenu::menu() const
+{
+    return m_menu.data();
+}
+
+SystemTrayMenuItem::SystemTrayMenuItem()
+    : QPlatformMenuItem()
+    , m_tag(0)
+    , m_action(new QAction(this))
+{
+    connect(m_action, &QAction::triggered, this, &QPlatformMenuItem::activated);
+    connect(m_action, &QAction::hovered, this, &QPlatformMenuItem::hovered);
+}
+
+SystemTrayMenuItem::~SystemTrayMenuItem()
+{
+}
+
+void SystemTrayMenuItem::setCheckable(bool checkable)
+{
+    m_action->setCheckable(checkable);
+}
+
+void SystemTrayMenuItem::setChecked(bool isChecked)
+{
+    m_action->setChecked(isChecked);
+}
+
+void SystemTrayMenuItem::setEnabled(bool enabled)
+{
+    m_action->setEnabled(enabled);
+}
+
+void SystemTrayMenuItem::setFont(const QFont &font)
+{
+    m_action->setFont(font);
+}
+
+void SystemTrayMenuItem::setIcon(const QIcon &icon)
+{
+    m_action->setIcon(icon);
+}
+
+void SystemTrayMenuItem::setIsSeparator(bool isSeparator)
+{
+    m_action->setSeparator(isSeparator);
+}
+
+void SystemTrayMenuItem::setMenu(QPlatformMenu *menu)
+{
+    if (SystemTrayMenu *ourMenu = qobject_cast<SystemTrayMenu *>(menu)) {
+        m_action->setMenu(ourMenu->menu());
+    }
+}
+
+void SystemTrayMenuItem::setRole(QPlatformMenuItem::MenuRole role)
+{
+    Q_UNUSED(role)
+}
+
+void SystemTrayMenuItem::setShortcut(const QKeySequence &shortcut)
+{
+    m_action->setShortcut(shortcut);
+}
+
+void SystemTrayMenuItem::setTag(quintptr tag)
+{
+    m_tag = tag;
+}
+
+void SystemTrayMenuItem::setText(const QString &text)
+{
+    m_action->setText(text);
+}
+
+void SystemTrayMenuItem::setVisible(bool isVisible)
+{
+    m_action->setVisible(isVisible);
+}
+
+void SystemTrayMenuItem::setIconSize(int size)
+{
+    Q_UNUSED(size);
+}
+
+quintptr SystemTrayMenuItem::tag() const
+{
+    return m_tag;
+}
+
+QAction *SystemTrayMenuItem::action() const
+{
+    return m_action;
+}
+
+KDEPlatformSystemTrayIcon::KDEPlatformSystemTrayIcon()
+    : QPlatformSystemTrayIcon()
+    , m_sni(Q_NULLPTR)
+{
+}
+
+KDEPlatformSystemTrayIcon::~KDEPlatformSystemTrayIcon()
+{
+}
+
+void KDEPlatformSystemTrayIcon::init()
+{
+    if (!m_sni) {
+        m_sni = new KStatusNotifierItem();
+        m_sni->setStandardActionsEnabled(false);
+        m_sni->setTitle(QApplication::applicationDisplayName());
+        connect(m_sni, &KStatusNotifierItem::activateRequested, [this](bool active, const QPoint &pos) {
+            Q_UNUSED(active)
+            Q_UNUSED(pos)
+            emit activated(QPlatformSystemTrayIcon::Trigger);
+        });
+        connect(m_sni, &KStatusNotifierItem::secondaryActivateRequested, [this](const QPoint &pos) {
+            Q_UNUSED(pos)
+            emit activated(QPlatformSystemTrayIcon::Context);
+        });
+    }
+}
+
+void KDEPlatformSystemTrayIcon::cleanup()
+{
+    delete m_sni;
+    m_sni = Q_NULLPTR;
+}
+
+void KDEPlatformSystemTrayIcon::updateIcon(const QIcon &icon)
+{
+    if (!m_sni) {
+        return;
+    }
+    if (icon.name().isEmpty()) {
+        m_sni->setIconByPixmap(icon);
+        m_sni->setToolTipIconByPixmap(icon);
+    } else {
+        m_sni->setIconByName(icon.name());
+        m_sni->setToolTipIconByName(icon.name());
+    }
+}
+
+void KDEPlatformSystemTrayIcon::updateToolTip(const QString &tooltip)
+{
+    if (!m_sni) {
+        return;
+    }
+    m_sni->setToolTipTitle(tooltip);
+}
+
+void KDEPlatformSystemTrayIcon::updateMenu(QPlatformMenu *menu)
+{
+    if (!m_sni) {
+        return;
+    }
+    if (SystemTrayMenu *ourMenu = qobject_cast<SystemTrayMenu*>(menu)) {
+        m_sni->setContextMenu(ourMenu->menu());
+    }
+}
+
+QPlatformMenu *KDEPlatformSystemTrayIcon::createMenu() const
+{
+    return new SystemTrayMenu();
+}
+
+QRect KDEPlatformSystemTrayIcon::geometry() const
+{
+    // StatusNotifierItem doesn't provide the geometry
+    return QRect();
+}
+
+void KDEPlatformSystemTrayIcon::showMessage(const QString &title, const QString &msg,
+                                            const QIcon &icon, MessageIcon iconType, int secs)
+{
+    Q_UNUSED(iconType)
+    if (!m_sni) {
+        return;
+    }
+    m_sni->showMessage(title, msg, icon.name(), secs);
+}
+
+bool KDEPlatformSystemTrayIcon::isSystemTrayAvailable() const
+{
+    QDBusInterface systrayHost(QStringLiteral("org.kde.StatusNotifierWatcher"), QStringLiteral("/StatusNotifierWatcher"), QStringLiteral("org.kde.StatusNotifierWatcher"));
+    if (systrayHost.isValid()) {
+        return systrayHost.property("IsStatusNotifierHostRegistered").toBool();
+    }
+
+    return false;
+}
+
+bool KDEPlatformSystemTrayIcon::supportsMessages() const
+{
+    return true;
+}
diff --git src/platformtheme/kdeplatformsystemtrayicon.h src/platformtheme/kdeplatformsystemtrayicon.h
new file mode 100644
index 0000000..533e2da
--- /dev/null
+++ src/platformtheme/kdeplatformsystemtrayicon.h
@@ -0,0 +1,111 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2014 Martin Gr��lin <mgraesslin@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+#ifndef KDEPLATFORMSYSTEMTRAYICON_H
+#define KDEPLATFORMSYSTEMTRAYICON_H
+
+#include <qpa/qplatformmenu.h>
+#include <qpa/qplatformsystemtrayicon.h>
+
+class KStatusNotifierItem;
+class SystemTrayMenuItem;
+class QAction;
+class QMenu;
+
+class SystemTrayMenu : public QPlatformMenu
+{
+    Q_OBJECT
+public:
+    SystemTrayMenu();
+    ~SystemTrayMenu() Q_DECL_OVERRIDE;
+    void insertMenuItem(QPlatformMenuItem *menuItem, QPlatformMenuItem *before) Q_DECL_OVERRIDE;
+    QPlatformMenuItem *menuItemAt(int position) const Q_DECL_OVERRIDE;
+    QPlatformMenuItem *menuItemForTag(quintptr tag) const Q_DECL_OVERRIDE;
+    void removeMenuItem(QPlatformMenuItem *menuItem) Q_DECL_OVERRIDE;
+    void setEnabled(bool enabled) Q_DECL_OVERRIDE;
+    void setIcon(const QIcon &icon) Q_DECL_OVERRIDE;
+    void setTag(quintptr tag) Q_DECL_OVERRIDE;
+    void setText(const QString &text) Q_DECL_OVERRIDE;
+    void setVisible(bool visible) Q_DECL_OVERRIDE;
+    void syncMenuItem(QPlatformMenuItem *menuItem) Q_DECL_OVERRIDE;
+    void syncSeparatorsCollapsible(bool enable) Q_DECL_OVERRIDE;
+    quintptr tag() const Q_DECL_OVERRIDE;
+    QPlatformMenuItem *createMenuItem() const Q_DECL_OVERRIDE;
+
+    QMenu *menu() const;
+
+private:
+    quintptr m_tag;
+    QPointer<QMenu> m_menu;
+    QList<SystemTrayMenuItem*> m_items;
+};
+
+class SystemTrayMenuItem : public QPlatformMenuItem
+{
+    Q_OBJECT
+public:
+    SystemTrayMenuItem();
+    ~SystemTrayMenuItem() Q_DECL_OVERRIDE;
+    void setCheckable(bool checkable) Q_DECL_OVERRIDE;
+    void setChecked(bool isChecked) Q_DECL_OVERRIDE;
+    void setEnabled(bool enabled) Q_DECL_OVERRIDE;
+    void setFont(const QFont &font) Q_DECL_OVERRIDE;
+    void setIcon(const QIcon &icon) Q_DECL_OVERRIDE;
+    void setIsSeparator(bool isSeparator) Q_DECL_OVERRIDE;
+    void setMenu(QPlatformMenu *menu) Q_DECL_OVERRIDE;
+    void setRole(MenuRole role) Q_DECL_OVERRIDE;
+    void setShortcut(const QKeySequence &shortcut) Q_DECL_OVERRIDE;
+    void setTag(quintptr tag) Q_DECL_OVERRIDE;
+    void setText(const QString &text) Q_DECL_OVERRIDE;
+    void setVisible(bool isVisible) Q_DECL_OVERRIDE;
+    quintptr tag() const Q_DECL_OVERRIDE;
+    void setIconSize(int size) Q_DECL_OVERRIDE;
+
+    QAction *action() const;
+
+private:
+    quintptr m_tag;
+    QAction *m_action;
+};
+
+class KDEPlatformSystemTrayIcon : public QPlatformSystemTrayIcon
+{
+public:
+    KDEPlatformSystemTrayIcon();
+    ~KDEPlatformSystemTrayIcon() Q_DECL_OVERRIDE;
+
+    void init() Q_DECL_OVERRIDE;
+    void cleanup() Q_DECL_OVERRIDE;
+    void updateIcon(const QIcon &icon) Q_DECL_OVERRIDE;
+    void updateToolTip(const QString &tooltip) Q_DECL_OVERRIDE;
+    void updateMenu(QPlatformMenu *menu) Q_DECL_OVERRIDE;
+    QRect geometry() const Q_DECL_OVERRIDE;
+    void showMessage(const QString &title, const QString &msg,
+                     const QIcon &icon, MessageIcon iconType, int secs) Q_DECL_OVERRIDE;
+
+    bool isSystemTrayAvailable() const Q_DECL_OVERRIDE;
+    bool supportsMessages() const Q_DECL_OVERRIDE;
+
+    QPlatformMenu *createMenu() const Q_DECL_OVERRIDE;
+
+private:
+    KStatusNotifierItem *m_sni;
+};
+
+#endif
diff --git src/platformtheme/kdeplatformtheme.cpp src/platformtheme/kdeplatformtheme.cpp
new file mode 100644
index 0000000..38e0730
--- /dev/null
+++ src/platformtheme/kdeplatformtheme.cpp
@@ -0,0 +1,288 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Kevin Ottens <ervin+bluesystems@kde.org>
+ *  Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+ *  Copyright 2014 Luk�? Tinkl <ltinkl@redhat.com>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include "kdeplatformtheme.h"
+#include "kfontsettingsdata.h"
+#include "khintssettings.h"
+#include "kdeplatformfiledialoghelper.h"
+#include "kdeplatformsystemtrayicon.h"
+
+#include <QCoreApplication>
+#include <QFont>
+#include <QPalette>
+#include <QString>
+#include <QStringList>
+#include <QVariant>
+#include <QDebug>
+
+#include <kiconengine.h>
+#include <kiconloader.h>
+#include <kstandardshortcut.h>
+#include <KStandardGuiItem>
+#include <KLocalizedString>
+
+KdePlatformTheme::KdePlatformTheme()
+{
+    m_fontsData = Q_NULLPTR;
+    m_hints = Q_NULLPTR;
+    loadSettings();
+}
+
+KdePlatformTheme::~KdePlatformTheme()
+{
+    delete m_fontsData;
+    delete m_hints;
+}
+
+QVariant KdePlatformTheme::themeHint(QPlatformTheme::ThemeHint hintType) const
+{
+    QVariant hint = m_hints->hint(hintType);
+    if (hint.isValid()) {
+        return hint;
+    } else {
+        return QPlatformTheme::themeHint(hintType);
+    }
+}
+
+const QPalette *KdePlatformTheme::palette(Palette type) const
+{
+    QPalette *palette = m_hints->palette(type);
+    if (palette) {
+        return palette;
+    } else {
+        return QPlatformTheme::palette(type);
+    }
+}
+
+KFontSettingsData::FontTypes KdePlatformTheme::fontType(Font type) const
+{
+    KFontSettingsData::FontTypes fdtype;
+    switch (type) {
+    case SystemFont:
+        fdtype = KFontSettingsData::GeneralFont; break;
+    case MenuFont:
+    case MenuBarFont:
+    case MenuItemFont:
+        fdtype = KFontSettingsData::MenuFont; break;
+    case MessageBoxFont:
+    case LabelFont:
+    case TipLabelFont:
+    case StatusBarFont:
+    case PushButtonFont:
+    case ToolButtonFont:
+    case ItemViewFont:
+    case ListViewFont:
+    case HeaderViewFont:
+    case ListBoxFont:
+    case ComboMenuItemFont:
+    case ComboLineEditFont:
+        fdtype = KFontSettingsData::GeneralFont; break;
+    case TitleBarFont:
+    case MdiSubWindowTitleFont:
+    case DockWidgetTitleFont:
+        fdtype = KFontSettingsData::WindowTitleFont; break;
+    case SmallFont:
+    case MiniFont:
+        fdtype = KFontSettingsData::SmallestReadableFont; break;
+    case FixedFont:
+        fdtype = KFontSettingsData::FixedFont; break;
+    default:
+        fdtype = KFontSettingsData::GeneralFont; break;
+    }
+
+    return fdtype;
+}
+
+const QFont *KdePlatformTheme::font(Font type) const
+{
+    return m_fontsData->font(fontType(type));
+}
+
+QIconEngine *KdePlatformTheme::createIconEngine(const QString &iconName) const
+{
+    return new KIconEngine(iconName, KIconLoader::global());
+}
+
+void KdePlatformTheme::loadSettings()
+{
+    if (!m_fontsData) {
+        m_fontsData = new KFontSettingsData;
+        m_hints = new KHintsSettings;
+    }
+}
+
+QList<QKeySequence> KdePlatformTheme::keyBindings(QKeySequence::StandardKey key) const
+{
+    switch (key) {
+    case QKeySequence::HelpContents:
+        return KStandardShortcut::shortcut(KStandardShortcut::Help);
+    case QKeySequence::WhatsThis:
+        return KStandardShortcut::shortcut(KStandardShortcut::WhatsThis);
+    case QKeySequence::Open:
+        return KStandardShortcut::shortcut(KStandardShortcut::Open);
+    case QKeySequence::Close:
+        return KStandardShortcut::shortcut(KStandardShortcut::Close);
+    case QKeySequence::Save:
+        return KStandardShortcut::shortcut(KStandardShortcut::Save);
+    case QKeySequence::New:
+        return KStandardShortcut::shortcut(KStandardShortcut::New);
+    case QKeySequence::Cut:
+        return KStandardShortcut::shortcut(KStandardShortcut::Cut);
+    case QKeySequence::Copy:
+        return KStandardShortcut::shortcut(KStandardShortcut::Copy);
+    case QKeySequence::Paste:
+        return KStandardShortcut::shortcut(KStandardShortcut::Paste);
+    case QKeySequence::Undo:
+        return KStandardShortcut::shortcut(KStandardShortcut::Undo);
+    case QKeySequence::Redo:
+        return KStandardShortcut::shortcut(KStandardShortcut::Redo);
+    case QKeySequence::Back:
+        return KStandardShortcut::shortcut(KStandardShortcut::Back);
+    case QKeySequence::Forward:
+        return KStandardShortcut::shortcut(KStandardShortcut::Forward);
+    case QKeySequence::Refresh:
+        return KStandardShortcut::shortcut(KStandardShortcut::Reload);
+    case QKeySequence::ZoomIn:
+        return KStandardShortcut::shortcut(KStandardShortcut::ZoomIn);
+    case QKeySequence::ZoomOut:
+        return KStandardShortcut::shortcut(KStandardShortcut::ZoomOut);
+    case QKeySequence::Print:
+        return KStandardShortcut::shortcut(KStandardShortcut::Print);
+    case QKeySequence::Find:
+        return KStandardShortcut::shortcut(KStandardShortcut::Find);
+    case QKeySequence::FindNext:
+        return KStandardShortcut::shortcut(KStandardShortcut::FindNext);
+    case QKeySequence::FindPrevious:
+        return KStandardShortcut::shortcut(KStandardShortcut::FindPrev);
+    case QKeySequence::Replace:
+        return KStandardShortcut::shortcut(KStandardShortcut::Replace);
+    case QKeySequence::SelectAll:
+        return KStandardShortcut::shortcut(KStandardShortcut::SelectAll);
+    case QKeySequence::MoveToNextWord:
+        return KStandardShortcut::shortcut(KStandardShortcut::ForwardWord);
+    case QKeySequence::MoveToPreviousWord:
+        return KStandardShortcut::shortcut(KStandardShortcut::BackwardWord);
+    case QKeySequence::MoveToNextPage:
+        return KStandardShortcut::shortcut(KStandardShortcut::Next);
+    case QKeySequence::MoveToPreviousPage:
+        return KStandardShortcut::shortcut(KStandardShortcut::Prior);
+    case QKeySequence::MoveToStartOfLine:
+        return KStandardShortcut::shortcut(KStandardShortcut::BeginningOfLine);
+    case QKeySequence::MoveToEndOfLine:
+        return KStandardShortcut::shortcut(KStandardShortcut::EndOfLine);
+    case QKeySequence::MoveToStartOfDocument:
+        return KStandardShortcut::shortcut(KStandardShortcut::Begin);
+    case QKeySequence::MoveToEndOfDocument:
+        return KStandardShortcut::shortcut(KStandardShortcut::End);
+    case QKeySequence::SaveAs:
+        return KStandardShortcut::shortcut(KStandardShortcut::SaveAs);
+    case QKeySequence::Preferences:
+        return KStandardShortcut::shortcut(KStandardShortcut::Preferences);
+    case QKeySequence::Quit:
+        return KStandardShortcut::shortcut(KStandardShortcut::Quit);
+    case QKeySequence::FullScreen:
+        return KStandardShortcut::shortcut(KStandardShortcut::FullScreen);
+    case QKeySequence::Deselect:
+        return KStandardShortcut::shortcut(KStandardShortcut::Deselect);
+    case QKeySequence::DeleteStartOfWord:
+        return KStandardShortcut::shortcut(KStandardShortcut::DeleteWordBack);
+    case QKeySequence::DeleteEndOfWord:
+        return KStandardShortcut::shortcut(KStandardShortcut::DeleteWordForward);
+    case QKeySequence::NextChild:
+        return KStandardShortcut::shortcut(KStandardShortcut::TabNext);
+    case QKeySequence::PreviousChild:
+        return KStandardShortcut::shortcut(KStandardShortcut::TabPrev);
+    default:
+        return QPlatformTheme::keyBindings(key);
+    }
+}
+
+bool KdePlatformTheme::usePlatformNativeDialog(QPlatformTheme::DialogType type) const
+{
+    return type == QPlatformTheme::FileDialog;
+}
+
+QString KdePlatformTheme::standardButtonText(int button) const
+{
+    switch (static_cast<QPlatformDialogHelper::StandardButton>(button)) {
+    case QPlatformDialogHelper::NoButton:
+        qWarning() << Q_FUNC_INFO << "Unsupported standard button:" << button;
+        return QString();
+    case QPlatformDialogHelper::Ok:
+        return KStandardGuiItem::ok().text();
+    case QPlatformDialogHelper::Save:
+        return KStandardGuiItem::save().text();
+    case QPlatformDialogHelper::SaveAll:
+        return i18nc("@action:button", "Save All");
+    case QPlatformDialogHelper::Open:
+        return KStandardGuiItem::open().text();
+    case QPlatformDialogHelper::Yes:
+        return KStandardGuiItem::yes().text();
+    case QPlatformDialogHelper::YesToAll:
+        return i18nc("@action:button", "Yes to All");
+    case QPlatformDialogHelper::No:
+        return KStandardGuiItem::no().text();
+    case QPlatformDialogHelper::NoToAll:
+        return i18nc("@action:button", "No to All");
+    case QPlatformDialogHelper::Abort:
+        // FIXME KStandardGuiItem::stop() doesn't seem right here
+        return i18nc("@action:button", "Abort");
+    case QPlatformDialogHelper::Retry:
+        return i18nc("@action:button", "Retry");
+    case QPlatformDialogHelper::Ignore:
+        return i18nc("@action:button", "Ignore");
+    case QPlatformDialogHelper::Close:
+        return KStandardGuiItem::close().text();
+    case QPlatformDialogHelper::Cancel:
+        return KStandardGuiItem::cancel().text();
+    case QPlatformDialogHelper::Discard:
+        return KStandardGuiItem::discard().text();
+    case QPlatformDialogHelper::Help:
+        return KStandardGuiItem::help().text();
+    case QPlatformDialogHelper::Apply:
+        return KStandardGuiItem::apply().text();
+    case QPlatformDialogHelper::Reset:
+        return KStandardGuiItem::reset().text();
+    case QPlatformDialogHelper::RestoreDefaults:
+        return KStandardGuiItem::defaults().text();
+    default:
+        return QPlatformTheme::defaultStandardButtonText(button);
+    }
+}
+
+QPlatformDialogHelper *KdePlatformTheme::createPlatformDialogHelper(QPlatformTheme::DialogType type) const
+{
+    switch (type) {
+    case QPlatformTheme::FileDialog:
+        return new KDEPlatformFileDialogHelper;
+    case QPlatformTheme::FontDialog:
+    case QPlatformTheme::ColorDialog:
+    case QPlatformTheme::MessageDialog:
+    default:
+        return 0;
+    }
+}
+
+QPlatformSystemTrayIcon *KdePlatformTheme::createPlatformSystemTrayIcon() const
+{
+    return new KDEPlatformSystemTrayIcon;
+}
diff --git src/platformtheme/kdeplatformtheme.h src/platformtheme/kdeplatformtheme.h
new file mode 100644
index 0000000..19fe815
--- /dev/null
+++ src/platformtheme/kdeplatformtheme.h
@@ -0,0 +1,62 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Kevin Ottens <ervin+bluesystems@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KDEPLATFORMTHEME_H
+#define KDEPLATFORMTHEME_H
+
+#include <qpa/qplatformtheme.h>
+#include "kfontsettingsdata.h"
+
+#include <QHash>
+#include <QObject>
+#include <QKeySequence>
+
+class KHintsSettings;
+class QIconEngine;
+
+class KdePlatformTheme : public QPlatformTheme
+{
+public:
+    KdePlatformTheme();
+    ~KdePlatformTheme();
+
+    QVariant themeHint(ThemeHint hint) const Q_DECL_OVERRIDE;
+    const QPalette *palette(Palette type = SystemPalette) const Q_DECL_OVERRIDE;
+    const QFont *font(Font type) const Q_DECL_OVERRIDE;
+    QIconEngine *createIconEngine(const QString &iconName) const Q_DECL_OVERRIDE;
+    QList<QKeySequence> keyBindings(QKeySequence::StandardKey key) const Q_DECL_OVERRIDE;
+
+    QPlatformDialogHelper *createPlatformDialogHelper(DialogType type) const Q_DECL_OVERRIDE;
+    bool usePlatformNativeDialog(DialogType type) const Q_DECL_OVERRIDE;
+
+    QString standardButtonText(int button) const Q_DECL_OVERRIDE;
+
+    QPlatformSystemTrayIcon *createPlatformSystemTrayIcon() const Q_DECL_OVERRIDE;
+
+protected:
+    void loadSettings();
+    KFontSettingsData::FontTypes fontType(Font type) const;
+
+private:
+    KHintsSettings *m_hints;
+    KFontSettingsData *m_fontsData;
+};
+
+#endif // KDEPLATFORMTHEME_H
diff --git src/platformtheme/kdeplatformtheme.json src/platformtheme/kdeplatformtheme.json
new file mode 100644
index 0000000..5d250cc
--- /dev/null
+++ src/platformtheme/kdeplatformtheme.json
@@ -0,0 +1,3 @@
+{
+    "Keys": [ "kde" ]
+}
diff --git src/platformtheme/kdirselectdialog.cpp src/platformtheme/kdirselectdialog.cpp
new file mode 100644
index 0000000..ffacd9e
--- /dev/null
+++ src/platformtheme/kdirselectdialog.cpp
@@ -0,0 +1,578 @@
+/*
+    Copyright (C) 2001,2002 Carsten Pfeiffer <pfeiffer@kde.org>
+    Copyright (C) 2001 Michael Jarrett <michaelj@corel.com>
+    Copyright (C) 2009 Shaun Reich <shaun.reich@kdemail.net>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License version 2 as published by the Free Software Foundation.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "kdirselectdialog_p.h"
+
+#include <QDebug>
+#include <QDialogButtonBox>
+#include <QDir>
+#include <QFileDialog>
+#include <QInputDialog>
+#include <QLayout>
+#include <QMenu>
+#include <QPushButton>
+#include <QStandardPaths>
+#include <QStringList>
+#include <QUrl>
+
+#include <kio/jobuidelegate.h>
+#include <kactioncollection.h>
+#include <kauthorized.h>
+#include <kconfig.h>
+#include <kconfiggroup.h>
+#include <kfileitemdelegate.h>
+#include <khistorycombobox.h>
+#include <kio/job.h>
+#include <kio/deletejob.h>
+#include <kio/copyjob.h>
+#include <kio/mkdirjob.h>
+#include <kjobwidgets.h>
+#include <klocalizedstring.h>
+#include <kmessagebox.h>
+#include <kpropertiesdialog.h>
+#include <krecentdirs.h>
+#include <kservice.h>
+#include <ksharedconfig.h>
+#include <ktoggleaction.h>
+#include <kurlcompletion.h>
+#include <kurlpixmapprovider.h>
+#include <kfilewidget.h>
+
+#include "kfiletreeview_p.h"
+#include <kfileplacesview.h>
+#include <kfileplacesmodel.h>
+// ### add mutator for treeview!
+
+class KDirSelectDialog::Private
+{
+public:
+    Private(bool localOnly, KDirSelectDialog *parent)
+        : m_parent(parent),
+          m_localOnly(localOnly),
+          m_comboLocked(false),
+          m_urlCombo(0)
+    {
+    }
+
+    void readConfig(const KSharedConfigPtr &config, const QString &group);
+    void saveConfig(KSharedConfigPtr config, const QString &group);
+    void slotMkdir();
+
+    void slotCurrentChanged();
+    void slotExpand(const QModelIndex &);
+    void slotUrlActivated(const QString &);
+    void slotComboTextChanged(const QString &);
+    void slotContextMenuRequested(const QPoint &);
+    void slotNewFolder();
+    void slotMoveToTrash();
+    void slotDelete();
+    void slotProperties();
+
+    KDirSelectDialog *m_parent;
+    bool m_localOnly : 1;
+    bool m_comboLocked : 1;
+    QUrl m_rootUrl;
+    QUrl m_startDir;
+    KFileTreeView *m_treeView;
+    QMenu *m_contextMenu;
+    KActionCollection *m_actions;
+    KFilePlacesView *m_placesView;
+    KHistoryComboBox *m_urlCombo;
+    QString m_recentDirClass;
+    QUrl m_startURL;
+    QAction *moveToTrash;
+    QAction *deleteAction;
+    QAction *showHiddenFoldersAction;
+};
+
+void KDirSelectDialog::Private::readConfig(const KSharedConfig::Ptr &config, const QString &group)
+{
+    m_urlCombo->clear();
+
+    KConfigGroup conf(config, group);
+    m_urlCombo->setHistoryItems(conf.readPathEntry("History Items", QStringList()));
+
+    const QSize size = conf.readEntry("DirSelectDialog Size", QSize());
+    if (size.isValid()) {
+        m_parent->resize(size);
+    }
+}
+
+void KDirSelectDialog::Private::saveConfig(KSharedConfig::Ptr config, const QString &group)
+{
+    KConfigGroup conf(config, group);
+    KConfigGroup::WriteConfigFlags flags(KConfigGroup::Persistent | KConfigGroup::Global);
+    conf.writePathEntry("History Items", m_urlCombo->historyItems(), flags);
+    conf.writeEntry("DirSelectDialog Size", m_parent->size(), flags);
+
+    config->sync();
+}
+
+void KDirSelectDialog::Private::slotMkdir()
+{
+    bool ok;
+    QString where = m_parent->url().toDisplayString(QUrl::PreferLocalFile);
+    QString name = i18nc("folder name", "New Folder");
+    if (m_parent->url().isLocalFile() && QFileInfo::exists(m_parent->url().toLocalFile() + QLatin1Char('/') + name)) {
+        name = KIO::suggestName(m_parent->url(), name);
+    }
+
+    QString directory = KIO::encodeFileName(QInputDialog::getText(m_parent, i18nc("@title:window", "New Folder"),
+                                            i18nc("@label:textbox", "Create new folder in:\n%1",  where),
+                                            QLineEdit::Normal, name, &ok));
+    if (!ok) {
+        return;
+    }
+
+    bool selectDirectory = true;
+    bool writeOk = false;
+    bool exists = false;
+    QUrl folderurl(m_parent->url());
+
+    const QStringList dirs = directory.split(QLatin1Char('/'), QString::SkipEmptyParts);
+    QStringList::ConstIterator it = dirs.begin();
+
+    for (; it != dirs.end(); ++it) {
+        folderurl.setPath(folderurl.path() + QLatin1Char('/') + *it);
+        KIO::StatJob *job = KIO::stat(folderurl);
+        KJobWidgets::setWindow(job, m_parent);
+        job->setDetails(0); //We only want to know if it exists, 0 == that.
+        job->setSide(KIO::StatJob::DestinationSide);
+        exists = job->exec();
+        if (!exists) {
+            KIO::MkdirJob *job = KIO::mkdir(folderurl);
+            KJobWidgets::setWindow(job, m_parent);
+            writeOk = job->exec();
+        }
+    }
+
+    if (exists) { // url was already existent
+        QString which = folderurl.toDisplayString(QUrl::PreferLocalFile);
+        KMessageBox::sorry(m_parent, i18n("A file or folder named %1 already exists.", which));
+        selectDirectory = false;
+    } else if (!writeOk) {
+        KMessageBox::sorry(m_parent, i18n("You do not have permission to create that folder."));
+    } else if (selectDirectory) {
+        m_parent->setCurrentUrl(folderurl);
+    }
+}
+
+void KDirSelectDialog::Private::slotCurrentChanged()
+{
+    if (m_comboLocked) {
+        return;
+    }
+
+    const QUrl u = m_treeView->currentUrl();
+
+    if (u.isValid()) {
+        m_urlCombo->setEditText(u.toDisplayString(QUrl::PreferLocalFile));
+    } else {
+        m_urlCombo->setEditText(QString());
+    }
+}
+
+void KDirSelectDialog::Private::slotUrlActivated(const QString &text)
+{
+    if (text.isEmpty()) {
+        return;
+    }
+
+    const QUrl url = QUrl::fromUserInput(text);
+    m_urlCombo->addToHistory(url.toDisplayString());
+
+    if (m_parent->localOnly() && !url.isLocalFile()) {
+        return;    //FIXME: messagebox for the user
+    }
+
+    QUrl oldUrl = m_treeView->currentUrl();
+    if (oldUrl.isEmpty()) {
+        oldUrl = m_startDir;
+    }
+
+    m_parent->setCurrentUrl(oldUrl);
+}
+
+void KDirSelectDialog::Private::slotComboTextChanged(const QString &text)
+{
+    m_treeView->blockSignals(true);
+    QUrl url = QUrl::fromUserInput(text);
+#ifdef Q_OS_WIN
+    QUrl rootUrl(m_treeView->rootUrl());
+    if (url.isLocalFile() && !rootUrl.isParentOf(url) && !rootUrl.matches(url, QUrl::StripTrailingSlash)) {
+        QUrl tmp = KIO::upUrl(url);
+        while (tmp.path().length() > 1) {
+            url = tmp;
+            tmp = KIO::upUrl(url);
+        }
+        m_treeView->setRootUrl(url);
+    }
+#endif
+    m_treeView->setCurrentUrl(url);
+    m_treeView->blockSignals(false);
+}
+
+void KDirSelectDialog::Private::slotContextMenuRequested(const QPoint &pos)
+{
+    m_contextMenu->popup(m_treeView->viewport()->mapToGlobal(pos));
+}
+
+void KDirSelectDialog::Private::slotExpand(const QModelIndex &index)
+{
+    m_treeView->setExpanded(index, !m_treeView->isExpanded(index));
+}
+
+void KDirSelectDialog::Private::slotNewFolder()
+{
+    slotMkdir();
+}
+
+void KDirSelectDialog::Private::slotMoveToTrash()
+{
+    const QUrl url = m_treeView->selectedUrl();
+    KIO::JobUiDelegate job;
+    if (job.askDeleteConfirmation(QList<QUrl>() << url, KIO::JobUiDelegate::Trash, KIO::JobUiDelegate::DefaultConfirmation)) {
+        KIO::CopyJob *copyJob = KIO::trash(url);
+        KJobWidgets::setWindow(copyJob, m_parent);
+        copyJob->ui()->setAutoErrorHandlingEnabled(true);
+    }
+}
+
+void KDirSelectDialog::Private::slotDelete()
+{
+    const QUrl url = m_treeView->selectedUrl();
+    KIO::JobUiDelegate job;
+    if (job.askDeleteConfirmation(QList<QUrl>() << url, KIO::JobUiDelegate::Delete, KIO::JobUiDelegate::DefaultConfirmation)) {
+        KIO::DeleteJob *deleteJob = KIO::del(url);
+        KJobWidgets::setWindow(deleteJob, m_parent);
+        deleteJob->ui()->setAutoErrorHandlingEnabled(true);
+    }
+}
+
+void KDirSelectDialog::Private::slotProperties()
+{
+    KPropertiesDialog *dialog = 0;
+    dialog = new KPropertiesDialog(m_treeView->selectedUrl(), this->m_parent);
+    dialog->setAttribute(Qt::WA_DeleteOnClose);
+    dialog->show();
+}
+
+KDirSelectDialog::KDirSelectDialog(const QUrl &startDir, bool localOnly, QWidget *parent)
+// #ifdef Q_OS_WIN
+//     : QDialog(parent, Qt::WindowMinMaxButtonsHint),
+// #else
+//     : QDialog(parent),
+// #endif
+     : d(new Private(localOnly, this))
+{
+    setWindowTitle(i18nc("@title:window", "Select Folder"));
+
+    QVBoxLayout *topLayout = new QVBoxLayout;
+    setLayout(topLayout);
+
+    QFrame *page = new QFrame(this);
+    topLayout->addWidget(page);
+
+    QPushButton *folderButton = new QPushButton;
+    KGuiItem::assign(folderButton, KGuiItem(i18nc("@action:button", "New Folder..."), QStringLiteral("folder-new")));
+    connect(folderButton, SIGNAL(clicked()), this, SLOT(slotNewFolder()));
+
+    m_buttons = new QDialogButtonBox(this);
+    m_buttons->addButton(folderButton, QDialogButtonBox::ActionRole);
+    m_buttons->setStandardButtons(QDialogButtonBox::Ok | QDialogButtonBox::Cancel);
+    connect(m_buttons, SIGNAL(accepted()), this, SLOT(accept()));
+    connect(m_buttons, SIGNAL(rejected()), this, SLOT(reject()));
+    topLayout->addWidget(m_buttons);
+
+    QHBoxLayout *hlay = new QHBoxLayout(page);
+    hlay->setMargin(0);
+    QVBoxLayout *mainLayout = new QVBoxLayout();
+    d->m_actions = new KActionCollection(this);
+    d->m_actions->addAssociatedWidget(this);
+    d->m_placesView = new KFilePlacesView(page);
+    d->m_placesView->setModel(new KFilePlacesModel(d->m_placesView));
+    d->m_placesView->setObjectName(QStringLiteral("speedbar"));
+    d->m_placesView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+    d->m_placesView->setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Minimum);
+    connect(d->m_placesView, SIGNAL(urlChanged(QUrl)),
+            SLOT(setCurrentUrl(QUrl)));
+    hlay->addWidget(d->m_placesView);
+    hlay->addLayout(mainLayout);
+
+    d->m_treeView = new KFileTreeView(page);
+    d->m_treeView->setDirOnlyMode(true);
+    d->m_treeView->setContextMenuPolicy(Qt::CustomContextMenu);
+
+    for (int i = 1; i < d->m_treeView->model()->columnCount(); ++i) {
+        d->m_treeView->hideColumn(i);
+    }
+
+    d->m_urlCombo = new KHistoryComboBox(page);
+    d->m_urlCombo->setLayoutDirection(Qt::LeftToRight);
+    d->m_urlCombo->setSizeAdjustPolicy(QComboBox::AdjustToMinimumContentsLength);
+    d->m_urlCombo->setTrapReturnKey(true);
+    d->m_urlCombo->setPixmapProvider(new KUrlPixmapProvider());
+    KUrlCompletion *comp = new KUrlCompletion();
+    comp->setMode(KUrlCompletion::DirCompletion);
+    d->m_urlCombo->setCompletionObject(comp, true);
+    d->m_urlCombo->setAutoDeleteCompletionObject(true);
+    d->m_urlCombo->setDuplicatesEnabled(false);
+
+    d->m_contextMenu = new QMenu(this);
+
+    QAction *newFolder = new QAction(i18nc("@action:inmenu", "New Folder..."), this);
+    d->m_actions->addAction(newFolder->objectName(), newFolder);
+    newFolder->setIcon(QIcon::fromTheme(QStringLiteral("folder-new")));
+    newFolder->setShortcut(Qt::Key_F10);
+    connect(newFolder, SIGNAL(triggered(bool)), this, SLOT(slotNewFolder()));
+    d->m_contextMenu->addAction(newFolder);
+
+    d->moveToTrash = new QAction(i18nc("@action:inmenu", "Move to Trash"), this);
+    d->m_actions->addAction(d->moveToTrash->objectName(), d->moveToTrash);
+    d->moveToTrash->setIcon(QIcon::fromTheme(QStringLiteral("user-trash")));
+    d->moveToTrash->setShortcut(Qt::Key_Delete);
+    connect(d->moveToTrash, SIGNAL(triggered(bool)), this, SLOT(slotMoveToTrash()));
+    d->m_contextMenu->addAction(d->moveToTrash);
+
+    d->deleteAction = new QAction(i18nc("@action:inmenu", "Delete"), this);
+    d->m_actions->addAction(d->deleteAction->objectName(), d->deleteAction);
+    d->deleteAction->setIcon(QIcon::fromTheme(QStringLiteral("edit-delete")));
+    d->deleteAction->setShortcut(Qt::SHIFT + Qt::Key_Delete);
+    connect(d->deleteAction, SIGNAL(triggered(bool)), this, SLOT(slotDelete()));
+    d->m_contextMenu->addAction(d->deleteAction);
+
+    d->m_contextMenu->addSeparator();
+
+    d->showHiddenFoldersAction = new KToggleAction(i18nc("@option:check", "Show Hidden Folders"), this);
+    d->m_actions->addAction(d->showHiddenFoldersAction->objectName(), d->showHiddenFoldersAction);
+    d->showHiddenFoldersAction->setShortcut(Qt::Key_F8);
+    connect(d->showHiddenFoldersAction, SIGNAL(triggered(bool)), d->m_treeView, SLOT(setShowHiddenFiles(bool)));
+    d->m_contextMenu->addAction(d->showHiddenFoldersAction);
+    d->m_contextMenu->addSeparator();
+
+    QAction *propertiesAction = new QAction(i18nc("@action:inmenu", "Properties"), this);
+    d->m_actions->addAction(propertiesAction->objectName(), propertiesAction);
+    propertiesAction->setIcon(QIcon::fromTheme(QStringLiteral("document-properties")));
+    propertiesAction->setShortcut(Qt::ALT + Qt::Key_Return);
+    connect(propertiesAction, SIGNAL(triggered(bool)), this, SLOT(slotProperties()));
+    d->m_contextMenu->addAction(propertiesAction);
+
+    d->m_startURL = KFileWidget::getStartUrl(startDir, d->m_recentDirClass);
+    if (localOnly && !d->m_startURL.isLocalFile()) {
+        QString docPath = QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation);
+        if (QDir(docPath).exists()) {
+            d->m_startURL = QUrl::fromLocalFile(docPath);
+        } else {
+            d->m_startURL = QUrl::fromLocalFile(QDir::homePath());
+        }
+    }
+
+    d->m_startDir = d->m_startURL;
+    d->m_rootUrl = d->m_treeView->rootUrl();
+
+    d->readConfig(KSharedConfig::openConfig(), QStringLiteral("DirSelect Dialog"));
+
+    mainLayout->addWidget(d->m_treeView, 1);
+    mainLayout->addWidget(d->m_urlCombo, 0);
+
+    connect(d->m_treeView, SIGNAL(currentChanged(QUrl)),
+            SLOT(slotCurrentChanged()));
+    connect(d->m_treeView, SIGNAL(activated(QModelIndex)),
+            SLOT(slotExpand(QModelIndex)));
+    connect(d->m_treeView, SIGNAL(customContextMenuRequested(QPoint)),
+            SLOT(slotContextMenuRequested(QPoint)));
+
+    connect(d->m_urlCombo, SIGNAL(editTextChanged(QString)),
+            SLOT(slotComboTextChanged(QString)));
+    connect(d->m_urlCombo, SIGNAL(activated(QString)),
+            SLOT(slotUrlActivated(QString)));
+    connect(d->m_urlCombo, SIGNAL(returnPressed(QString)),
+            SLOT(slotUrlActivated(QString)));
+
+    setCurrentUrl(d->m_startURL);
+}
+
+KDirSelectDialog::~KDirSelectDialog()
+{
+    delete d;
+}
+
+QUrl KDirSelectDialog::url() const
+{
+    QUrl comboUrl = QUrl::fromUserInput(d->m_urlCombo->currentText());
+
+    if (comboUrl.isValid()) {
+        KIO::StatJob *statJob = KIO::stat(comboUrl, KIO::HideProgressInfo);
+        KJobWidgets::setWindow(statJob, d->m_parent);
+        const bool ok = statJob->exec();
+        if (ok && statJob->statResult().isDir()) {
+            return comboUrl;
+        }
+    }
+
+    // qDebug() << comboUrl.path() << " is not an accessible directory";
+    return d->m_treeView->currentUrl();
+}
+
+QUrl KDirSelectDialog::rootUrl() const
+{
+    return d->m_rootUrl;
+}
+
+QAbstractItemView *KDirSelectDialog::view() const
+{
+    return d->m_treeView;
+}
+
+bool KDirSelectDialog::localOnly() const
+{
+    return d->m_localOnly;
+}
+
+QUrl KDirSelectDialog::startDir() const
+{
+    return d->m_startDir;
+}
+
+void KDirSelectDialog::setCurrentUrl(const QUrl &url)
+{
+    if (!url.isValid()) {
+        return;
+    }
+
+    if (url.scheme() != d->m_rootUrl.scheme()) {
+        QUrl u(url);
+        //We need the url to end with / because some code ahead (kdirmodel) is expecting
+        //to find the / separator. It can happen that a valid url like smb: does not have
+        //one so we should add it.
+        if (!u.toString().endsWith(QLatin1Char('/'))) {
+            u.setPath(QStringLiteral("/"));
+        }
+
+        d->m_treeView->setRootUrl(u);
+        d->m_rootUrl = u;
+    }
+
+    //Check if url represents a hidden folder and enable showing them
+    QString fileName = url.fileName();
+    //TODO a better hidden file check?
+    bool isHidden = fileName.length() > 1 && fileName[0] == QLatin1Char('.') &&
+                    (fileName.length() > 2 ? fileName[1] != QLatin1Char('.') : true);
+    bool showHiddenFiles = isHidden && !d->m_treeView->showHiddenFiles();
+    if (showHiddenFiles) {
+        d->showHiddenFoldersAction->setChecked(true);
+        d->m_treeView->setShowHiddenFiles(true);
+    }
+
+    d->m_treeView->setCurrentUrl(url);
+}
+
+void KDirSelectDialog::accept()
+{
+    QUrl selectedUrl = url();
+    if (!selectedUrl.isValid()) {
+        return;
+    }
+
+    if (!d->m_recentDirClass.isEmpty()) {
+        KRecentDirs::add(d->m_recentDirClass, selectedUrl.toString());
+    }
+
+    d->m_urlCombo->addToHistory(selectedUrl.toDisplayString());
+    KFileWidget::setStartDir(url());
+
+    QDialog::accept();
+}
+
+void KDirSelectDialog::hideEvent(QHideEvent *event)
+{
+    d->saveConfig(KSharedConfig::openConfig(), QStringLiteral("DirSelect Dialog"));
+
+    QDialog::hideEvent(event);
+}
+
+// static
+QUrl KDirSelectDialog::selectDirectory(const QUrl &startDir,
+                                       bool localOnly,
+                                       QWidget *parent,
+                                       const QString &caption)
+{
+    KDirSelectDialog myDialog(startDir, localOnly, parent);
+
+    if (!caption.isNull()) {
+        myDialog.setWindowTitle(caption);
+    }
+
+    if (myDialog.exec() == QDialog::Accepted) {
+        QUrl url = myDialog.url();
+
+        //Returning the most local url
+        if (url.isLocalFile()) {
+            return url;
+        }
+
+        KIO::StatJob *job = KIO::stat(url);
+        KJobWidgets::setWindow(job, parent);
+
+        if (!job->exec()) {
+            return url;
+        }
+
+        KIO::UDSEntry entry = job->statResult();
+        const QString path = entry.stringValue(KIO::UDSEntry::UDS_LOCAL_PATH);
+
+        return path.isEmpty() ? url : QUrl::fromLocalFile(path);
+    } else {
+        return QUrl();
+    }
+}
+
+QUrl KDirSelectDialog::directory()
+{
+    return url();
+}
+
+QList<QUrl> KDirSelectDialog::selectedFiles()
+{
+    return QList<QUrl>() << url();
+}
+
+void KDirSelectDialog::setDirectory(const QUrl &directory)
+{
+    setCurrentUrl(directory);
+}
+
+QString KDirSelectDialog::selectedNameFilter()
+{
+    return QString();
+}
+
+void KDirSelectDialog::selectFile(const QUrl &filename)
+{
+    Q_UNUSED(filename)
+}
+
+void KDirSelectDialog::selectNameFilter(const QString &filter)
+{
+    Q_UNUSED(filter)
+}
+
+
+#include "moc_kdirselectdialog_p.cpp"
diff --git src/platformtheme/kdirselectdialog_p.h src/platformtheme/kdirselectdialog_p.h
new file mode 100644
index 0000000..06be37f
--- /dev/null
+++ src/platformtheme/kdirselectdialog_p.h
@@ -0,0 +1,136 @@
+/*
+  Copyright (C) 2001 Michael Jarrett <michaelj@corel.com>
+  Copyright (C) 2001 Carsten Pfeiffer <pfeiffer@kde.org>
+  Copyright (C) 2009 Shaun Reich <shaun.reich@kdemail.net>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Library General Public
+  License version 2 as published by the Free Software Foundation.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Library General Public License for more details.
+
+  You should have received a copy of the GNU Library General Public License
+  along with this library; see the file COPYING.LIB.  If not, write to
+  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+  Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KDIRSELECTDIALOG_H
+#define KDIRSELECTDIALOG_H
+
+#include "kdeplatformfiledialogbase_p.h"
+#include <QUrl>
+
+class QAbstractItemView;
+
+/**
+ * A pretty dialog for a KDirSelect control for selecting directories.
+ * @author Michael Jarrett <michaelj@corel.com>
+ * @deprecated since 5.0, use QFileDialog::getExistingDirectoryUrl instead.
+ */
+class KDirSelectDialog : public KDEPlatformFileDialogBase
+{
+    Q_OBJECT
+
+public:
+    /**
+     * Creates a new directory selection dialog.
+     * @internal use the static selectDirectory function
+     * @param startDir the directory, initially shown
+     * @param localOnly unused. You can only select paths below the startDir
+     * @param parent the parent for the dialog, usually 0L
+     */
+    explicit KDirSelectDialog(const QUrl &startDir = QUrl(),
+                              bool localOnly = false,
+                              QWidget *parent = 0L);
+
+    /**
+     * Destroys the directory selection dialog.
+     */
+    ~KDirSelectDialog();
+
+    /**
+     * Returns the currently selected URL, or an empty one if no item is selected.
+     *
+     * If the URL entered in the combobox is valid and exists, it is returned.
+     * Otherwise, the URL selected in the treeview is returned instead.
+     */
+    QUrl url() const;
+
+    /**
+     * Returns the root url
+     */
+    QUrl rootUrl() const;
+
+    /**
+     * Returns a pointer to the view which is used for displaying the directories.
+     */
+    QAbstractItemView *view() const;
+
+    /**
+     * Returns whether only local directories can be selected.
+     */
+    bool localOnly() const;
+
+    /**
+     * Creates a KDirSelectDialog, and returns the result.
+     * @param startDir the directory, initially shown
+     * The tree will display this directory and subdirectories of it.
+     * @param localOnly unused. You can only select paths below the startDir
+     * @param parent the parent widget to use for the dialog, or NULL to create a parent-less dialog
+     * @param caption the caption to use for the dialog, or QString() for the default caption
+     * @return The URL selected, or an empty URL if the user canceled
+     * or no URL was selected.
+     *
+     * @deprecated since 5.0, use QFileDialog::getExistingDirectory (if localOnly was true)
+     * or QFileDialog::getExistingDirectoryUrl (if localOnly was false) instead.
+     */
+    static QUrl selectDirectory(const QUrl &startDir = QUrl(),
+            bool localOnly = false, QWidget *parent = 0L,
+            const QString &caption = QString());
+
+    /**
+     * @return The path for the root node
+     */
+    QUrl startDir() const;
+
+    QUrl directory() Q_DECL_OVERRIDE;
+    void selectNameFilter(const QString &filter) Q_DECL_OVERRIDE;
+    void setDirectory(const QUrl &directory) Q_DECL_OVERRIDE;
+    void selectFile(const QUrl &filename) Q_DECL_OVERRIDE;
+    QString selectedNameFilter() Q_DECL_OVERRIDE;
+    QList<QUrl> selectedFiles() Q_DECL_OVERRIDE;
+
+public Q_SLOTS:
+    /**
+     * Sets the current @p url in the dialog.
+     */
+    void setCurrentUrl(const QUrl &url);
+
+protected:
+    void accept() Q_DECL_OVERRIDE;
+
+    /**
+     * Reimplemented for saving the dialog geometry.
+     */
+    void hideEvent(QHideEvent *event) Q_DECL_OVERRIDE;
+
+private:
+    class Private;
+    Private *const d;
+
+    Q_PRIVATE_SLOT(d, void slotCurrentChanged())
+    Q_PRIVATE_SLOT(d, void slotExpand(const QModelIndex &))
+    Q_PRIVATE_SLOT(d, void slotUrlActivated(const QString &))
+    Q_PRIVATE_SLOT(d, void slotComboTextChanged(const QString &))
+    Q_PRIVATE_SLOT(d, void slotContextMenuRequested(const QPoint &))
+    Q_PRIVATE_SLOT(d, void slotNewFolder())
+    Q_PRIVATE_SLOT(d, void slotMoveToTrash())
+    Q_PRIVATE_SLOT(d, void slotDelete())
+    Q_PRIVATE_SLOT(d, void slotProperties())
+};
+
+#endif
diff --git src/platformtheme/kfiletreeview.cpp src/platformtheme/kfiletreeview.cpp
new file mode 100644
index 0000000..77b128d
--- /dev/null
+++ src/platformtheme/kfiletreeview.cpp
@@ -0,0 +1,212 @@
+/*
+   This file is part of the KDE project
+
+   Copyright (C) 2007 Tobias Koenig <tokoe@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "kfiletreeview_p.h"
+
+#include <QDir>
+#include <QContextMenuEvent>
+#include <QMenu>
+#include <QUrl>
+
+#include <kdirlister.h>
+#include <kdirmodel.h>
+#include <kdirsortfilterproxymodel.h>
+#include <kfileitemdelegate.h>
+#include <klocalizedstring.h>
+#include <ktoggleaction.h>
+
+class KFileTreeView::Private
+{
+public:
+    Private(KFileTreeView *parent)
+        : q(parent)
+    {
+    }
+
+    QUrl urlForProxyIndex(const QModelIndex &index) const;
+
+    void _k_activated(const QModelIndex &);
+    void _k_currentChanged(const QModelIndex &, const QModelIndex &);
+    void _k_expanded(const QModelIndex &);
+
+    KFileTreeView *q;
+    KDirModel *mSourceModel;
+    KDirSortFilterProxyModel *mProxyModel;
+};
+
+QUrl KFileTreeView::Private::urlForProxyIndex(const QModelIndex &index) const
+{
+    const KFileItem item = mSourceModel->itemForIndex(mProxyModel->mapToSource(index));
+
+    return !item.isNull() ? item.url() : QUrl();
+}
+
+void KFileTreeView::Private::_k_activated(const QModelIndex &index)
+{
+    const QUrl url = urlForProxyIndex(index);
+    if (url.isValid()) {
+        emit q->activated(url);
+    }
+}
+
+void KFileTreeView::Private::_k_currentChanged(const QModelIndex &currentIndex, const QModelIndex &)
+{
+    const QUrl url = urlForProxyIndex(currentIndex);
+    if (url.isValid()) {
+        emit q->currentChanged(url);
+    }
+}
+
+void KFileTreeView::Private::_k_expanded(const QModelIndex &baseIndex)
+{
+    QModelIndex index = mProxyModel->mapFromSource(baseIndex);
+
+    q->selectionModel()->clearSelection();
+    q->selectionModel()->setCurrentIndex(index, QItemSelectionModel::SelectCurrent);
+    q->scrollTo(index);
+}
+
+KFileTreeView::KFileTreeView(QWidget *parent)
+    : QTreeView(parent), d(new Private(this))
+{
+    d->mSourceModel = new KDirModel(this);
+    d->mProxyModel = new KDirSortFilterProxyModel(this);
+    d->mProxyModel->setSourceModel(d->mSourceModel);
+
+    setModel(d->mProxyModel);
+    setItemDelegate(new KFileItemDelegate(this));
+    setLayoutDirection(Qt::LeftToRight);
+
+    d->mSourceModel->dirLister()->openUrl(QUrl::fromLocalFile(QDir::root().absolutePath()), KDirLister::Keep);
+
+    connect(this, SIGNAL(activated(QModelIndex)),
+            this, SLOT(_k_activated(QModelIndex)));
+    connect(selectionModel(), SIGNAL(currentChanged(QModelIndex,QModelIndex)),
+            this, SLOT(_k_currentChanged(QModelIndex,QModelIndex)));
+
+    connect(d->mSourceModel, SIGNAL(expand(QModelIndex)),
+            this, SLOT(_k_expanded(QModelIndex)));
+}
+
+KFileTreeView::~KFileTreeView()
+{
+    delete d;
+}
+
+QUrl KFileTreeView::currentUrl() const
+{
+    return d->urlForProxyIndex(currentIndex());
+}
+
+QUrl KFileTreeView::selectedUrl() const
+{
+    if (!selectionModel()->hasSelection()) {
+        return QUrl();
+    }
+
+    const QItemSelection selection = selectionModel()->selection();
+    const QModelIndex firstIndex = selection.indexes().first();
+
+    return d->urlForProxyIndex(firstIndex);
+}
+
+QList<QUrl> KFileTreeView::selectedUrls() const
+{
+    QList<QUrl> urls;
+
+    if (!selectionModel()->hasSelection()) {
+        return urls;
+    }
+
+    const QModelIndexList indexes = selectionModel()->selection().indexes();
+    foreach (const QModelIndex &index, indexes) {
+        const QUrl url = d->urlForProxyIndex(index);
+        if (url.isValid()) {
+            urls.append(url);
+        }
+    }
+
+    return urls;
+}
+
+QUrl KFileTreeView::rootUrl() const
+{
+    return d->mSourceModel->dirLister()->url();
+}
+
+void KFileTreeView::setDirOnlyMode(bool enabled)
+{
+    d->mSourceModel->dirLister()->setDirOnlyMode(enabled);
+    d->mSourceModel->dirLister()->openUrl(d->mSourceModel->dirLister()->url());
+}
+
+void KFileTreeView::setShowHiddenFiles(bool enabled)
+{
+    QUrl url = currentUrl();
+    d->mSourceModel->dirLister()->setShowingDotFiles(enabled);
+    d->mSourceModel->dirLister()->openUrl(d->mSourceModel->dirLister()->url());
+    setCurrentUrl(url);
+}
+
+void KFileTreeView::setCurrentUrl(const QUrl &url)
+{
+    QModelIndex baseIndex = d->mSourceModel->indexForUrl(url);
+
+    if (!baseIndex.isValid()) {
+        d->mSourceModel->expandToUrl(url);
+        return;
+    }
+
+    QModelIndex proxyIndex = d->mProxyModel->mapFromSource(baseIndex);
+    selectionModel()->clearSelection();
+    selectionModel()->setCurrentIndex(proxyIndex, QItemSelectionModel::SelectCurrent);
+    scrollTo(proxyIndex);
+}
+
+void KFileTreeView::setRootUrl(const QUrl &url)
+{
+    d->mSourceModel->dirLister()->openUrl(url);
+}
+
+void KFileTreeView::contextMenuEvent(QContextMenuEvent *event)
+{
+    QMenu menu;
+    KToggleAction *showHiddenAction = new KToggleAction(i18n("Show Hidden Folders"), &menu);
+    showHiddenAction->setChecked(d->mSourceModel->dirLister()->showingDotFiles());
+    connect(showHiddenAction, SIGNAL(toggled(bool)), this, SLOT(setShowHiddenFiles(bool)));
+
+    menu.addAction(showHiddenAction);
+    menu.exec(event->globalPos());
+}
+
+bool KFileTreeView::showHiddenFiles() const
+{
+    return d->mSourceModel->dirLister()->showingDotFiles();
+}
+
+QSize KFileTreeView::sizeHint() const
+{
+    // This size makes KDirSelectDialog pop up just under 800x600 by default :-)
+    return QSize(680, 500);
+}
+
+#include "moc_kfiletreeview_p.cpp"
+
diff --git src/platformtheme/kfiletreeview_p.h src/platformtheme/kfiletreeview_p.h
new file mode 100644
index 0000000..8442018
--- /dev/null
+++ src/platformtheme/kfiletreeview_p.h
@@ -0,0 +1,128 @@
+/*
+   This file is part of the KDE project
+
+   Copyright (C) 2007 Tobias Koenig <tokoe@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KFILETREEVIEW_H
+#define KFILETREEVIEW_H
+
+#include <QTreeView>
+
+#include <QUrl>
+
+/**
+ * The file treeview offers a treeview on the filesystem.
+ */
+class KFileTreeView : public QTreeView // exported only for kfiletreeviewtest
+{
+    Q_OBJECT
+
+public:
+    /**
+     * Creates a new file tree view.
+     */
+    KFileTreeView(QWidget *parent = 0);
+
+    /**
+     * Destroys the file tree view.
+     */
+    ~KFileTreeView();
+
+    /**
+     * Returns the current url.
+     */
+    QUrl currentUrl() const;
+
+    /**
+     * Returns the selected url.
+     */
+    QUrl selectedUrl() const;
+
+    /**
+     * Returns all selected urls.
+     */
+    QList<QUrl> selectedUrls() const;
+
+    /**
+     * Returns the current root url of the view.
+     */
+    QUrl rootUrl() const;
+
+    /**
+     * Returns true if the view is currently showing hidden files
+     * @since 4.3
+     */
+    bool showHiddenFiles() const;
+
+    /**
+     * @reimplemented
+     */
+    QSize sizeHint() const Q_DECL_OVERRIDE;
+
+public Q_SLOTS:
+    /**
+     * Sets whether the dir-only mode is @p enabled.
+     *
+     * In dir-only mode, only directories and subdirectories
+     * are listed in the view.
+     */
+    void setDirOnlyMode(bool enabled);
+
+    /**
+     * Sets whether hidden files shall be listed.
+     */
+    void setShowHiddenFiles(bool enabled);
+
+    /**
+     * Sets the current @p url of the view.
+     */
+    void setCurrentUrl(const QUrl &url);
+
+    /**
+     * Sets the root @p url of the view.
+     *
+     * The default is file:///.
+     */
+    void setRootUrl(const QUrl &url);
+
+Q_SIGNALS:
+    /**
+     * This signal is emitted whenever an @p url has been activated.
+     */
+    void activated(const QUrl &url);
+
+    /**
+     * This signal is emitted whenever the current @p url has been changed.
+     */
+    void currentChanged(const QUrl &url);
+
+protected:
+    using QTreeView::currentChanged;
+    void contextMenuEvent(QContextMenuEvent *) Q_DECL_OVERRIDE;
+
+private:
+    class Private;
+    Private *const d;
+
+    Q_PRIVATE_SLOT(d, void _k_activated(const QModelIndex &))
+    Q_PRIVATE_SLOT(d, void _k_currentChanged(const QModelIndex &, const QModelIndex &))
+    Q_PRIVATE_SLOT(d, void _k_expanded(const QModelIndex &))
+};
+
+#endif
diff --git src/platformtheme/kfontsettingsdata.cpp src/platformtheme/kfontsettingsdata.cpp
new file mode 100644
index 0000000..7c85430
--- /dev/null
+++ src/platformtheme/kfontsettingsdata.cpp
@@ -0,0 +1,119 @@
+/* This file is part of the KDE libraries
+   Copyright (C) 2000, 2006 David Faure <faure@kde.org>
+   Copyright 2008 Friedrich W. H. Kossebau <kossebau@kde.org>
+   Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "kfontsettingsdata.h"
+#include <QCoreApplication>
+#include <QString>
+#include <QVariant>
+#include <QApplication>
+#include <QDBusMessage>
+#include <QDBusConnection>
+#include <qpa/qwindowsysteminterface.h>
+
+#include <ksharedconfig.h>
+#include <kconfiggroup.h>
+
+KFontSettingsData::KFontSettingsData()
+    : QObject(0)
+{
+    QMetaObject::invokeMethod(this, "delayedDBusConnects", Qt::QueuedConnection);
+
+    for (int i = 0; i < FontTypesCount; ++i) {
+        mFonts[i] = 0;
+    }
+}
+
+KFontSettingsData::~KFontSettingsData()
+{
+    for (int i = 0; i < FontTypesCount; ++i) {
+        delete mFonts[i];
+    }
+}
+
+// NOTE: keep in sync with plasma-desktop/kcms/fonts/fonts.cpp
+static const char GeneralId[] =      "General";
+static const char DefaultFont[] =    "Noto Sans";
+
+static const KFontData DefaultFontData[KFontSettingsData::FontTypesCount] = {
+    { GeneralId, "font",                 DefaultFont,  10, -1, QFont::SansSerif },
+    { GeneralId, "fixed",                "Oxygen Mono",  9, -1, QFont::Monospace },
+    { GeneralId, "toolBarFont",          DefaultFont,  9, -1, QFont::SansSerif },
+    { GeneralId, "menuFont",             DefaultFont,  10, -1, QFont::SansSerif },
+    { "WM",      "activeFont",           DefaultFont,  10, -1, QFont::SansSerif },
+    { GeneralId, "taskbarFont",          DefaultFont,  10, -1, QFont::SansSerif },
+    { GeneralId, "smallestReadableFont", DefaultFont,  8, -1, QFont::SansSerif }
+};
+
+KSharedConfigPtr &KFontSettingsData::kdeGlobals()
+{
+    if (!mKdeGlobals) {
+        mKdeGlobals = KSharedConfig::openConfig(QStringLiteral("kdeglobals"), KConfig::NoGlobals);
+    }
+    return mKdeGlobals;
+}
+
+QFont *KFontSettingsData::font(FontTypes fontType)
+{
+    QFont *cachedFont = mFonts[fontType];
+
+    if (!cachedFont) {
+        const KFontData &fontData = DefaultFontData[fontType];
+        cachedFont = new QFont(QLatin1String(fontData.FontName), fontData.Size, fontData.Weight);
+        cachedFont->setStyleHint(fontData.StyleHint);
+
+        const KConfigGroup configGroup(kdeGlobals(), fontData.ConfigGroupKey);
+        QString fontInfo = configGroup.readEntry(fontData.ConfigKey, QString());
+
+        //If we have serialized information for this font, restore it
+        //NOTE: We are not using KConfig directly because we can't call QFont::QFont from here
+        if (!fontInfo.isEmpty()) {
+            cachedFont->fromString(fontInfo);
+        }
+
+        mFonts[fontType] = cachedFont;
+    }
+
+    return cachedFont;
+}
+
+void KFontSettingsData::dropFontSettingsCache()
+{
+    if (mKdeGlobals) {
+        mKdeGlobals->reparseConfiguration();
+    }
+    for (int i = 0; i < FontTypesCount; ++i) {
+        delete mFonts[i];
+        mFonts[i] = 0;
+    }
+
+    QWindowSystemInterface::handleThemeChange(0);
+
+    if (qobject_cast<QApplication *>(QCoreApplication::instance())) {
+        QApplication::setFont(*font(KFontSettingsData::GeneralFont));
+    } else {
+        QGuiApplication::setFont(*font(KFontSettingsData::GeneralFont));
+    }
+}
+
+void KFontSettingsData::delayedDBusConnects()
+{
+    QDBusConnection::sessionBus().connect(QString(), QStringLiteral("/KDEPlatformTheme"), QStringLiteral("org.kde.KDEPlatformTheme"),
+                                          QStringLiteral("refreshFonts"), this, SLOT(dropFontSettingsCache()));
+}
diff --git src/platformtheme/kfontsettingsdata.h src/platformtheme/kfontsettingsdata.h
new file mode 100644
index 0000000..4c14f54
--- /dev/null
+++ src/platformtheme/kfontsettingsdata.h
@@ -0,0 +1,74 @@
+/* This file is part of the KDE libraries
+   Copyright (C) 2000, 2006 David Faure <faure@kde.org>
+   Copyright 2008 Friedrich W. H. Kossebau <kossebau@kde.org>
+   Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KFONTSETTINGSDATA_H
+#define KFONTSETTINGSDATA_H
+
+#include <QObject>
+#include <QFont>
+#include <ksharedconfig.h>
+
+struct KFontData {
+    const char *ConfigGroupKey;
+    const char *ConfigKey;
+    const char *FontName;
+    int Size;
+    int Weight;
+    QFont::StyleHint StyleHint;
+};
+
+class KFontSettingsData : public QObject
+{
+    Q_OBJECT
+public:
+    // if adding a new type here also add an entry to DefaultFontData
+    enum FontTypes {
+        GeneralFont = 0,
+        FixedFont,
+        ToolbarFont,
+        MenuFont,
+        WindowTitleFont,
+        TaskbarFont,
+        SmallestReadableFont,
+        FontTypesCount
+    };
+
+public:
+    KFontSettingsData();
+    ~KFontSettingsData();
+
+public Q_SLOTS:
+    void dropFontSettingsCache();
+
+protected Q_SLOTS:
+    void delayedDBusConnects();
+
+public: // access, is not const due to caching
+    QFont *font(FontTypes fontType);
+
+protected:
+    KSharedConfigPtr &kdeGlobals();
+
+private:
+    QFont *mFonts[FontTypesCount];
+    KSharedConfigPtr mKdeGlobals;
+};
+
+#endif // KFONTSETTINGSDATA_H
diff --git src/platformtheme/kfontsettingsdatamac.h src/platformtheme/kfontsettingsdatamac.h
new file mode 100644
index 0000000..ee99919
--- /dev/null
+++ src/platformtheme/kfontsettingsdatamac.h
@@ -0,0 +1,59 @@
+/* This file is part of the KDE libraries
+   Copyright (C) 2000, 2006 David Faure <faure@kde.org>
+   Copyright 2008 Friedrich W. H. Kossebau <kossebau@kde.org>
+   Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+   Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KFONTSETTINGSDATAMAC_H
+#define KFONTSETTINGSDATAMAC_H
+
+#include "kfontsettingsdata.h"
+
+class KFontSettingsDataMac : public KFontSettingsData
+{
+    Q_OBJECT
+public:
+    // if adding a new type here also add an entry to DefaultFontData
+    enum FontTypes {
+        GeneralFont = 0,
+        FixedFont,
+        ToolbarFont,
+        MenuFont,
+        WindowTitleFont,
+        TaskbarFont,
+        SmallestReadableFont,
+        MessageBoxFont,
+        FontTypesCount
+    };
+
+    KFontSettingsDataMac();
+    ~KFontSettingsDataMac();
+
+public Q_SLOTS:
+    void dropFontSettingsCache();
+
+protected Q_SLOTS:
+    void delayedDBusConnects();
+
+public:
+    QFont *font(FontTypes fontType);
+private:
+    QFont *mFonts[FontTypesCount];
+};
+
+#endif // KFONTSETTINGSDATAMAC_H
diff --git src/platformtheme/kfontsettingsdatamac.mm src/platformtheme/kfontsettingsdatamac.mm
new file mode 100644
index 0000000..a001377
--- /dev/null
+++ src/platformtheme/kfontsettingsdatamac.mm
@@ -0,0 +1,210 @@
+/* This file is part of the KDE libraries
+   Copyright (C) 2000, 2006 David Faure <faure@kde.org>
+   Copyright 2008 Friedrich W. H. Kossebau <kossebau@kde.org>
+   Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+   Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "kfontsettingsdatamac.h"
+
+#include <QDebug>
+#include <QCoreApplication>
+#include <QFontDatabase>
+#include <QFont>
+#include <QString>
+#include <QVariant>
+#include <QApplication>
+#include <QDBusMessage>
+#include <QDBusConnection>
+#include <qpa/qwindowsysteminterface.h>
+
+#include <ksharedconfig.h>
+#include <kconfiggroup.h>
+
+// NOTE: keep in sync with plasma-desktop/kcms/fonts/fonts.cpp
+static const char GeneralId[] =      "General";
+// NOTE: the default system font changed with OS X 10.11, from Lucida Grande to
+// San Francisco. With luck this will be caught by QFontDatabase::GeneralFont
+static const char DefaultFont[] =    "Lucida Grande";
+static char *LocalDefaultFont = NULL;
+
+/* Default fonts on OS X <= 10.9 :
+    System: Lucida Grande 13pt
+    System headlines: <System>,Bold
+    Application: Helvetica 12pt
+    Fixed width: Monaco 10pt
+    Messages: <system>
+    Labels: <system>,11pt
+    Help tags: <system>,11pt
+    Window title bars: <system>
+    Utility window title bars: <system>,11pt
+    --- Dumped from the native QPlatformTheme::themeFont() function:
+    (themeFont QPlatformTheme::Font : CoreText font role)
+    themeFont 0 : 2 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,13,-1,5,50,0,0,0,0,0"
+    themeFont 1 : 12 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,14,-1,5,50,0,0,0,0,0"
+    themeFont 2 : 12 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,14,-1,5,50,0,0,0,0,0"
+    themeFont 3 : 12 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,14,-1,5,50,0,0,0,0,0"
+    themeFont 4 : 3 = ".Lucida Grande UI" style "Bold" NSFont weight@12pt= 9 QFont= ".Lucida Grande UI,13,-1,5,75,0,0,0,0,0"
+    themeFont 5 : 2 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,13,-1,5,50,0,0,0,0,0"
+    themeFont 6 : 25 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,11,-1,5,50,0,0,0,0,0"
+    themeFont 7 : 2 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,13,-1,5,50,0,0,0,0,0"
+    themeFont 8 : 15 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,13,-1,5,50,0,0,0,0,0"
+    themeFont 9 : 2 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,13,-1,5,50,0,0,0,0,0"
+    themeFont 10 : 2 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,13,-1,5,50,0,0,0,0,0"
+    themeFont 11 : 16 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,13,-1,5,50,0,0,0,0,0"
+    themeFont 12 : 2 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,13,-1,5,50,0,0,0,0,0"
+    themeFont 13 : 2 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,13,-1,5,50,0,0,0,0,0"
+    themeFont 14 : 22 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,10,-1,5,50,0,0,0,0,0"
+    themeFont 15 : 2 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,13,-1,5,50,0,0,0,0,0"
+    themeFont 16 : 8 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,12,-1,5,50,0,0,0,0,0"
+    themeFont 17 : 4 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,11,-1,5,50,0,0,0,0,0"
+    themeFont 18 : 8 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,12,-1,5,50,0,0,0,0,0"
+    themeFont 19 : 2 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,13,-1,5,50,0,0,0,0,0"
+    themeFont 20 : 8 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,12,-1,5,50,0,0,0,0,0"
+    themeFont 21 : 4 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,11,-1,5,50,0,0,0,0,0"
+    themeFont 22 : 6 = ".Lucida Grande UI" style "Regular" NSFont weight@12pt= 5 QFont= ".Lucida Grande UI,9,-1,5,50,0,0,0,0,0"
+    themeFont 23 : 1 = "Monaco" style "Regular" NSFont weight@12pt= 5 QFont= "Monaco,10,-1,5,50,0,0,0,0,0"
+ */
+
+static KFontData DefaultFontData[KFontSettingsDataMac::FontTypesCount] = {
+    // Note: we use 
+    { GeneralId, "font",                 DefaultFont,  12, -1, QFont::SansSerif },
+    { GeneralId, "fixed",                "Monaco",     10, -1, QFont::Monospace },
+    { GeneralId, "toolBarFont",          DefaultFont,  11, -1, QFont::SansSerif },
+    { GeneralId, "menuFont",             DefaultFont,  14, -1, QFont::SansSerif },
+    { "WM",      "activeFont",           DefaultFont,  13, -1, QFont::SansSerif },
+    { GeneralId, "taskbarFont",          DefaultFont,   9, -1, QFont::SansSerif },
+    { GeneralId, "smallestReadableFont", DefaultFont,   9, -1, QFont::SansSerif },
+    // this one is to accomodate for the MessageBoxFont which should be bold on OS X
+    // when using the native theme fonts.
+    { GeneralId, "messageBoxFont",       DefaultFont,  13, QFont::Bold, QFont::SansSerif }
+};
+
+static const char *fontNameFor(QFontDatabase::SystemFont role)
+{
+    QFont qf = QFontDatabase::systemFont(role);
+    const char *fn = qf.defaultFamily().toLocal8Bit().constData();
+    if (role == QFontDatabase::FixedFont && !qf.fixedPitch()) {
+        fn = "Monaco";
+    }
+    if (strcmp(fn, ".Lucida Grande UI") == 0) {
+        return "Lucida Grande";
+    } else {
+        return fn;
+    }
+}
+
+KFontSettingsDataMac::KFontSettingsDataMac()
+{
+    QMetaObject::invokeMethod(this, "delayedDBusConnects", Qt::QueuedConnection);
+    if (!LocalDefaultFont) {
+        LocalDefaultFont = strdup(fontNameFor(QFontDatabase::GeneralFont));
+    }
+    for (int i = 0 ; i < KFontSettingsDataMac::FontTypesCount ; ++i) {
+        const char *fn;
+        switch(i) {
+            case FixedFont:
+                fn = strdup(fontNameFor(QFontDatabase::FixedFont));
+                break;
+            case WindowTitleFont:
+                fn = strdup(fontNameFor(QFontDatabase::TitleFont));
+                break;
+            case SmallestReadableFont:
+                fn = strdup(fontNameFor(QFontDatabase::SmallestReadableFont));
+                break;
+            default:
+                fn = LocalDefaultFont;
+                break;
+        }
+        DefaultFontData[i].FontName = fn;
+    }
+    for (int i = 0; i < FontTypesCount; ++i) {
+        // remove any information that already have been cached by our parent
+        // IFF we don't have our own mFonts copy
+        // delete mFonts[i];
+        mFonts[i] = 0;
+    }
+}
+
+KFontSettingsDataMac::~KFontSettingsDataMac()
+{
+    for (int i = 0 ; i < KFontSettingsDataMac::FontTypesCount ; ++i) {
+        if (DefaultFontData[i].FontName != DefaultFont) {
+            if (DefaultFontData[i].FontName != LocalDefaultFont) {
+                delete DefaultFontData[i].FontName;
+            }
+            DefaultFontData[i].FontName = DefaultFont;
+        }
+    }
+    delete LocalDefaultFont;
+    LocalDefaultFont = NULL;
+}
+
+QFont *KFontSettingsDataMac::font(FontTypes fontType)
+{
+    QFont *cachedFont = mFonts[fontType];
+
+    if (!cachedFont) {
+        const KConfigGroup configGroup(kdeGlobals(), DefaultFontData[fontType].ConfigGroupKey);
+        QString fontInfo;
+        bool forceBold = false;
+
+        if (fontType == MessageBoxFont) {
+            // OS X special: the MessageBoxFont is by default a bold version of the GeneralFont
+            // and that's what is cached in DefaultFontData[MessageBoxFont].
+            // NB: we can use a single configGroup for this hack as long as MessageBoxFont and
+            // GeneralFont share the same ConfigGroupKey (or MessageBoxFont cannot be configured).
+            fontInfo = configGroup.readEntry(DefaultFontData[GeneralFont].ConfigKey, QString());
+            if (!fontInfo.isEmpty()) {
+                // However, if the user has configured a GeneralFont (MessageBoxFont cannot be configured),
+                // we respect his/her choice but maintain the bold aspect dictated by the platform.
+                fontType = GeneralFont;
+                forceBold = true;
+            }
+        }
+
+        const KFontData &fontData = DefaultFontData[fontType];
+
+        cachedFont = new QFont(QLatin1String(fontData.FontName), fontData.Size, forceBold? QFont::Bold : fontData.Weight);
+        cachedFont->setStyleHint(fontData.StyleHint);
+
+        fontInfo = configGroup.readEntry(fontData.ConfigKey, QString());
+
+        if (!fontInfo.isEmpty()) {
+            cachedFont->fromString(fontInfo);
+        }
+
+        mFonts[fontType] = cachedFont;
+    }
+
+    return cachedFont;
+}
+
+void KFontSettingsDataMac::dropFontSettingsCache()
+{
+    if (qobject_cast<QApplication *>(QCoreApplication::instance())) {
+        QApplication::setFont(*font(KFontSettingsDataMac::GeneralFont));
+    } else {
+        QGuiApplication::setFont(*font(KFontSettingsDataMac::GeneralFont));
+    }
+}
+
+void KFontSettingsDataMac::delayedDBusConnects()
+{
+    QDBusConnection::sessionBus().connect(QString(), QStringLiteral("/KDEPlatformTheme"), QStringLiteral("org.kde.KDEPlatformTheme"),
+                                          QStringLiteral("refreshFonts"), this, SLOT(dropFontSettingsCache()));
+}
diff --git src/platformtheme/khintssettings.cpp src/platformtheme/khintssettings.cpp
new file mode 100644
index 0000000..7343fdb
--- /dev/null
+++ src/platformtheme/khintssettings.cpp
@@ -0,0 +1,423 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Kevin Ottens <ervin+bluesystems@kde.org>
+ *  Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+ *  Copyright 2013 Alejandro Fiestas Olivares <afiestas@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include "khintssettings.h"
+
+#include <QDebug>
+#include <QDir>
+#include <QString>
+#include <QFileInfo>
+#include <QToolBar>
+#include <QPalette>
+#include <QToolButton>
+#include <QMainWindow>
+#include <QApplication>
+#include <QGuiApplication>
+#include <QDialogButtonBox>
+#include <QScreen>
+
+#include <QDBusConnection>
+#include <QDBusInterface>
+
+#include <kiconloader.h>
+#include <kconfiggroup.h>
+#include <ksharedconfig.h>
+#include <kcolorscheme.h>
+
+#include <config-platformtheme.h>
+#ifdef UNIT_TEST
+#undef HAVE_X11
+#define HAVE_X11 0
+#endif
+#if HAVE_X11
+#include <QX11Info>
+#include <X11/Xcursor/Xcursor.h>
+#endif
+
+static const QString defaultLookAndFeelPackage = QStringLiteral("org.kde.breeze.desktop");
+
+KSharedConfigPtr &KHintsSettings::kdeGlobals()
+{
+    if (!mKdeGlobals) {
+        mKdeGlobals = KSharedConfig::openConfig(QStringLiteral("kdeglobals"), KConfig::NoGlobals);
+    }
+    return mKdeGlobals;
+}
+
+KHintsSettings::KHintsSettings() : QObject(0)
+{
+    kdeGlobals();
+    KConfigGroup cg(mKdeGlobals, "KDE");
+
+    // try to extract the proper defaults file from a lookandfeel package
+    const QString looknfeel = cg.readEntry("LookAndFeelPackage", defaultLookAndFeelPackage);
+    mDefaultLnfConfig = KSharedConfig::openConfig(QStandardPaths::locate(QStandardPaths::GenericDataLocation, QStringLiteral("plasma/look-and-feel/") + looknfeel + QStringLiteral("/contents/defaults")));
+    if (looknfeel != defaultLookAndFeelPackage) {
+        mLnfConfig = KSharedConfig::openConfig(QStandardPaths::locate(QStandardPaths::GenericDataLocation, QStringLiteral("plasma/look-and-feel/") + defaultLookAndFeelPackage + QStringLiteral("/contents/defaults")));
+    }
+
+
+    m_hints[QPlatformTheme::CursorFlashTime] = qBound(200, cg.readEntry("CursorBlinkRate", 1000), 2000);
+    m_hints[QPlatformTheme::MouseDoubleClickInterval] = cg.readEntry("DoubleClickInterval", 400);
+    m_hints[QPlatformTheme::StartDragDistance] = cg.readEntry("StartDragDist", 10);
+    m_hints[QPlatformTheme::StartDragTime] = cg.readEntry("StartDragTime", 500);
+
+    KConfigGroup cgToolbar(mKdeGlobals, "Toolbar style");
+    m_hints[QPlatformTheme::ToolButtonStyle] = toolButtonStyle(cgToolbar);
+
+    KConfigGroup cgToolbarIcon(mKdeGlobals, "MainToolbarIcons");
+    m_hints[QPlatformTheme::ToolBarIconSize] = cgToolbarIcon.readEntry("Size", 22);
+
+    m_hints[QPlatformTheme::ItemViewActivateItemOnSingleClick] = cg.readEntry("SingleClick", true);
+
+    m_hints[QPlatformTheme::SystemIconThemeName] = readConfigValue(QStringLiteral("Icons"), QStringLiteral("Theme"), QStringLiteral("breeze"));
+
+    m_hints[QPlatformTheme::SystemIconFallbackThemeName] = QStringLiteral("hicolor");
+    m_hints[QPlatformTheme::IconThemeSearchPaths] = xdgIconThemePaths();
+
+    QStringList styleNames;
+    styleNames << QStringLiteral(BREEZE_STYLE_NAME)
+               << QStringLiteral("oxygen")
+               << QStringLiteral("fusion")
+               << QStringLiteral("windows");
+    const QString configuredStyle = cg.readEntry("widgetStyle", QString());
+    if (!configuredStyle.isEmpty()) {
+        styleNames.removeOne(configuredStyle);
+        styleNames.prepend(configuredStyle);
+    }
+    const QString lnfStyle = readConfigValue(QStringLiteral("KDE"), QStringLiteral("widgetStyle"), QString()).toString();
+    if (!lnfStyle.isEmpty()) {
+        styleNames.removeOne(lnfStyle);
+        styleNames.prepend(lnfStyle);
+    }
+    m_hints[QPlatformTheme::StyleNames] = styleNames;
+
+    m_hints[QPlatformTheme::DialogButtonBoxLayout] = QDialogButtonBox::KdeLayout;
+    m_hints[QPlatformTheme::DialogButtonBoxButtonsHaveIcons] = cg.readEntry("ShowIconsOnPushButtons", true);
+    m_hints[QPlatformTheme::UseFullScreenForPopupMenu] = true;
+    m_hints[QPlatformTheme::KeyboardScheme] = QPlatformTheme::KdeKeyboardScheme;
+    m_hints[QPlatformTheme::UiEffects] = cg.readEntry("GraphicEffectsLevel", 0) != 0 ? QPlatformTheme::GeneralUiEffect : 0;
+    m_hints[QPlatformTheme::IconPixmapSizes] = QVariant::fromValue(QList<int>() << 512 << 256 << 128 << 64 << 32 << 22 << 16 << 8);
+
+    m_hints[QPlatformTheme::WheelScrollLines] = cg.readEntry("WheelScrollLines", 3);
+    if (qobject_cast<QApplication *>(QCoreApplication::instance())) {
+        QApplication::setWheelScrollLines(cg.readEntry("WheelScrollLines", 3));
+    }
+
+    bool showIcons = cg.readEntry("ShowIconsInMenuItems", !QApplication::testAttribute(Qt::AA_DontShowIconsInMenus));
+    QCoreApplication::setAttribute(Qt::AA_DontShowIconsInMenus, !showIcons);
+
+    QMetaObject::invokeMethod(this, "delayedDBusConnects", Qt::QueuedConnection);
+    QMetaObject::invokeMethod(this, "setupIconLoader", Qt::QueuedConnection);
+
+    loadPalettes();
+}
+
+KHintsSettings::~KHintsSettings()
+{
+    qDeleteAll(m_palettes);
+}
+
+QVariant KHintsSettings::readConfigValue(const QString &group, const QString &key, const QVariant &defaultValue)
+{
+    KConfigGroup userCg(mKdeGlobals, group);
+    QVariant value = userCg.readEntry(key, QString());
+
+    if (!value.isNull()) {
+        return value;
+    }
+
+    if (mLnfConfig) {
+        KConfigGroup lnfCg(mLnfConfig, "kdeglobals");
+        lnfCg = KConfigGroup(&lnfCg, group);
+        if (lnfCg.isValid()) {
+            value = lnfCg.readEntry(key, defaultValue);
+
+            if (!value.isNull()) {
+                return value;
+            }
+        }
+    }
+
+    KConfigGroup lnfCg(mDefaultLnfConfig, group);
+    if (lnfCg.isValid()) {
+        return lnfCg.readEntry(key, defaultValue);
+    }
+
+    return defaultValue;
+}
+
+QStringList KHintsSettings::xdgIconThemePaths() const
+{
+    QStringList paths;
+
+    const QFileInfo homeIconDir(QDir::homePath() + QStringLiteral("/.icons"));
+    if (homeIconDir.isDir()) {
+        paths << homeIconDir.absoluteFilePath();
+    }
+
+    QString xdgDirString = QFile::decodeName(qgetenv("XDG_DATA_DIRS"));
+
+    if (xdgDirString.isEmpty()) {
+        xdgDirString = QStringLiteral("/usr/local/share:/usr/share");
+    }
+
+    foreach (const QString &xdgDir, xdgDirString.split(QLatin1Char(':'))) {
+        const QFileInfo xdgIconsDir(xdgDir + QStringLiteral("/icons"));
+        if (xdgIconsDir.isDir()) {
+            paths << xdgIconsDir.absoluteFilePath();
+        }
+    }
+
+    return paths;
+}
+
+void KHintsSettings::delayedDBusConnects()
+{
+    QDBusConnection::sessionBus().connect(QString(), QStringLiteral("/KToolBar"), QStringLiteral("org.kde.KToolBar"),
+                                          QStringLiteral("styleChanged"), this, SLOT(toolbarStyleChanged()));
+    QDBusConnection::sessionBus().connect(QString(), QStringLiteral("/KGlobalSettings"), QStringLiteral("org.kde.KGlobalSettings"),
+                                          QStringLiteral("notifyChange"), this, SLOT(slotNotifyChange(int,int)));
+}
+
+void KHintsSettings::setupIconLoader()
+{
+    connect(KIconLoader::global(), &KIconLoader::iconChanged, this, &KHintsSettings::iconChanged);
+}
+
+void KHintsSettings::toolbarStyleChanged()
+{
+    mKdeGlobals->reparseConfiguration();
+    KConfigGroup cg(mKdeGlobals, "Toolbar style");
+
+    m_hints[QPlatformTheme::ToolButtonStyle] = toolButtonStyle(cg);
+    //from gtksymbol.cpp
+    QWidgetList widgets = QApplication::allWidgets();
+    for (int i = 0; i < widgets.size(); ++i) {
+        QWidget *widget = widgets.at(i);
+        if (qobject_cast<QToolButton *>(widget)) {
+            QEvent event(QEvent::StyleChange);
+            QApplication::sendEvent(widget, &event);
+        }
+    }
+}
+
+void KHintsSettings::slotNotifyChange(int type, int arg)
+{
+    mKdeGlobals->reparseConfiguration();
+    KConfigGroup cg(mKdeGlobals, "KDE");
+
+    switch (type) {
+    case PaletteChanged: {
+        loadPalettes();
+
+        //QApplication::setPalette and QGuiApplication::setPalette are different functions
+        //and non virtual. Call the correct one
+        if (qobject_cast<QApplication *>(QCoreApplication::instance())) {
+            QApplication::setPalette(*m_palettes[QPlatformTheme::SystemPalette]);
+        } else if (qobject_cast<QGuiApplication *>(QCoreApplication::instance())) {
+            QGuiApplication::setPalette(*m_palettes[QPlatformTheme::SystemPalette]);
+        }
+        break;
+    }
+    case SettingsChanged: {
+
+        SettingsCategory category = static_cast<SettingsCategory>(arg);
+        if (category == SETTINGS_QT || category == SETTINGS_MOUSE) {
+            updateQtSettings(cg);
+        } else if (category == SETTINGS_STYLE) {
+            m_hints[QPlatformTheme::DialogButtonBoxButtonsHaveIcons] = cg.readEntry("ShowIconsOnPushButtons", true);
+            m_hints[QPlatformTheme::UiEffects] = cg.readEntry("GraphicEffectsLevel", 0) != 0 ? QPlatformTheme::GeneralUiEffect : 0;
+        }
+        break;
+    }
+    case ToolbarStyleChanged: {
+        toolbarStyleChanged();
+        break;
+    }
+    case IconChanged:
+        iconChanged(arg); //Once the KCM is ported to use IconChanged, this should not be needed
+        break;
+    case CursorChanged:
+        updateCursorTheme();
+        break;
+    case StyleChanged: {
+        QApplication *app = qobject_cast<QApplication *>(QCoreApplication::instance());
+        if (!app) {
+            return;
+        }
+
+        const QString theme = cg.readEntry("widgetStyle", QString());
+        if (theme.isEmpty()) {
+            return;
+        }
+
+        QStringList styleNames;
+        styleNames << cg.readEntry("widgetStyle", QString())
+                << QStringLiteral(BREEZE_STYLE_NAME)
+                << QStringLiteral("oxygen")
+                << QStringLiteral("fusion")
+                << QStringLiteral("windows");
+        const QString lnfStyle = readConfigValue(QStringLiteral("KDE"), QStringLiteral("widgetStyle"), QString()).toString();
+        if (!lnfStyle.isEmpty() && !styleNames.contains(lnfStyle)) {
+            styleNames.prepend(lnfStyle);
+        }
+        m_hints[QPlatformTheme::StyleNames] = styleNames;
+
+        app->setStyle(theme);
+        loadPalettes();
+        break;
+    }
+    default:
+        qWarning() << "Unknown type of change in KGlobalSettings::slotNotifyChange: " << type;
+    }
+}
+
+void KHintsSettings::iconChanged(int group)
+{
+    KIconLoader::Group iconGroup = (KIconLoader::Group) group;
+    if (iconGroup != KIconLoader::MainToolbar) {
+        m_hints[QPlatformTheme::SystemIconThemeName] = readConfigValue(QStringLiteral("Icons"), QStringLiteral("Theme"), QStringLiteral("breeze"));
+
+        return;
+    }
+
+    const int currentSize = KIconLoader::global()->currentSize(KIconLoader::MainToolbar);
+    if (m_hints[QPlatformTheme::ToolBarIconSize] == currentSize) {
+        return;
+    }
+
+    m_hints[QPlatformTheme::ToolBarIconSize] = currentSize;
+
+    //If we are not a QApplication, means that we are a QGuiApplication, then we do nothing.
+    if (!qobject_cast<QApplication *>(QCoreApplication::instance())) {
+        return;
+    }
+
+    QWidgetList widgets = QApplication::allWidgets();
+    Q_FOREACH (QWidget *widget, widgets) {
+        if (qobject_cast<QToolBar *>(widget) || qobject_cast<QMainWindow *>(widget)) {
+            QEvent event(QEvent::StyleChange);
+            QApplication::sendEvent(widget, &event);
+        }
+    }
+}
+
+void KHintsSettings::updateQtSettings(KConfigGroup &cg)
+{
+    int flash = qBound(200, cg.readEntry("CursorBlinkRate", 1000), 2000);
+    m_hints[QPlatformTheme::CursorFlashTime] = flash;
+
+    int doubleClickInterval = cg.readEntry("DoubleClickInterval", 400);
+    m_hints[QPlatformTheme::MouseDoubleClickInterval] = doubleClickInterval;
+
+    int startDragDistance = cg.readEntry("StartDragDist", 10);
+    m_hints[QPlatformTheme::StartDragDistance] = startDragDistance;
+
+    int startDragTime = cg.readEntry("StartDragTime", 10);
+    m_hints[QPlatformTheme::StartDragTime] = startDragTime;
+
+    m_hints[QPlatformTheme::ItemViewActivateItemOnSingleClick] = cg.readEntry("SingleClick", true);
+
+    bool showIcons = cg.readEntry("ShowIconsInMenuItems", !QApplication::testAttribute(Qt::AA_DontShowIconsInMenus));
+    QCoreApplication::setAttribute(Qt::AA_DontShowIconsInMenus, !showIcons);
+
+    int wheelScrollLines = cg.readEntry("WheelScrollLines", 3);
+    m_hints[QPlatformTheme::WheelScrollLines] = wheelScrollLines;
+    QApplication *app = qobject_cast<QApplication *>(QCoreApplication::instance());
+    if (app) {
+        QApplication::setWheelScrollLines(cg.readEntry("WheelScrollLines", 3));
+    }
+}
+
+Qt::ToolButtonStyle KHintsSettings::toolButtonStyle(const KConfigGroup &cg) const
+{
+    const QString buttonStyle = cg.readEntry("ToolButtonStyle", "TextBesideIcon").toLower();
+    return buttonStyle == QLatin1String("textbesideicon") ? Qt::ToolButtonTextBesideIcon
+           : buttonStyle == QLatin1String("icontextright") ? Qt::ToolButtonTextBesideIcon
+           : buttonStyle == QLatin1String("textundericon") ? Qt::ToolButtonTextUnderIcon
+           : buttonStyle == QLatin1String("icontextbottom") ? Qt::ToolButtonTextUnderIcon
+           : buttonStyle == QLatin1String("textonly") ? Qt::ToolButtonTextOnly
+           : Qt::ToolButtonIconOnly;
+}
+
+void KHintsSettings::loadPalettes()
+{
+    qDeleteAll(m_palettes);
+    m_palettes.clear();
+
+    if (mKdeGlobals->hasGroup("Colors:View")) {
+        m_palettes[QPlatformTheme::SystemPalette] = new QPalette(KColorScheme::createApplicationPalette(mKdeGlobals));
+    } else {
+
+        KConfigGroup cg(mKdeGlobals, "KDE");
+        const QString looknfeel = cg.readEntry("LookAndFeelPackage", defaultLookAndFeelPackage);
+        QString path = QStandardPaths::locate(QStandardPaths::GenericDataLocation, QStringLiteral("plasma/look-and-feel/") + looknfeel + QStringLiteral("/contents/colors"));
+        if (!path.isEmpty()) {
+            m_palettes[QPlatformTheme::SystemPalette] = new QPalette(KColorScheme::createApplicationPalette(KSharedConfig::openConfig(path)));
+            return;
+        }
+
+        path = QStandardPaths::locate(QStandardPaths::GenericDataLocation, QStringLiteral("plasma/look-and-feel/org.kde.loonandfeel/contents/colors"));
+        if (!path.isEmpty()) {
+            m_palettes[QPlatformTheme::SystemPalette] = new QPalette(KColorScheme::createApplicationPalette(KSharedConfig::openConfig(path)));
+            return;
+        }
+
+        const QString scheme = readConfigValue(QStringLiteral("General"), QStringLiteral("ColorScheme"), QStringLiteral("Breeze")).toString();
+        path = QStandardPaths::locate(QStandardPaths::GenericDataLocation, QStringLiteral("color-schemes/") + scheme + QStringLiteral(".colors"));
+
+        if (!path.isEmpty()) {
+            m_palettes[QPlatformTheme::SystemPalette] = new QPalette(KColorScheme::createApplicationPalette(KSharedConfig::openConfig(path)));
+        }
+    }
+}
+
+void KHintsSettings::updateCursorTheme()
+{
+    KConfig config(QStringLiteral("kcminputrc"));
+    KConfigGroup g(&config, "Mouse");
+
+    int size      = g.readEntry("cursorSize", -1);
+
+    // Default cursor size is 16 points
+    if (size == -1) {
+        if (QScreen *s = QGuiApplication::primaryScreen()) {
+            size = s->logicalDotsPerInchY() * 16 / 72;
+        } else {
+            size = 0;
+        }
+    }
+
+#if HAVE_X11
+    if (QX11Info::isPlatformX11()) {
+        const QString theme = g.readEntry("cursorTheme", QString());
+        // Note that in X11R7.1 and earlier, calling XcursorSetTheme()
+        // with a NULL theme would cause Xcursor to use "default", but
+        // in 7.2 and later it will cause it to revert to the theme that
+        // was configured when the application was started.
+        XcursorSetTheme(QX11Info::display(), theme.isNull() ?
+                        "default" : QFile::encodeName(theme).constData());
+        XcursorSetDefaultSize(QX11Info::display(), size);
+    }
+#endif
+}
diff --git src/platformtheme/khintssettings.h src/platformtheme/khintssettings.h
new file mode 100644
index 0000000..7127aa5
--- /dev/null
+++ src/platformtheme/khintssettings.h
@@ -0,0 +1,101 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Alejandro Fiestas Olivares <afiestas@kde.org>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KHINTS_SETTINGS_H
+#define KHINTS_SETTINGS_H
+
+#include <QObject>
+#include <QVariant>
+
+#include <qpa/qplatformtheme.h>
+#include <ksharedconfig.h>
+
+class KConfigGroup;
+
+class QPalette;
+class KHintsSettings : public QObject
+{
+    Q_OBJECT
+public:
+    /**
+    * An identifier for change signals.
+    * @note Copied from KGlobalSettings
+    */
+    enum ChangeType { PaletteChanged = 0, FontChanged, StyleChanged,
+                      SettingsChanged, IconChanged, CursorChanged,
+                      ToolbarStyleChanged, ClipboardConfigChanged,
+                      BlockShortcuts, NaturalSortingChanged
+                    };
+    /**
+    * Valid values for the settingsChanged signal
+    * @note Copied from KGlobalSettings
+    */
+    enum SettingsCategory { SETTINGS_MOUSE, SETTINGS_COMPLETION, SETTINGS_PATHS,
+                            SETTINGS_POPUPMENU, SETTINGS_QT, SETTINGS_SHORTCUTS,
+                            SETTINGS_LOCALE, SETTINGS_STYLE
+                          };
+    explicit KHintsSettings();
+    virtual ~KHintsSettings();
+
+    inline QVariant hint(QPlatformTheme::ThemeHint hint) const
+    {
+        return m_hints[hint];
+    }
+
+    inline QPalette *palette(QPlatformTheme::Palette type) const
+    {
+        return m_palettes[type];
+    }
+
+    QStringList xdgIconThemePaths() const;
+
+protected Q_SLOTS:
+    void delayedDBusConnects();
+    void setupIconLoader();
+    void toolbarStyleChanged();
+    void slotNotifyChange(int type, int arg);
+
+protected:
+    KSharedConfigPtr &kdeGlobals();
+    QVariant readConfigValue(const QString &group, const QString &key, const QVariant &defaultValue);
+    void loadPalettes();
+    void iconChanged(int group);
+    void updateQtSettings(KConfigGroup &cg);
+    Qt::ToolButtonStyle toolButtonStyle(const KConfigGroup &cg) const;
+    void updateCursorTheme();
+
+    inline QHash<QPlatformTheme::Palette, QPalette *> &palettes()
+    {
+        return m_palettes;
+    }
+    inline QHash<QPlatformTheme::ThemeHint, QVariant> &hints()
+    {
+        return m_hints;
+    }
+
+private:
+    QHash<QPlatformTheme::Palette, QPalette *> m_palettes;
+    QHash<QPlatformTheme::ThemeHint, QVariant> m_hints;
+    KSharedConfigPtr mKdeGlobals;
+    KSharedConfigPtr mDefaultLnfConfig;
+    KSharedConfigPtr mLnfConfig;
+};
+
+#endif //KHINTS_SETTINGS_H
diff --git src/platformtheme/khintssettingsmac.h src/platformtheme/khintssettingsmac.h
new file mode 100644
index 0000000..9e02301
--- /dev/null
+++ src/platformtheme/khintssettingsmac.h
@@ -0,0 +1,50 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Alejandro Fiestas Olivares <afiestas@kde.org>
+ *  Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KHINTS_SETTINGS_MAC_H
+#define KHINTS_SETTINGS_MAC_H
+
+#include "khintssettings.h"
+
+class KConfigGroup;
+
+class QPalette;
+class KHintsSettingsMac : public KHintsSettings
+{
+    Q_OBJECT
+public:
+    explicit KHintsSettingsMac();
+    virtual ~KHintsSettingsMac();
+
+    QStringList xdgIconThemePaths() const;
+
+protected Q_SLOTS:
+    void delayedDBusConnects();
+    void slotNotifyChange(int type, int arg);
+
+protected:
+    void loadPalettes();
+    void iconChanged(int group);
+    Qt::ToolButtonStyle toolButtonStyle(const KConfigGroup &cg) const;
+    void updateCursorTheme();
+};
+
+#endif //KHINTS_SETTINGS_MAC_H
diff --git src/platformtheme/khintssettingsmac.mm src/platformtheme/khintssettingsmac.mm
new file mode 100644
index 0000000..fe2bd5f
--- /dev/null
+++ src/platformtheme/khintssettingsmac.mm
@@ -0,0 +1,229 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Kevin Ottens <ervin+bluesystems@kde.org>
+ *  Copyright 2013 Aleix Pol Gonzalez <aleixpol@blue-systems.com>
+ *  Copyright 2013 Alejandro Fiestas Olivares <afiestas@kde.org>
+ *  Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include "khintssettingsmac.h"
+
+#include <QDebug>
+#include <QDir>
+#include <QString>
+#include <QFileInfo>
+#include <QToolBar>
+#include <QPalette>
+#include <QToolButton>
+#include <QMainWindow>
+#include <QApplication>
+#include <QGuiApplication>
+#include <QDialogButtonBox>
+#include <QScreen>
+
+#include <QDBusConnection>
+#include <QDBusInterface>
+
+#include <kiconloader.h>
+#include <kconfiggroup.h>
+#include <ksharedconfig.h>
+#include <kcolorscheme.h>
+
+#include <config-platformtheme.h>
+
+KHintsSettingsMac::KHintsSettingsMac()
+{
+    KSharedConfigPtr mKdeGlobals = kdeGlobals();
+
+    KConfigGroup cg(mKdeGlobals, "KDE");
+    // we're overriding whatever the parent class configured
+    hints().clear();
+    KConfigGroup cgToolbar(mKdeGlobals, "Toolbar style");
+    hints()[QPlatformTheme::ToolButtonStyle] = toolButtonStyle(cgToolbar);
+
+    KConfigGroup cgToolbarIcon(mKdeGlobals, "MainToolbarIcons");
+    hints()[QPlatformTheme::ToolBarIconSize] = cgToolbarIcon.readEntry("Size", 22);
+
+    hints()[QPlatformTheme::ItemViewActivateItemOnSingleClick] = cg.readEntry("SingleClick", true);
+
+    // The new default Breeze icon theme is svg based and looks more out of place than the older Oxygen theme
+    // which is PNG-based, and thus easier to use with/in the Finder.
+    hints()[QPlatformTheme::SystemIconThemeName] = readConfigValue(QStringLiteral("Icons"), QStringLiteral("Theme"), QStringLiteral("oxygen"));
+
+    hints()[QPlatformTheme::IconThemeSearchPaths] = xdgIconThemePaths();
+
+    QStringList styleNames;
+    styleNames << QStringLiteral("macintosh")
+               << QStringLiteral("fusion")
+               << QStringLiteral("windows");
+    const QString configuredStyle = cg.readEntry("widgetStyle", QString());
+    if (!configuredStyle.isEmpty()) {
+        styleNames.removeOne(configuredStyle);
+        styleNames.prepend(configuredStyle);
+    }
+    const QString lnfStyle = readConfigValue(QStringLiteral("KDE"), QStringLiteral("widgetStyle"), QString()).toString();
+    if (!lnfStyle.isEmpty()) {
+        styleNames.removeOne(lnfStyle);
+        styleNames.prepend(lnfStyle);
+    }
+    hints()[QPlatformTheme::StyleNames] = styleNames;
+
+    hints()[QPlatformTheme::DialogButtonBoxLayout] = QDialogButtonBox::MacLayout;
+    hints()[QPlatformTheme::DialogButtonBoxButtonsHaveIcons] = cg.readEntry("ShowIconsOnPushButtons", false);
+    hints()[QPlatformTheme::UseFullScreenForPopupMenu] = true;
+    hints()[QPlatformTheme::KeyboardScheme] = QPlatformTheme::MacKeyboardScheme;
+    hints()[QPlatformTheme::UiEffects] = cg.readEntry("GraphicEffectsLevel", 0) != 0 ? QPlatformTheme::GeneralUiEffect : 0;
+// this would be what we should return for IconPixmapSizes if we wanted to copy the system defaults:
+//     qreal devicePixelRatio = qGuiApp->devicePixelRatio();
+//     QList<int> sizes;
+//     sizes << 16 * devicePixelRatio
+//           << 32 * devicePixelRatio
+//           << 64 * devicePixelRatio
+//           << 128 * devicePixelRatio;
+//     hints()[QPlatformTheme::IconPixmapSizes] = QVariant::fromValue(sizes);
+
+    hints()[QPlatformTheme::WheelScrollLines] = cg.readEntry("WheelScrollLines", 3);
+    if (qobject_cast<QApplication *>(QCoreApplication::instance())) {
+        QApplication::setWheelScrollLines(cg.readEntry("WheelScrollLines", 3));
+    }
+
+    bool showIcons = cg.readEntry("ShowIconsInMenuItems", !QApplication::testAttribute(Qt::AA_DontShowIconsInMenus));
+    QCoreApplication::setAttribute(Qt::AA_DontShowIconsInMenus, !showIcons);
+
+    QMetaObject::invokeMethod(this, "delayedDBusConnects", Qt::QueuedConnection);
+
+    loadPalettes();
+}
+
+KHintsSettingsMac::~KHintsSettingsMac()
+{
+}
+
+// adapted from QGenericUnixTheme::xdgIconThemePaths()
+QStringList KHintsSettingsMac::xdgIconThemePaths() const
+{
+    QStringList paths;
+    // Add home directory first in search path
+    const QFileInfo homeIconDir(QDir::homePath() + QStringLiteral("/.icons"));
+    if (homeIconDir.isDir()) {
+        paths.prepend(homeIconDir.absoluteFilePath());
+    }
+
+    QStringList xdgDirs = QStandardPaths::standardLocations(QStandardPaths::GenericDataLocation);
+    if (xdgDirs.isEmpty()) {
+        xdgDirs << "/opt/local/share"
+            << "/usr/local/share"
+            << "/usr/share";
+    }
+    foreach (const QString &xdgDir, xdgDirs) {
+        const QFileInfo xdgIconsDir(xdgDir + QStringLiteral("/icons"));
+        if (xdgIconsDir.isDir()) {
+            paths.append(xdgIconsDir.absoluteFilePath());
+        }
+        const QFileInfo pixmapsIconsDir(xdgDir + QStringLiteral("/pixmaps"));
+        if (pixmapsIconsDir.isDir()) {
+            paths.append(pixmapsIconsDir.absoluteFilePath());
+        }
+    }
+    return paths;
+}
+
+void KHintsSettingsMac::delayedDBusConnects()
+{
+    QDBusConnection::sessionBus().connect(QString(), QStringLiteral("/KToolBar"), QStringLiteral("org.kde.KToolBar"),
+                                          QStringLiteral("styleChanged"), this, SLOT(toolbarStyleChanged()));
+    QDBusConnection::sessionBus().connect(QString(), QStringLiteral("/KGlobalSettings"), QStringLiteral("org.kde.KGlobalSettings"),
+                                          QStringLiteral("notifyChange"), this, SLOT(slotNotifyChange(int,int)));
+}
+
+void KHintsSettingsMac::slotNotifyChange(int type, int arg)
+{
+    KHintsSettings::slotNotifyChange(type,arg);
+    KSharedConfigPtr mKdeGlobals = kdeGlobals();
+    KConfigGroup cg(mKdeGlobals, "KDE");
+
+    switch (type) {
+    case SettingsChanged: {
+
+        SettingsCategory category = static_cast<SettingsCategory>(arg);
+        if (category == SETTINGS_STYLE) {
+            hints()[QPlatformTheme::DialogButtonBoxButtonsHaveIcons] = cg.readEntry("ShowIconsOnPushButtons", false);
+        }
+        break;
+    }
+    case StyleChanged: {
+        QApplication *app = qobject_cast<QApplication *>(QCoreApplication::instance());
+        if (!app) {
+            return;
+        }
+
+        const QString theme = cg.readEntry("widgetStyle", QString());
+        if (theme.isEmpty()) {
+            return;
+        }
+
+        QStringList styleNames;
+        styleNames << cg.readEntry("widgetStyle", QString())
+                << QStringLiteral("macintosh")
+                << QStringLiteral("fusion")
+                << QStringLiteral("windows");
+        const QString lnfStyle = readConfigValue(QStringLiteral("KDE"), QStringLiteral("widgetStyle"), QString()).toString();
+        if (!lnfStyle.isEmpty() && !styleNames.contains(lnfStyle)) {
+            styleNames.prepend(lnfStyle);
+        }
+        hints()[QPlatformTheme::StyleNames] = styleNames;
+        break;
+    }
+    }
+}
+
+void KHintsSettingsMac::iconChanged(int group)
+{
+    KIconLoader::Group iconGroup = (KIconLoader::Group) group;
+    if (iconGroup != KIconLoader::MainToolbar) {
+        hints()[QPlatformTheme::SystemIconThemeName] = readConfigValue(QStringLiteral("Icons"), QStringLiteral("Theme"), QStringLiteral("oxygen"));
+        return;
+    }
+    return KHintsSettings::iconChanged(group);
+}
+
+Qt::ToolButtonStyle KHintsSettingsMac::toolButtonStyle(const KConfigGroup &cg) const
+{
+    const QString buttonStyle = cg.readEntry("ToolButtonStyle", "TextUnderIcon").toLower();
+    return buttonStyle == QLatin1String("textbesideicon") ? Qt::ToolButtonTextBesideIcon
+           : buttonStyle == QLatin1String("icontextright") ? Qt::ToolButtonTextBesideIcon
+           : buttonStyle == QLatin1String("textundericon") ? Qt::ToolButtonTextUnderIcon
+           : buttonStyle == QLatin1String("icontextbottom") ? Qt::ToolButtonTextUnderIcon
+           : buttonStyle == QLatin1String("textonly") ? Qt::ToolButtonTextOnly
+           : Qt::ToolButtonIconOnly;
+}
+
+void KHintsSettingsMac::loadPalettes()
+{
+    qDeleteAll(palettes());
+    palettes().clear();
+
+    KSharedConfigPtr mKdeGlobals = kdeGlobals();
+    if (mKdeGlobals->hasGroup("Colors:View")) {
+        palettes()[QPlatformTheme::SystemPalette] = new QPalette(KColorScheme::createApplicationPalette(mKdeGlobals));
+    }
+}
+
+void KHintsSettingsMac::updateCursorTheme()
+{
+}
diff --git src/platformtheme/main_mac.cpp src/platformtheme/main_mac.cpp
new file mode 100644
index 0000000..2141cd5
--- /dev/null
+++ src/platformtheme/main_mac.cpp
@@ -0,0 +1,44 @@
+/*  This file is part of the KDE libraries
+ *  Copyright 2013 Kevin Ottens <ervin+bluesystems@kde.org>
+ *  Copyright 2015 René J.V. Bertin <rjvbertin@gmail.com>
+ *
+ *  This library is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License or ( at
+ *  your option ) version 3 or, at the discretion of KDE e.V. ( which shall
+ *  act as a proxy as in section 14 of the GPLv3 ), any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this library; see the file COPYING.LIB.  If not, write to
+ *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ *  Boston, MA 02110-1301, USA.
+ */
+
+#include <qpa/qplatformthemeplugin.h>
+
+#include "kdemactheme.h"
+
+#include <config-platformtheme.h>
+
+class KdePlatformThemePlugin : public QPlatformThemePlugin
+{
+    Q_OBJECT
+    Q_PLUGIN_METADATA(IID "org.qt-project.Qt.QPA.QPlatformThemeFactoryInterface.5.1" FILE "kdeplatformtheme.json")
+public:
+    KdePlatformThemePlugin(QObject *parent = Q_NULLPTR)
+        : QPlatformThemePlugin(parent) {}
+
+    QPlatformTheme *create(const QString &key, const QStringList &paramList) Q_DECL_OVERRIDE
+    {
+        Q_UNUSED(key)
+        Q_UNUSED(paramList)
+        return new KdeMacTheme;
+    }
+};
+
+#include "main_mac.moc"
