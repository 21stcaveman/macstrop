From e5562d7b00ab566a6ac095c07b1ad0a9fc1bf010 Mon Sep 17 00:00:00 2001
From: Peifeng Yu <7437103@gmail.com>
Date: Mon, 12 Sep 2016 11:30:06 -0400
Subject: [PATCH] LLDB plugin: fix Bug 368603

- warn the user about unsupported lldb version
- reject user command if an unsupported version is found (to prevent crash on invalid message)

diff --git debuggers/common/midebugsession.cpp debuggers/common/midebugsession.cpp
index e771111..bf60e10 100644
--- debuggers/common/midebugsession.cpp
+++ debuggers/common/midebugsession.cpp
@@ -706,14 +706,11 @@ void MIDebugSession::jumpToMemoryAddress(const QString& address)
 
 void MIDebugSession::addUserCommand(const QString& cmd)
 {
-    if (!cmd.isEmpty() && cmd[0].isDigit()) {
-        // Add a space to the begining, so debugger won't get confused if the
-        // command starts with a number (won't mix it up with command token added)
-        queueCmd(new UserCommand(MI::NonMI, " " + cmd));
-    } else {
-        queueCmd(new UserCommand(MI::NonMI, cmd));
-    }
+    auto usercmd = createUserCommand(cmd);
+    if (!usercmd)
+        return;
 
+    queueCmd(usercmd);
     // User command can theoreticall modify absolutely everything,
     // so need to force a reload.
 
@@ -724,6 +721,19 @@ void MIDebugSession::addUserCommand(const QString& cmd)
         raiseEvent(program_state_changed);
 }
 
+MICommand *MIDebugSession::createUserCommand(const QString &cmd) const
+{
+    MICommand *res = nullptr;
+    if (!cmd.isEmpty() && cmd[0].isDigit()) {
+        // Add a space to the begining, so debugger won't get confused if the
+        // command starts with a number (won't mix it up with command token added)
+        res = new UserCommand(MI::NonMI, " " + cmd);
+    } else {
+        res = new UserCommand(MI::NonMI, cmd);
+    }
+    return res;
+}
+
 MICommand *MIDebugSession::createCommand(CommandType type, const QString& arguments,
                                          CommandFlags flags) const
 {
diff --git debuggers/common/midebugsession.h debuggers/common/midebugsession.h
index 9fe0967..bf17c0c 100644
--- debuggers/common/midebugsession.h
+++ debuggers/common/midebugsession.h
@@ -66,61 +66,61 @@ Q_SIGNALS:
     /**
      * Emits when received standard output lines from inferior
      */
-    void inferiorStdoutLines(const QStringList &lines);
+    void inferiorStdoutLines(const QStringList &lines) const;
 
     /**
      * Emits when received standard error lines from inferior
      */
-    void inferiorStderrLines(const QStringList &lines);
+    void inferiorStderrLines(const QStringList &lines) const;
 
-    void inferiorStopped(const MI::AsyncRecord &r);
+    void inferiorStopped(const MI::AsyncRecord &r) const;
 
-    void inferiorRunning();
+    void inferiorRunning() const;
 
     /**
      * Emits when received standard output from debugger for user commands
      */
-    void debuggerUserCommandOutput(const QString &output);
+    void debuggerUserCommandOutput(const QString &output) const;
 
     /**
      * Emits when received standard output from debugger for internal commands
      */
-    void debuggerInternalCommandOutput(const QString &output);
+    void debuggerInternalCommandOutput(const QString &output) const;
 
     /**
      * Emits when received internal output from debugger
      */
-    void debuggerInternalOutput(const QString &output);
+    void debuggerInternalOutput(const QString &output) const;
 
     /**
      * Emits when received standard output from inferior's tty
      */
-    void inferiorTtyStdout(const QByteArray &output);
+    void inferiorTtyStdout(const QByteArray &output) const;
 
     /**
      * Emits when received standard output from inferior's tty
      */
-    void inferiorTtyStderr(const QByteArray &output);
+    void inferiorTtyStderr(const QByteArray &output) const;
 
     /**
      * Emits when the debugger instance state changes
      */
-    void debuggerStateChanged(DBGStateFlags oldState, DBGStateFlags newState);
+    void debuggerStateChanged(DBGStateFlags oldState, DBGStateFlags newState) const;
 
     /**
      * Emits when there's message needed to be show to user.
      */
-    void showMessage(const QString& message, int timeout);
+    void showMessage(const QString& message, int timeout) const;
 
     /**
      * Emits when the debugger console view need to be raised.
      */
-    void raiseDebuggerConsoleViews();
+    void raiseDebuggerConsoleViews() const;
 
     /**
      * Emits when need to reset
      */
-    void reset();
+    void reset() const;
 
 public:
     bool debuggerStateIsOn(DBGStateFlags state) const;
@@ -189,11 +189,12 @@ public Q_SLOTS:
 public:
     virtual MI::MICommand *createCommand(MI::CommandType type, const QString& arguments,
                                          MI::CommandFlags flags = 0) const;
+    virtual MI::MICommand *createUserCommand(const QString &cmd) const;
     /** Adds a command to the end of queue of commands to be executed
-        by gdb. The command will be actually sent to gdb only when
+        by debugger. The command will be actually sent to debugger only when
         replies from all previous commands are received and full processed.
 
-        The literal command sent to gdb is obtained by calling
+        The literal command sent to debugger is obtained by calling
         cmd->cmdToSend. The call is made immediately before sending the
         command, so it's possible to use results of prior commands when
         computing the exact command to send.
diff --git debuggers/lldb/debugsession.cpp debuggers/lldb/debugsession.cpp
index 448d3ea..691ec64 100644
--- debuggers/lldb/debugsession.cpp
+++ debuggers/lldb/debugsession.cpp
@@ -103,6 +103,8 @@ DebugSession::DebugSession(LldbDebuggerPlugin *plugin)
     , m_breakpointController(nullptr)
     , m_variableController(nullptr)
     , m_frameStackModel(nullptr)
+    , m_formatterPath()
+    , m_hasCorrectCLIOutput(false)
 {
     m_breakpointController = new BreakpointController(this);
     m_variableController = new VariableController(this);
@@ -144,6 +146,16 @@ MICommand *DebugSession::createCommand(MI::CommandType type, const QString& argu
     return new LldbCommand(type, arguments, flags);
 }
 
+MICommand *DebugSession::createUserCommand(const QString& cmd) const
+{
+    if (m_hasCorrectCLIOutput)
+        return MIDebugSession::createUserCommand(cmd);
+    auto msg = i18n("Attempting to execute user command on unsupported lldb version");
+    emit debuggerInternalOutput(msg);
+    qCDebug(DEBUGGERLLDB) << "Attempting user command on unsupported lldb version";
+    return nullptr;
+}
+
 void DebugSession::setFormatterPath(const QString &path)
 {
     m_formatterPath = path;
@@ -381,9 +393,40 @@ void DebugSession::handleCoreFile(const QStringList &s)
 
 void DebugSession::handleVersion(const QStringList& s)
 {
+    m_hasCorrectCLIOutput = !s.isEmpty();
+    if (!m_hasCorrectCLIOutput) {
+        // No output from 'version' command. It's likely that
+        // the lldb used is not patched for the CLI output
+
+        if (!qobject_cast<QGuiApplication*>(qApp))  {
+            //for unittest
+            qFatal("You need a graphical application.");
+        }
+
+        auto ans = KMessageBox::warningYesNo(
+            qApp->activeWindow(),
+            i18n("<b>Your lldb-mi version is unsupported, as it lacks an essential patch.</b><br/>"
+                 "See https://llvm.org/bugs/show_bug.cgi?id=28026 for more information.<br/>"
+                 "Debugger console will be disabled to prevent crash.<br/>"
+                 "Do you want to continue?"),
+            i18n("LLDB Version Unsupported"),
+            KStandardGuiItem::yes(),
+            KStandardGuiItem::no(),
+            "unsupported-lldb-debugger");
+        if (ans == KMessageBox::ButtonCode::No) {
+            programFinished("Stopped because of unsupported LLDB version");
+            stopDebugger();
+        }
+        return;
+    }
+
     qCDebug(DEBUGGERLLDB) << s.first();
 
+#ifdef Q_OS_OSX
+    QRegularExpression rx("^lldb-(\\d+).(\\d+).(\\d+)\\b", QRegularExpression::MultilineOption);
+#else
     QRegularExpression rx("^lldb version: (\\d+).(\\d+).(\\d+)\\b", QRegularExpression::MultilineOption);
+#endif
     auto match = rx.match(s.first());
     int version[] = {0, 0, 0};
     if (match.hasMatch()) {
@@ -394,7 +437,12 @@ void DebugSession::handleVersion(const QStringList& s)
 
     // minimal version is 3.8.1
     bool ok = true;
+#ifdef Q_OS_OSX
+    // lldb 3.8.1 reports version 350.99.0 on OS X
+    const int min_ver[] = {350, 99, 0};
+#else
     const int min_ver[] = {3, 8, 1};
+#endif
     for (int i = 0; i < 3; ++i) {
         if (version[i] < min_ver[i]) {
             ok = false;
diff --git debuggers/lldb/debugsession.h debuggers/lldb/debugsession.h
index f44e4a1..58e5e4f 100644
--- debuggers/lldb/debugsession.h
+++ debuggers/lldb/debugsession.h
@@ -56,6 +56,7 @@ public:
 
     MI::MICommand *createCommand(MI::CommandType type, const QString &arguments,
                                  MI::CommandFlags flags) const override;
+    MI::MICommand *createUserCommand(const QString & cmd) const override;
 
     void updateAllVariables();
 
@@ -95,6 +96,7 @@ private:
     LldbFrameStackModel *m_frameStackModel;
 
     QString m_formatterPath;
+    bool m_hasCorrectCLIOutput;
 };
 
 } // end of namespace GDB
-- 
2.9.3

