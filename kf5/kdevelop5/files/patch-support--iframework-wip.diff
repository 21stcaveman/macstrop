diff --git projectmanagers/cmake/cmakeimportjsonjob.cpp projectmanagers/cmake/cmakeimportjsonjob.cpp
index f064647..50ed3b4 100644
--- projectmanagers/cmake/cmakeimportjsonjob.cpp
+++ projectmanagers/cmake/cmakeimportjsonjob.cpp
@@ -86,6 +86,7 @@ CMakeJsonData importCommands(const Path& commandsFile)
 
         CMakeFile ret;
         ret.includes = result.paths;
+        ret.frameworkDirectories = result.frameworkDirectories;
         ret.defines = result.defines;
         // NOTE: we use the canonical file path to prevent issues with symlinks in the path
         //       leading to lookup failures
diff --git projectmanagers/cmake/cmakemanager.cpp projectmanagers/cmake/cmakemanager.cpp
index 5c15e2f..717dabe 100644
--- projectmanagers/cmake/cmakemanager.cpp
+++ projectmanagers/cmake/cmakemanager.cpp
@@ -124,7 +124,7 @@ CMakeManager::~CMakeManager()
     parseLock()->unlock();
 }
 
-bool CMakeManager::hasIncludesOrDefines(ProjectBaseItem* item) const
+bool CMakeManager::hasBuildInfo(ProjectBaseItem* item) const
 {
     return m_projects[item->project()].jsonData.files.contains(item->path());
 }
@@ -234,6 +234,11 @@ Path::List CMakeManager::includeDirectories(KDevelop::ProjectBaseItem *item) con
     return fileInformation(item).includes;
 }
 
+Path::List CMakeManager::frameworkDirectories(KDevelop::ProjectBaseItem *item) const
+{
+    return fileInformation(item).frameworkDirectories;
+}
+
 QHash<QString, QString> CMakeManager::defines(KDevelop::ProjectBaseItem *item ) const
 {
     return fileInformation(item).defines;
diff --git projectmanagers/cmake/cmakemanager.h projectmanagers/cmake/cmakemanager.h
index 3096b7d..0a6571e 100644
--- projectmanagers/cmake/cmakemanager.h
+++ projectmanagers/cmake/cmakemanager.h
@@ -86,9 +86,10 @@ public:
 
     Features features() const override { return Features(Folders | Targets | Files ); }
     KDevelop::IProjectBuilder* builder() const override;
-    bool hasIncludesOrDefines(KDevelop::ProjectBaseItem*) const override;
+    bool hasBuildInfo(KDevelop::ProjectBaseItem*) const override;
     KDevelop::Path buildDirectory(KDevelop::ProjectBaseItem*) const override;
     KDevelop::Path::List includeDirectories(KDevelop::ProjectBaseItem *) const override;
+    KDevelop::Path::List frameworkDirectories(KDevelop::ProjectBaseItem *item) const override;
     QHash<QString, QString> defines(KDevelop::ProjectBaseItem *) const override;
 
     KDevelop::ProjectTargetItem* createTarget( const QString&, KDevelop::ProjectFolderItem* ) override { return 0; }
diff --git projectmanagers/cmake/cmakeprojectdata.h projectmanagers/cmake/cmakeprojectdata.h
index 60e8773..af48678 100644
--- projectmanagers/cmake/cmakeprojectdata.h
+++ projectmanagers/cmake/cmakeprojectdata.h
@@ -36,6 +36,7 @@
 struct CMakeFile
 {
     KDevelop::Path::List includes;
+    KDevelop::Path::List frameworkDirectories;
     QHash<QString, QString> defines;
 };
 inline QDebug &operator<<(QDebug debug, const CMakeFile& file)
diff --git projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp
index b04647e..a445ce8 100644
--- projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp
+++ projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp
@@ -66,7 +66,7 @@ bool CustomBuildSystem::addFilesToTarget( const QList<ProjectFileItem*>&, Projec
     return false;
 }
 
-bool CustomBuildSystem::hasIncludesOrDefines( ProjectBaseItem* ) const
+bool CustomBuildSystem::hasBuildInfo( ProjectBaseItem* ) const
 {
     return false;
 }
@@ -144,6 +144,11 @@ Path::List CustomBuildSystem::includeDirectories( ProjectBaseItem* ) const
     return {};
 }
 
+Path::List CustomBuildSystem::frameworkDirectories( ProjectBaseItem* ) const
+{
+    return {};
+}
+
 KJob* CustomBuildSystem::install( KDevelop::ProjectBaseItem* item, const QUrl &installPrefix )
 {
     auto job = new CustomBuildJob( this, item, CustomBuildSystemTool::Install );
diff --git projectmanagers/custom-buildsystem/custombuildsystemplugin.h projectmanagers/custom-buildsystem/custombuildsystemplugin.h
index 372b283..832f1c0 100644
--- projectmanagers/custom-buildsystem/custombuildsystemplugin.h
+++ projectmanagers/custom-buildsystem/custombuildsystemplugin.h
@@ -70,12 +70,13 @@ public:
 // BuildSystemManager API
 public:
     bool addFilesToTarget( const QList<KDevelop::ProjectFileItem*>& file, KDevelop::ProjectTargetItem* parent ) override;
-    bool hasIncludesOrDefines( KDevelop::ProjectBaseItem* ) const override;
+    bool hasBuildInfo( KDevelop::ProjectBaseItem* ) const override;
     KDevelop::Path buildDirectory( KDevelop::ProjectBaseItem* ) const override;
     IProjectBuilder* builder() const override;
     KDevelop::ProjectTargetItem* createTarget( const QString& target, KDevelop::ProjectFolderItem* parent ) override;
     QHash<QString, QString> defines( KDevelop::ProjectBaseItem* ) const override;
     KDevelop::Path::List includeDirectories( KDevelop::ProjectBaseItem* ) const override;
+    KDevelop::Path::List frameworkDirectories( KDevelop::ProjectBaseItem* ) const override;
     bool removeFilesFromTargets( const QList<KDevelop::ProjectFileItem*>& ) override;
     bool removeTarget( KDevelop::ProjectTargetItem* target ) override;
     QList<KDevelop::ProjectTargetItem*> targets( KDevelop::ProjectFolderItem* ) const override;
diff --git projectmanagers/custommake/custommakemanager.cpp projectmanagers/custommake/custommakemanager.cpp
index e2ce943..682099c 100644
--- projectmanagers/custommake/custommakemanager.cpp
+++ projectmanagers/custommake/custommakemanager.cpp
@@ -62,7 +62,7 @@ public:
         return {};
     }
 
-    Path::List includesInBackground(const QString& path) const override
+    Path::List resolvePathInBackground(const QString& path, const bool isFrameworks) const
     {
         {
             QReadLocker lock(&m_lock);
@@ -77,7 +77,21 @@ public:
             }
         }
 
-        return m_resolver->resolveIncludePath(path).paths;
+        if (isFrameworks) {
+            return m_resolver->resolveIncludePath(path).frameworkDirectories;
+        } else {
+            return m_resolver->resolveIncludePath(path).paths;
+        }
+    }
+
+    Path::List includesInBackground(const QString& path) const override
+    {
+        return resolvePathInBackground(path, false);
+    }
+
+    Path::List frameworkDirectoriesInBackground(const QString& path) const override
+    {
+        return resolvePathInBackground(path, true);
     }
 
     IDefinesAndIncludesManager::Type type() const override
@@ -137,6 +151,11 @@ Path::List CustomMakeManager::includeDirectories(KDevelop::ProjectBaseItem*) con
     return Path::List();
 }
 
+Path::List CustomMakeManager::frameworkDirectories(KDevelop::ProjectBaseItem*) const
+{
+    return Path::List();
+}
+
 QHash<QString,QString> CustomMakeManager::defines(KDevelop::ProjectBaseItem*) const
 {
     return QHash<QString,QString>();
@@ -168,7 +187,7 @@ bool CustomMakeManager::removeFilesFromTargets(const QList< ProjectFileItem* > &
     return false;
 }
 
-bool CustomMakeManager::hasIncludesOrDefines(KDevelop::ProjectBaseItem* item) const
+bool CustomMakeManager::hasBuildInfo(KDevelop::ProjectBaseItem* item) const
 {
     Q_UNUSED(item);
     return false;
diff --git projectmanagers/custommake/custommakemanager.h projectmanagers/custommake/custommakemanager.h
index 33c2997..1648b01 100644
--- projectmanagers/custommake/custommakemanager.h
+++ projectmanagers/custommake/custommakemanager.h
@@ -46,6 +46,11 @@ public:
     KDevelop::Path::List includeDirectories(KDevelop::ProjectBaseItem*) const override;
 
     /**
+     * Provide a list of framework directories.
+     */
+    KDevelop::Path::List frameworkDirectories(KDevelop::ProjectBaseItem*) const override;
+
+    /**
      * Provide a list of files that contain the preprocessor defines for the
      * project
      */
@@ -88,7 +93,7 @@ public:
     /**
      * Test if @p item has any includes or defines from this BSM
      */
-    bool hasIncludesOrDefines(KDevelop::ProjectBaseItem* item) const override;
+    bool hasBuildInfo(KDevelop::ProjectBaseItem* item) const override;
 
     /**
      * Get the toplevel build directory for the project
diff --git projectmanagers/custommake/makefileresolver/makefileresolver.cpp projectmanagers/custommake/makefileresolver/makefileresolver.cpp
index 97973d4..704f601 100644
--- projectmanagers/custommake/makefileresolver/makefileresolver.cpp
+++ projectmanagers/custommake/makefileresolver/makefileresolver.cpp
@@ -66,6 +66,7 @@ namespace {
     { }
     ModificationRevisionSet modificationTime;
     Path::List paths;
+    Path::List frameworkDirectories;
     QHash<QString, QString> defines;
     QString errorMessage, longErrorMessage;
     bool failed;
@@ -248,12 +249,18 @@ namespace {
       bool m_shouldTouchFiles;
   };
 
-void PathResolutionResult::mergeWith(const PathResolutionResult& rhs)
+static void mergePaths(KDevelop::Path::List& destList, const KDevelop::Path::List& srcList)
 {
-    foreach(const Path& path, rhs.paths) {
-        if(!paths.contains(path))
-            paths.append(path);
+    foreach (const Path& path, srcList) {
+        if (!destList.contains(path))
+            destList.append(path);
     }
+}
+
+void PathResolutionResult::mergeWith(const PathResolutionResult& rhs)
+{
+    mergePaths(paths, rhs.paths);
+    mergePaths(frameworkDirectories, rhs.frameworkDirectories);
     includePathDependency += rhs.includePathDependency;
     defines.unite(rhs.defines);
 }
@@ -397,7 +404,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
       }
     }
 
-    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty())
+    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkDirectories.isEmpty())
       return resultOnFail;
     else
       return PathResolutionResult(false, i18n("Makefile is missing in folder \"%1\"", dir.absolutePath()), i18n("Problem while trying to resolve include paths for %1", file));
@@ -406,6 +413,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
   PushValue<bool> e(m_isResolving, true);
 
   Path::List cachedPaths; //If the call doesn't succeed, use the cached not up-to-date version
+  Path::List cachedFWDirs;
   QHash<QString, QString> cachedDefines;
   ModificationRevisionSet dependency;
   dependency.addModificationRevision(IndexedString(makeFile.filePath()), ModificationRevision::revisionForFile(IndexedString(makeFile.filePath())));
@@ -416,12 +424,14 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
     it = s_cache.find(dir.path());
     if (it != s_cache.end()) {
       cachedPaths = it->paths;
+      cachedFWDirs = it->frameworkDirectories;
       cachedDefines = it->defines;
       if (dependency == it->modificationTime) {
         if (!it->failed) {
           //We have a valid cached result
           PathResolutionResult ret(true);
           ret.paths = it->paths;
+          ret.frameworkDirectories = it->frameworkDirectories;
           ret.defines = it->defines;
           ret.mergeWith(resultOnFail);
           return ret;
@@ -432,6 +442,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
             ret.errorMessage = i18n("Cached: %1", it->errorMessage);
             ret.longErrorMessage = it->longErrorMessage;
             ret.paths = it->paths;
+            ret.frameworkDirectories = it->frameworkDirectories;
             ret.defines = it->defines;
             ret.mergeWith(resultOnFail);
             return ret;
@@ -454,7 +465,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 
   int dot;
   if ((dot = file.lastIndexOf('.')) == -1) {
-    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty())
+    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkDirectories.isEmpty())
       return resultOnFail;
     else
       return PathResolutionResult(false, i18n("Filename %1 seems to be malformed", file));
@@ -491,6 +502,10 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
       res.paths = cachedPaths; //We failed, maybe there is an old cached result, use that.
       res.defines = cachedDefines;
   }
+  // a build command could contain only one or more -iframework or -F specifications.
+  if (res.frameworkDirectories.isEmpty()) {
+      res.frameworkDirectories = cachedFWDirs;
+  }
 
   {
     QMutexLocker l(&s_cacheMutex);
@@ -499,6 +514,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 
     CacheEntry& ce(*it);
     ce.paths = res.paths;
+    ce.frameworkDirectories = res.frameworkDirectories;
     ce.modificationTime = dependency;
 
     if (!res) {
@@ -514,7 +530,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
   }
 
 
-  if (!res && (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty()))
+  if (!res && (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkDirectories.isEmpty()))
     return resultOnFail;
 
   return res;
@@ -523,7 +539,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 static QRegularExpression includeRegularExpression()
 {
   static const QRegularExpression expression(
-    "\\s(?:--include-dir=|-I\\s*|-isystem\\s+)("
+    "\\s(--include-dir=|-I\\s*|-isystem\\s+|-iframework\\s+|-F\\s*)("
     "\\'.*\\'|\\\".*\\\"" //Matches "hello", 'hello', 'hello"hallo"', etc.
     "|"
     "((?:\\\\.)?([\\S^\\\\]?))+" //Matches /usr/I\ am\ a\ strange\ path/include
@@ -639,7 +655,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePathInternal(const QString&
   ///STEP 2: Search the output for include-paths
 
   PathResolutionResult ret = processOutput(fullOutput, workingDirectory);
-  if (ret.paths.isEmpty())
+  if (ret.paths.isEmpty() && ret.frameworkDirectories.isEmpty())
     return PathResolutionResult(false, i18n("Could not extract include paths from make output"),
                                 i18n("Folder: \"%1\"  Command: \"%2\"  Output: \"%3\"", workingDirectory,
                                      source.getCommand(file, workingDirectory, makeParameters), fullOutput));
@@ -683,18 +699,25 @@ PathResolutionResult MakeFileResolver::processOutput(const QString& fullOutput,
     auto it = includeRx.globalMatch(fullOutput);
     while (it.hasNext()) {
       const auto match = it.next();
-      QString path = match.captured(1);
+      QString path = match.captured(2);
       if (path.startsWith('"') || (path.startsWith('\'') && path.length() > 2)) {
-        //probable a quoted path
-        if (path.endsWith(path.left(1))) {
-          //Quotation is ok, remove it
-          path = path.mid(1, path.length() - 2);
-        }
+          //probable a quoted path
+          if (path.endsWith(path.left(1))) {
+            //Quotation is ok, remove it
+            path = path.mid(1, path.length() - 2);
+          }
       }
       if (QDir::isRelativePath(path))
         path = workingDirectory + '/' + path;
-
-      ret.paths << internPath(path);
+      const auto& internedPath = internPath(path);
+      const auto& type = match.captured(1);
+      const auto isFramework = type.startsWith(QLatin1String("-iframework"))
+        || type.startsWith(QLatin1String("-F"));
+      if (isFramework) {
+        ret.frameworkDirectories << internedPath;
+      } else {
+        ret.paths << internedPath;
+      }
     }
   }
 
diff --git projectmanagers/custommake/makefileresolver/makefileresolver.h projectmanagers/custommake/makefileresolver/makefileresolver.h
index debe977..b23ceed 100644
--- projectmanagers/custommake/makefileresolver/makefileresolver.h
+++ projectmanagers/custommake/makefileresolver/makefileresolver.h
@@ -40,6 +40,10 @@ struct PathResolutionResult
   KDevelop::ModificationRevisionSet includePathDependency;
 
   KDevelop::Path::List paths;
+  // the list of framework directories specified with explicit -iframework and/or -F arguments.
+  // Mainly for OS X, but available everywhere to avoid #ifdefs and
+  // because clang is an out-of-the-box cross-compiler.
+  KDevelop::Path::List frameworkDirectories;
   QHash<QString, QString> defines;
 
   void mergeWith(const PathResolutionResult& rhs);
diff --git projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
index 368e83e..87799f2 100644
--- projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
+++ projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
@@ -81,6 +81,30 @@ void TestCustomMake::testIncludeDirectories()
     QVERIFY(result.paths.contains(Path("/testFile4")));
 }
 
+void TestCustomMake::testFrameworkDirectories()
+{
+    QTemporaryDir tempDir;
+    int expectedPaths = 2;
+    {
+        QFile file( tempDir.path() + "/Makefile" );
+        createFile( file );
+        QFile testfile( tempDir.path() + "/testfile.cpp" );
+        createFile(testfile);
+        QTextStream stream1( &file );
+        stream1 << "testfile.o:\n\t clang++ testfile.cpp -iframework /System/Library/Frameworks -F/Library/Frameworks -o testfile";
+    }
+
+    MakeFileResolver mf;
+    auto result = mf.resolveIncludePath(tempDir.path() + "/testfile.cpp");
+    if (!result.success) {
+      qDebug() << result.errorMessage << result.longErrorMessage;
+      QFAIL("Failed to resolve include path.");
+    }
+    QCOMPARE(result.frameworkDirectories.size(), expectedPaths);
+    QVERIFY(result.frameworkDirectories.contains(Path("/System/Library/Frameworks")));
+    QVERIFY(result.frameworkDirectories.contains(Path("/Library/Frameworks")));
+}
+
 void TestCustomMake::testDefines()
 {
     MakeFileResolver mf;
diff --git projectmanagers/custommake/makefileresolver/tests/test_custommake.h projectmanagers/custommake/makefileresolver/tests/test_custommake.h
index 3ad0f36..113523a 100644
--- projectmanagers/custommake/makefileresolver/tests/test_custommake.h
+++ projectmanagers/custommake/makefileresolver/tests/test_custommake.h
@@ -32,6 +32,7 @@ private slots:
     void initTestCase();
     void cleanupTestCase();
     void testIncludeDirectories();
+    void testFrameworkDirectories();
     void testDefines();
 };
 
diff --git projectmanagers/qmake/qmakemanager.cpp projectmanagers/qmake/qmakemanager.cpp
index 123b474..2ed766f 100644
--- projectmanagers/qmake/qmakemanager.cpp
+++ projectmanagers/qmake/qmakemanager.cpp
@@ -395,14 +395,15 @@ IProjectBuilder* QMakeProjectManager::builder() const
     return m_builder;
 }
 
-Path::List QMakeProjectManager::includeDirectories(ProjectBaseItem* item) const
+Path::List QMakeProjectManager::collectDirectories(ProjectBaseItem* item, const bool collectIncludes) const
 {
     Path::List list;
     QMakeFolderItem* folder = findQMakeFolderParent(item);
     if (folder) {
         foreach (QMakeProjectFile* pro, folder->projectFiles()) {
             if (pro->files().contains(item->path().toLocalFile())) {
-                foreach (const QString& dir, pro->includeDirectories()) {
+                const QStringList directories = collectIncludes ? pro->includeDirectories() : pro->frameworkDirectories();
+                foreach (const QString& dir, directories) {
                     Path path(dir);
                     if (!list.contains(path)) {
                         list << path;
@@ -413,7 +414,8 @@ Path::List QMakeProjectManager::includeDirectories(ProjectBaseItem* item) const
         if (list.isEmpty()) {
             // fallback for new files, use all possible include dirs
             foreach (QMakeProjectFile* pro, folder->projectFiles()) {
-                foreach (const QString& dir, pro->includeDirectories()) {
+                const QStringList directories = collectIncludes ? pro->includeDirectories() : pro->frameworkDirectories();
+                foreach (const QString& dir, directories) {
                     Path path(dir);
                     if (!list.contains(path)) {
                         list << path;
@@ -430,6 +432,16 @@ Path::List QMakeProjectManager::includeDirectories(ProjectBaseItem* item) const
     return list;
 }
 
+Path::List QMakeProjectManager::includeDirectories(ProjectBaseItem* item) const
+{
+    return collectDirectories(item);
+}
+
+Path::List QMakeProjectManager::frameworkDirectories(ProjectBaseItem* item) const
+{
+    return collectDirectories(item, false);
+}
+
 QHash<QString, QString> QMakeProjectManager::defines(ProjectBaseItem* item) const
 {
     QHash<QString, QString> d;
@@ -446,7 +458,7 @@ QHash<QString, QString> QMakeProjectManager::defines(ProjectBaseItem* item) cons
     return d;
 }
 
-bool QMakeProjectManager::hasIncludesOrDefines(KDevelop::ProjectBaseItem* item) const
+bool QMakeProjectManager::hasBuildInfo(KDevelop::ProjectBaseItem* item) const
 {
     return findQMakeFolderParent(item);
 }
diff --git projectmanagers/qmake/qmakemanager.h projectmanagers/qmake/qmakemanager.h
index e5e3266..690f58c 100644
--- projectmanagers/qmake/qmakemanager.h
+++ projectmanagers/qmake/qmakemanager.h
@@ -28,6 +28,7 @@
 class QMakeFolderItem;
 class IQMakeBuilder;
 class QMakeCache;
+class QMakeProjectFile;
 
 class QMakeProjectManager : public KDevelop::AbstractFileManagerPlugin, public KDevelop::IBuildSystemManager
 {
@@ -55,9 +56,11 @@ public:
     //TODO
     KDevelop::IProjectBuilder*  builder() const override;
     KDevelop::Path buildDirectory(KDevelop::ProjectBaseItem*) const override;
+    KDevelop::Path::List collectDirectories(KDevelop::ProjectBaseItem*, const bool collectIncludes=true) const;
     KDevelop::Path::List includeDirectories(KDevelop::ProjectBaseItem*) const override;
+    KDevelop::Path::List frameworkDirectories(KDevelop::ProjectBaseItem* item) const override;
     QHash<QString,QString> defines(KDevelop::ProjectBaseItem*) const override;
-    bool hasIncludesOrDefines(KDevelop::ProjectBaseItem*) const override;
+    bool hasBuildInfo(KDevelop::ProjectBaseItem*) const override;
 
     KDevelop::ProjectTargetItem* createTarget( const QString&, KDevelop::ProjectFolderItem* ) override
     {
diff --git projectmanagers/qmake/qmakeprojectfile.cpp projectmanagers/qmake/qmakeprojectfile.cpp
index 221eee9..d0e5b2b 100644
--- projectmanagers/qmake/qmakeprojectfile.cpp
+++ projectmanagers/qmake/qmakeprojectfile.cpp
@@ -102,10 +102,11 @@ bool QMakeProjectFile::read()
 
     const QString qtInstallHeaders = QStringLiteral("QT_INSTALL_HEADERS");
     const QString qtVersion = QStringLiteral("QT_VERSION");
+    const QString qtInstallLibs = QStringLiteral("QT_INSTALL_LIBS");
 
     const QString binary = QMakeConfig::qmakeBinary(project());
     if (!m_qmakeQueryCache.contains(binary)) {
-        const auto queryResult = QMakeConfig::queryQMake(binary, {qtInstallHeaders, qtVersion});
+        const auto queryResult = QMakeConfig::queryQMake(binary, {qtInstallHeaders, qtVersion, qtInstallLibs});
         if (queryResult.isEmpty()) {
             qCWarning(KDEV_QMAKE) << "Failed to query qmake - bad qmake binary configured?" << binary;
         }
@@ -115,6 +116,7 @@ bool QMakeProjectFile::read()
     const auto cachedQueryResult = m_qmakeQueryCache.value(binary);
     m_qtIncludeDir = cachedQueryResult.value(qtInstallHeaders);
     m_qtVersion = cachedQueryResult.value(qtVersion);
+    m_qtLibDir = cachedQueryResult.value(qtInstallLibs);
 
     return QMakeFile::read();
 }
@@ -251,6 +253,42 @@ QStringList QMakeProjectFile::includeDirectories() const
     ifDebug(qCDebug(KDEV_QMAKE) << "final list:" << list;) return list;
 }
 
+// Scan QMAKE_C*FLAGS for -F and -iframework and QMAKE_LFLAGS for good measure. Time will
+// tell if we need to scan the release/debug/... specific versions of QMAKE_C*FLAGS.
+// Also include QT_INSTALL_LIBS which corresponds to Qt's framework directory on OS X.
+QStringList QMakeProjectFile::frameworkDirectories() const
+{
+    const auto variablesToCheck = {QStringLiteral("QMAKE_CFLAGS"),
+                                    QStringLiteral("QMAKE_CXXFLAGS"),
+                                    QStringLiteral("QMAKE_LFLAGS")};
+    const QLatin1String fOption("-F");
+    const QLatin1String iframeworkOption("-iframework");
+    QStringList fwDirs;
+    foreach (const auto& var, variablesToCheck) {
+        bool storeArg = false;
+        foreach (const auto& arg, variableValues(var)) {
+            if (arg == fOption || arg == iframeworkOption) {
+                // detached -F/-iframework arg; set a warrant to store the next argument
+                storeArg = true;
+            } else {
+                if (arg.startsWith(fOption)) {
+                    fwDirs << arg.mid(fOption.size());
+                } else if (arg.startsWith(iframeworkOption)) {
+                    fwDirs << arg.mid(iframeworkOption.size());
+                } else if (storeArg) {
+                    fwDirs << arg;
+                }
+                // cancel any outstanding warrants to store the next argument
+                storeArg = false;
+            }
+        }
+    }
+#ifdef Q_OS_OSX
+    fwDirs << m_qtLibDir;
+#endif
+    return fwDirs;
+}
+
 QStringList QMakeProjectFile::files() const
 {
     ifDebug(qCDebug(KDEV_QMAKE) << "Fetching files";)
diff --git projectmanagers/qmake/qmakeprojectfile.h projectmanagers/qmake/qmakeprojectfile.h
index 027800c..d7f493d 100644
--- projectmanagers/qmake/qmakeprojectfile.h
+++ projectmanagers/qmake/qmakeprojectfile.h
@@ -51,6 +51,7 @@ public:
     QStringList files() const;
     QStringList filesForTarget( const QString& ) const;
     QStringList includeDirectories() const;
+    QStringList frameworkDirectories() const;
 
     QStringList targets() const;
 
@@ -80,6 +81,8 @@ private:
     static QHash<QString, QHash<QString, QString> > m_qmakeQueryCache;
     QString m_qtIncludeDir;
     QString m_qtVersion;
+    // On OS X, QT_INSTALL_LIBS is typically a framework directory and should thus be added to the framework search path
+    QString m_qtLibDir;
 };
 
 #endif
diff --git languages/clang/clangparsejob.cpp languages/clang/clangparsejob.cpp
index 8375eb5..655841f 100644
--- languages/clang/clangparsejob.cpp
+++ languages/clang/clangparsejob.cpp
@@ -140,7 +140,7 @@ ProjectFileItem* findProjectFileItem(const IndexedString& url, bool* hasBuildSys
     }
     if (file && file->project()) {
         if (auto bsm = file->project()->buildSystemManager()) {
-            *hasBuildSystemInfo = bsm->hasIncludesOrDefines(file);
+            *hasBuildSystemInfo = bsm->hasBuildInfo(file);
         }
     }
     return file;
@@ -165,10 +165,12 @@ ClangParseJob::ClangParseJob(const IndexedString& url, ILanguageSupport* languag
     bool hasBuildSystemInfo;
     if (auto file = findProjectFileItem(tuUrl, &hasBuildSystemInfo)) {
         m_environment.addIncludes(IDefinesAndIncludesManager::manager()->includes(file));
+        m_environment.addFrameworkDirectories(IDefinesAndIncludesManager::manager()->frameworkDirectories(file));
         m_environment.addDefines(IDefinesAndIncludesManager::manager()->defines(file));
         m_environment.setParserSettings(ClangSettingsManager::self()->parserSettings(file));
     } else {
         m_environment.addIncludes(IDefinesAndIncludesManager::manager()->includes(tuUrl.str()));
+        m_environment.addFrameworkDirectories(IDefinesAndIncludesManager::manager()->frameworkDirectories(tuUrl.str()));
         m_environment.addDefines(IDefinesAndIncludesManager::manager()->defines(tuUrl.str()));
         m_environment.setParserSettings(ClangSettingsManager::self()->parserSettings(tuUrl.str()));
     }
@@ -230,6 +232,7 @@ void ClangParseJob::run(ThreadWeaver::JobPointer /*self*/, ThreadWeaver::Thread*
         }
 
         m_environment.addIncludes(IDefinesAndIncludesManager::manager()->includesInBackground(tuUrlStr));
+        m_environment.addFrameworkDirectories(IDefinesAndIncludesManager::manager()->frameworkDirectoriesInBackground(tuUrlStr));
         m_environment.addDefines(IDefinesAndIncludesManager::manager()->definesInBackground(tuUrlStr));
         m_environment.setPchInclude(userDefinedPchIncludeForFile(tuUrlStr));
     }
diff --git languages/clang/duchain/clangparsingenvironment.cpp languages/clang/duchain/clangparsingenvironment.cpp
index b515037..6b9f00f 100644
--- languages/clang/duchain/clangparsingenvironment.cpp
+++ languages/clang/duchain/clangparsingenvironment.cpp
@@ -43,14 +43,20 @@ void ClangParsingEnvironment::addIncludes(const Path::List& includes)
     m_includes += includes;
 }
 
-ClangParsingEnvironment::IncludePaths ClangParsingEnvironment::includes() const
+void ClangParsingEnvironment::addFrameworkDirectories(const KDevelop::Path::List& frameworkDirectories)
+{
+    m_frameworkDirectories += frameworkDirectories;
+}
+
+template <typename PathType>
+static PathType appendPaths(const KDevelop::Path::List &paths, const KDevelop::Path::List &projectPaths)
 {
-    IncludePaths ret;
-    ret.project.reserve(m_includes.size());
-    ret.system.reserve(m_includes.size());
-    foreach (const auto& path, m_includes) {
+    PathType ret;
+    ret.project.reserve(paths.size());
+    ret.system.reserve(paths.size());
+    foreach (const auto& path, paths) {
         bool inProject = false;
-        foreach (const auto& project, m_projectPaths) {
+        foreach (const auto& project, projectPaths) {
             if (project.isParentOf(path) || project == path) {
                 inProject = true;
                 break;
@@ -65,6 +71,16 @@ ClangParsingEnvironment::IncludePaths ClangParsingEnvironment::includes() const
     return ret;
 }
 
+ClangParsingEnvironment::IncludePaths ClangParsingEnvironment::includes() const
+{
+    return appendPaths<IncludePaths>(m_includes, m_projectPaths);
+}
+
+ClangParsingEnvironment::FrameworkDirectories ClangParsingEnvironment::frameworkDirectories() const
+{
+    return appendPaths<FrameworkDirectories>(m_frameworkDirectories, m_projectPaths);
+}
+
 void ClangParsingEnvironment::addDefines(const QHash<QString, QString>& defines)
 {
     for (auto it = defines.constBegin(); it != defines.constEnd(); ++it) {
@@ -121,6 +137,11 @@ uint ClangParsingEnvironment::hash() const
         hash << qHash(include);
     }
 
+    hash << m_frameworkDirectories.size();
+    for (const auto& fwDir : m_frameworkDirectories) {
+        hash << qHash(fwDir);
+    }
+
     hash << qHash(m_pchInclude);
     hash << qHash(m_parserSettings.parserOptions);
     return hash;
@@ -130,6 +151,7 @@ bool ClangParsingEnvironment::operator==(const ClangParsingEnvironment& other) c
 {
     return m_defines == other.m_defines
         && m_includes == other.m_includes
+        && m_frameworkDirectories == other.m_frameworkDirectories
         && m_pchInclude == other.m_pchInclude
         && m_quality == other.m_quality
         && m_tuUrl == other.m_tuUrl
diff --git languages/clang/duchain/clangparsingenvironment.h languages/clang/duchain/clangparsingenvironment.h
index c689132..ccd5d1e 100644
--- languages/clang/duchain/clangparsingenvironment.h
+++ languages/clang/duchain/clangparsingenvironment.h
@@ -49,6 +49,11 @@ public:
      */
     void addIncludes(const KDevelop::Path::List& includes);
 
+    /**
+     * Add the given list of @p framework-directories to this environment.
+     */
+    void addFrameworkDirectories(const KDevelop::Path::List& frameworkDirectories);
+
     struct IncludePaths
     {
         /// This list contains all include paths outside the known projects paths.
@@ -61,6 +66,18 @@ public:
      */
     IncludePaths includes() const;
 
+    struct FrameworkDirectories
+    {
+        /// This list contains all framework directories outside the known projects paths.
+        KDevelop::Path::List system;
+        /// This list contains all framework directories inside the known projects paths.
+        KDevelop::Path::List project;
+    };
+    /**
+     * Returns the list of framework directories, split into a list of system paths and project paths.
+     */
+    FrameworkDirectories frameworkDirectories() const;
+
     void addDefines(const QHash<QString, QString>& defines);
     QMap<QString, QString> defines() const;
 
@@ -101,6 +118,7 @@ public:
 private:
     KDevelop::Path::List m_projectPaths;
     KDevelop::Path::List m_includes;
+    KDevelop::Path::List m_frameworkDirectories;
     // NOTE: As elements in QHash stored in an unordered sequence, we're using QMap instead
     QMap<QString, QString> m_defines;
     KDevelop::Path m_pchInclude;
diff --git languages/clang/duchain/parsesession.cpp languages/clang/duchain/parsesession.cpp
index aae0661..77cc783 100644
--- languages/clang/duchain/parsesession.cpp
+++ languages/clang/duchain/parsesession.cpp
@@ -118,6 +119,28 @@ void addIncludes(QVector<const char*>* args, QVector<QByteArray>* otherArgs,
     }
 }
 
+void addFrameworkDirectories(QVector<const char*>* args, QVector<QByteArray>* otherArgs,
+                 const Path::List& frameworkDirectories, const char* cliSwitch)
+{
+    foreach (const Path& url, frameworkDirectories) {
+        if (url.isEmpty()) {
+            continue;
+        }
+
+        QFileInfo info(url.toLocalFile());
+        if (!info.isDir()) {
+            qWarning() << "supposed framework directory is not a directory:" << url.pathOrUrl();
+            continue;
+        }
+        QByteArray path = url.toLocalFile().toUtf8();
+
+        otherArgs->append(cliSwitch);
+        otherArgs->append(path);
+        args->append(cliSwitch);
+        args->append(path.constData());
+    }
+}
+
 QVector<CXUnsavedFile> toClangApi(const QVector<UnsavedFile>& unsavedFiles)
 {
     QVector<CXUnsavedFile> unsaved;
@@ -220,6 +243,10 @@ ParseSessionData::ParseSessionData(const QVector<UnsavedFile>& unsavedFiles, Cla
     addIncludes(&clangArguments, &smartArgs, includes.system, "-isystem");
     addIncludes(&clangArguments, &smartArgs, includes.project, "-I");
 
+    const auto& frameworkDirectories = environment.frameworkDirectories();
+    addFrameworkDirectories(&clangArguments, &smartArgs, frameworkDirectories.system, "-iframework");
+    addFrameworkDirectories(&clangArguments, &smartArgs, frameworkDirectories.project, "-F");
+
     smartArgs << writeDefinesFile(environment.defines());
     clangArguments << "-imacros" << smartArgs.last().constData();
 
diff --git languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp
index 24e532a..aefcd3a 100644
--- languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp
+++ languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp
@@ -152,6 +152,11 @@ Path::List CompilerProvider::includes( ProjectBaseItem* item ) const
     return config.compiler->includes(languageType == Utils::C ? config.parserArguments.cArguments : config.parserArguments.cppArguments);
 }
 
+Path::List CompilerProvider::frameworkDirectories( ProjectBaseItem* item ) const
+{
+    return {};
+}
+
 IDefinesAndIncludesManager::Type CompilerProvider::type() const
 {
     return IDefinesAndIncludesManager::CompilerSpecific;
diff --git languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h
index 7a5184f..a76b592 100644
--- languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h
+++ languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h
@@ -40,6 +40,7 @@ public:
 
     KDevelop::Defines defines( KDevelop::ProjectBaseItem* item ) const override;
     KDevelop::Path::List includes( KDevelop::ProjectBaseItem* item ) const override;
+    KDevelop::Path::List frameworkDirectories( KDevelop::ProjectBaseItem* item ) const override;
     KDevelop::IDefinesAndIncludesManager::Type type() const override;
 
     /// @return current compiler for the @p item
diff --git languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp
index ebceb4d..9ed74e8 100644
--- languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp
+++ languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp
@@ -111,6 +111,10 @@ DefinesAndIncludesManager::DefinesAndIncludesManager( QObject* parent, const QVa
 {
     KDEV_USE_EXTENSION_INTERFACE(IDefinesAndIncludesManager);
     registerProvider(m_settings->provider());
+#ifdef Q_OS_OSX
+    m_defaultFrameworkDirectories += Path(QStringLiteral("/Library/Frameworks"));
+    m_defaultFrameworkDirectories += Path(QStringLiteral("/System/Library/Frameworks"));
+#endif
 }
 
 DefinesAndIncludesManager::~DefinesAndIncludesManager() = default;
@@ -184,6 +188,32 @@ Path::List DefinesAndIncludesManager::includes( ProjectBaseItem* item, Type type
     return includes;
 }
 
+Path::List DefinesAndIncludesManager::frameworkDirectories( ProjectBaseItem* item, Type type ) const
+{
+    Q_ASSERT(QThread::currentThread() == qApp->thread());
+
+    if (!item) {
+        return m_settings->provider()->frameworkDirectories(nullptr);
+    }
+
+    Path::List frameworkDirectories = m_defaultFrameworkDirectories;
+
+    if ( type & ProjectSpecific ) {
+        auto buildManager = item->project()->buildSystemManager();
+        if ( buildManager ) {
+            frameworkDirectories += buildManager->frameworkDirectories(item);
+        }
+    }
+
+    for (auto provider : m_providers) {
+        if (provider->type() & type) {
+            frameworkDirectories += provider->frameworkDirectories(item);
+        }
+    }
+
+    return frameworkDirectories;
+}
+
 bool DefinesAndIncludesManager::unregisterProvider(IDefinesAndIncludesManager::Provider* provider)
 {
     int idx = m_providers.indexOf(provider);
@@ -218,6 +248,11 @@ Path::List DefinesAndIncludesManager::includes(const QString& path) const
            + m_noProjectIPM->includesAndDefines(path).first;
 }
 
+Path::List DefinesAndIncludesManager::frameworkDirectories(const QString& path) const
+{
+    return m_settings->provider()->frameworkDirectories(nullptr);
+}
+
 void DefinesAndIncludesManager::openConfigurationDialog(const QString& pathToFile)
 {
     if (auto project = KDevelop::ICore::self()->projectController()->findProjectForUrl(QUrl::fromLocalFile(pathToFile))) {
@@ -238,6 +273,17 @@ Path::List DefinesAndIncludesManager::includesInBackground(const QString& path)
     return includes;
 }
 
+Path::List DefinesAndIncludesManager::frameworkDirectoriesInBackground(const QString& path) const
+{
+    Path::List fwDirs;
+
+    for (auto provider: m_backgroundProviders) {
+        fwDirs += provider->frameworkDirectoriesInBackground(path);
+    }
+
+    return fwDirs;
+}
+
 Defines DefinesAndIncludesManager::definesInBackground(const QString& path) const
 {
     QHash<QString, QString> defines;
diff --git languages/plugins/custom-definesandincludes/definesandincludesmanager.h languages/plugins/custom-definesandincludes/definesandincludesmanager.h
index 6d0d210..d3b7a57 100644
--- languages/plugins/custom-definesandincludes/definesandincludesmanager.h
+++ languages/plugins/custom-definesandincludes/definesandincludesmanager.h
@@ -49,14 +49,18 @@ public:
     KDevelop::Defines defines( KDevelop::ProjectBaseItem* item, Type type ) const override;
     ///@return list of all custom includes for @p item
     KDevelop::Path::List includes( KDevelop::ProjectBaseItem* item, Type type  ) const override;
+    ///@return list of all custom framework directories for @p item
+    KDevelop::Path::List frameworkDirectories( KDevelop::ProjectBaseItem* item, Type type ) const override;
 
     KDevelop::Defines defines( const QString& path ) const override;
     KDevelop::Path::List includes( const QString& path ) const override;
+    KDevelop::Path::List frameworkDirectories(const QString& path) const override;
 
     void registerProvider( Provider* provider ) override;
     bool unregisterProvider( Provider* provider ) override;
 
     KDevelop::Path::List includesInBackground( const QString& path ) const override;
+    KDevelop::Path::List frameworkDirectoriesInBackground( const QString& path ) const override;
     KDevelop::Defines definesInBackground(const QString& path) const override;
 
     void registerBackgroundProvider(BackgroundProvider* provider) override;
@@ -78,6 +82,7 @@ private:
     QVector<BackgroundProvider*> m_backgroundProviders;
     SettingsManager* m_settings;
     QScopedPointer<NoProjectIncludePathsManager> m_noProjectIPM;
+    KDevelop::Path::List m_defaultFrameworkDirectories;
 };
 
 #endif // CUSTOMDEFINESANDINCLUDESMANAGER_H
diff --git languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h
index 5da71f2..6ee4611 100644
--- languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h
+++ languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h
@@ -72,6 +72,8 @@ public:
 
         virtual Path::List includes( ProjectBaseItem* item ) const = 0;
 
+        virtual Path::List frameworkDirectories( ProjectBaseItem* item ) const = 0;
+
         /// @return the type of i/d this provider provides
         virtual Type type() const = 0;
     };
@@ -90,6 +92,8 @@ public:
 
         virtual Path::List includesInBackground( const QString& path ) const = 0;
 
+        virtual Path::List frameworkDirectoriesInBackground( const QString& path ) const = 0;
+
         virtual Defines definesInBackground( const QString& path ) const = 0;
 
         /// @return the type of i/d this provider provides
@@ -106,6 +110,11 @@ public:
     ///NOTE: call it from the foreground thread only.
     virtual Path::List includes( ProjectBaseItem* item, Type type = All ) const = 0;
 
+    ///@param item project item
+    ///@return list of framework directories for @p item
+    ///NOTE: call it from the foreground thread only.
+    virtual Path::List frameworkDirectories( ProjectBaseItem* item, Type type = All ) const = 0;
+
     ///@param path path to an out-of-project file.
     ///@return list of defines for @p path
     ///NOTE: call it from the foreground thread only.
@@ -116,6 +125,11 @@ public:
     ///NOTE: call it from the foreground thread only.
     virtual Path::List includes( const QString& path ) const = 0;
 
+    ///@param path path to an out-of-project file.
+    ///@return list of framework directories for @p path
+    ///NOTE: call it from the foreground thread only.
+    virtual Path::List frameworkDirectories( const QString& path ) const = 0;
+
     /**
      * Computes include directories in background thread.
      *
@@ -126,6 +140,15 @@ public:
     virtual Path::List includesInBackground( const QString& path ) const = 0;
 
     /**
+     * Computes framework directories in background thread.
+     *
+     * This is especially useful for CustomMake projects.
+     *
+     * Call it from background thread if possible.
+    **/
+    virtual Path::List frameworkDirectoriesInBackground( const QString& path ) const = 0;
+
+    /**
      * Computes defined macros in background thread.
      *
      * Call it from background thread if possible.
