diff --git a/projectmanagers/cmake/cmakeimportjsonjob.cpp b/projectmanagers/cmake/cmakeimportjsonjob.cpp
index f064647..623879c 100644
--- a/projectmanagers/cmake/cmakeimportjsonjob.cpp
+++ b/projectmanagers/cmake/cmakeimportjsonjob.cpp
@@ -86,6 +86,7 @@ CMakeJsonData importCommands(const Path& commandsFile)
 
         CMakeFile ret;
         ret.includes = result.paths;
+        ret.frameworkPaths = result.frameworkPaths;
         ret.defines = result.defines;
         // NOTE: we use the canonical file path to prevent issues with symlinks in the path
         //       leading to lookup failures
diff --git a/projectmanagers/cmake/cmakemanager.cpp b/projectmanagers/cmake/cmakemanager.cpp
index 5c15e2f..c9a2ec4 100644
--- a/projectmanagers/cmake/cmakemanager.cpp
+++ b/projectmanagers/cmake/cmakemanager.cpp
@@ -124,6 +124,8 @@ CMakeManager::~CMakeManager()
     parseLock()->unlock();
 }
 
+// TODO? should there be an equivalent hasFrameworkDirectories() method, or should
+// this method return true when an item has a frameworkDir specification? Works with either...
 bool CMakeManager::hasIncludesOrDefines(ProjectBaseItem* item) const
 {
     return m_projects[item->project()].jsonData.files.contains(item->path());
@@ -234,6 +236,11 @@ Path::List CMakeManager::includeDirectories(KDevelop::ProjectBaseItem *item) con
     return fileInformation(item).includes;
 }
 
+Path::List CMakeManager::frameworkDirectories(KDevelop::ProjectBaseItem *item) const
+{
+    return fileInformation(item).frameworkPaths;
+}
+
 QHash<QString, QString> CMakeManager::defines(KDevelop::ProjectBaseItem *item ) const
 {
     return fileInformation(item).defines;
diff --git a/projectmanagers/cmake/cmakemanager.h b/projectmanagers/cmake/cmakemanager.h
index 3096b7d..c1c6cdb 100644
--- a/projectmanagers/cmake/cmakemanager.h
+++ b/projectmanagers/cmake/cmakemanager.h
@@ -89,6 +89,7 @@ public:
     bool hasIncludesOrDefines(KDevelop::ProjectBaseItem*) const override;
     KDevelop::Path buildDirectory(KDevelop::ProjectBaseItem*) const override;
     KDevelop::Path::List includeDirectories(KDevelop::ProjectBaseItem *) const override;
+    KDevelop::Path::List frameworkDirectories(KDevelop::ProjectBaseItem *item) const override;
     QHash<QString, QString> defines(KDevelop::ProjectBaseItem *) const override;
 
     KDevelop::ProjectTargetItem* createTarget( const QString&, KDevelop::ProjectFolderItem* ) override { return 0; }
diff --git a/projectmanagers/cmake/cmakeprojectdata.h b/projectmanagers/cmake/cmakeprojectdata.h
index 60e8773..754456d 100644
--- a/projectmanagers/cmake/cmakeprojectdata.h
+++ b/projectmanagers/cmake/cmakeprojectdata.h
@@ -36,6 +36,7 @@
 struct CMakeFile
 {
     KDevelop::Path::List includes;
+    KDevelop::Path::List frameworkPaths;
     QHash<QString, QString> defines;
 };
 inline QDebug &operator<<(QDebug debug, const CMakeFile& file)
diff --git a/projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp b/projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp
index b04647e..bb2083b 100644
--- a/projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp
+++ b/projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp
@@ -144,6 +144,11 @@ Path::List CustomBuildSystem::includeDirectories( ProjectBaseItem* ) const
     return {};
 }
 
+Path::List CustomBuildSystem::frameworkDirectories( ProjectBaseItem* ) const
+{
+    return {};
+}
+
 KJob* CustomBuildSystem::install( KDevelop::ProjectBaseItem* item, const QUrl &installPrefix )
 {
     auto job = new CustomBuildJob( this, item, CustomBuildSystemTool::Install );
diff --git a/projectmanagers/custom-buildsystem/custombuildsystemplugin.h b/projectmanagers/custom-buildsystem/custombuildsystemplugin.h
index 372b283..c5478c5 100644
--- a/projectmanagers/custom-buildsystem/custombuildsystemplugin.h
+++ b/projectmanagers/custom-buildsystem/custombuildsystemplugin.h
@@ -76,6 +76,7 @@ public:
     KDevelop::ProjectTargetItem* createTarget( const QString& target, KDevelop::ProjectFolderItem* parent ) override;
     QHash<QString, QString> defines( KDevelop::ProjectBaseItem* ) const override;
     KDevelop::Path::List includeDirectories( KDevelop::ProjectBaseItem* ) const override;
+    KDevelop::Path::List frameworkDirectories( KDevelop::ProjectBaseItem* ) const override;
     bool removeFilesFromTargets( const QList<KDevelop::ProjectFileItem*>& ) override;
     bool removeTarget( KDevelop::ProjectTargetItem* target ) override;
     QList<KDevelop::ProjectTargetItem*> targets( KDevelop::ProjectFolderItem* ) const override;
diff --git a/projectmanagers/custommake/custommakemanager.cpp b/projectmanagers/custommake/custommakemanager.cpp
index e2ce943..912749a 100644
--- a/projectmanagers/custommake/custommakemanager.cpp
+++ b/projectmanagers/custommake/custommakemanager.cpp
@@ -80,6 +80,24 @@ public:
         return m_resolver->resolveIncludePath(path).paths;
     }
 
+    Path::List frameworkPathsInBackground(const QString& path) const override
+    {
+        {
+            QReadLocker lock(&m_lock);
+
+            bool inProject = std::any_of(m_customMakeManager->m_projectPaths.constBegin(), m_customMakeManager->m_projectPaths.constEnd(), [&path](const QString& projectPath)
+            {
+                return path.startsWith(projectPath);
+            } );
+
+            if (!inProject) {
+                return {};
+            }
+        }
+
+        return m_resolver->resolveIncludePath(path).frameworkPaths;
+    }
+
     IDefinesAndIncludesManager::Type type() const override
     {
         return IDefinesAndIncludesManager::ProjectSpecific;
@@ -137,6 +155,11 @@ Path::List CustomMakeManager::includeDirectories(KDevelop::ProjectBaseItem*) con
     return Path::List();
 }
 
+Path::List CustomMakeManager::frameworkDirectories(KDevelop::ProjectBaseItem*) const
+{
+    return Path::List();
+}
+
 QHash<QString,QString> CustomMakeManager::defines(KDevelop::ProjectBaseItem*) const
 {
     return QHash<QString,QString>();
diff --git a/projectmanagers/custommake/custommakemanager.h b/projectmanagers/custommake/custommakemanager.h
index 33c2997..3afcbf4 100644
--- a/projectmanagers/custommake/custommakemanager.h
+++ b/projectmanagers/custommake/custommakemanager.h
@@ -46,6 +46,11 @@ public:
     KDevelop::Path::List includeDirectories(KDevelop::ProjectBaseItem*) const override;
 
     /**
+     * Provide a list of framework directories.
+     */
+    KDevelop::Path::List frameworkDirectories(KDevelop::ProjectBaseItem*) const override;
+
+    /**
      * Provide a list of files that contain the preprocessor defines for the
      * project
      */
diff --git a/projectmanagers/custommake/makefileresolver/makefileresolver.cpp b/projectmanagers/custommake/makefileresolver/makefileresolver.cpp
index 97973d4..c926cfd 100644
--- a/projectmanagers/custommake/makefileresolver/makefileresolver.cpp
+++ b/projectmanagers/custommake/makefileresolver/makefileresolver.cpp
@@ -66,6 +66,7 @@ namespace {
     { }
     ModificationRevisionSet modificationTime;
     Path::List paths;
+    Path::List frameworkPaths;
     QHash<QString, QString> defines;
     QString errorMessage, longErrorMessage;
     bool failed;
@@ -254,6 +255,10 @@ void PathResolutionResult::mergeWith(const PathResolutionResult& rhs)
         if(!paths.contains(path))
             paths.append(path);
     }
+    foreach(const Path& path, rhs.frameworkPaths) {
+        if(!frameworkPaths.contains(path))
+            frameworkPaths.append(path);
+    }
     includePathDependency += rhs.includePathDependency;
     defines.unite(rhs.defines);
 }
@@ -397,7 +402,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
       }
     }
 
-    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty())
+    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkPaths.isEmpty())
       return resultOnFail;
     else
       return PathResolutionResult(false, i18n("Makefile is missing in folder \"%1\"", dir.absolutePath()), i18n("Problem while trying to resolve include paths for %1", file));
@@ -406,6 +411,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
   PushValue<bool> e(m_isResolving, true);
 
   Path::List cachedPaths; //If the call doesn't succeed, use the cached not up-to-date version
+  Path::List cachedFWDirs;
   QHash<QString, QString> cachedDefines;
   ModificationRevisionSet dependency;
   dependency.addModificationRevision(IndexedString(makeFile.filePath()), ModificationRevision::revisionForFile(IndexedString(makeFile.filePath())));
@@ -416,12 +422,14 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
     it = s_cache.find(dir.path());
     if (it != s_cache.end()) {
       cachedPaths = it->paths;
+      cachedFWDirs = it->frameworkPaths;
       cachedDefines = it->defines;
       if (dependency == it->modificationTime) {
         if (!it->failed) {
           //We have a valid cached result
           PathResolutionResult ret(true);
           ret.paths = it->paths;
+          ret.frameworkPaths = it->frameworkPaths;
           ret.defines = it->defines;
           ret.mergeWith(resultOnFail);
           return ret;
@@ -432,6 +440,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
             ret.errorMessage = i18n("Cached: %1", it->errorMessage);
             ret.longErrorMessage = it->longErrorMessage;
             ret.paths = it->paths;
+            ret.frameworkPaths = it->frameworkPaths;
             ret.defines = it->defines;
             ret.mergeWith(resultOnFail);
             return ret;
@@ -454,7 +463,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 
   int dot;
   if ((dot = file.lastIndexOf('.')) == -1) {
-    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty())
+    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkPaths.isEmpty())
       return resultOnFail;
     else
       return PathResolutionResult(false, i18n("Filename %1 seems to be malformed", file));
@@ -491,6 +500,10 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
       res.paths = cachedPaths; //We failed, maybe there is an old cached result, use that.
       res.defines = cachedDefines;
   }
+  // a build command could contain only one or more -iframework or -F specifications.
+  if (res.frameworkPaths.isEmpty()) {
+      res.frameworkPaths = cachedFWDirs;
+  }
 
   {
     QMutexLocker l(&s_cacheMutex);
@@ -499,6 +512,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 
     CacheEntry& ce(*it);
     ce.paths = res.paths;
+    ce.frameworkPaths = res.frameworkPaths;
     ce.modificationTime = dependency;
 
     if (!res) {
@@ -514,7 +528,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
   }
 
 
-  if (!res && (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty()))
+  if (!res && (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkPaths.isEmpty()))
     return resultOnFail;
 
   return res;
@@ -523,7 +537,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 static QRegularExpression includeRegularExpression()
 {
   static const QRegularExpression expression(
-    "\\s(?:--include-dir=|-I\\s*|-isystem\\s+)("
+    "\\s(--include-dir=|-I\\s*|-isystem\\s+|-iframework\\s+|-F\\s*)("
     "\\'.*\\'|\\\".*\\\"" //Matches "hello", 'hello', 'hello"hallo"', etc.
     "|"
     "((?:\\\\.)?([\\S^\\\\]?))+" //Matches /usr/I\ am\ a\ strange\ path/include
@@ -639,7 +653,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePathInternal(const QString&
   ///STEP 2: Search the output for include-paths
 
   PathResolutionResult ret = processOutput(fullOutput, workingDirectory);
-  if (ret.paths.isEmpty())
+  if (ret.paths.isEmpty() && ret.frameworkPaths.isEmpty())
     return PathResolutionResult(false, i18n("Could not extract include paths from make output"),
                                 i18n("Folder: \"%1\"  Command: \"%2\"  Output: \"%3\"", workingDirectory,
                                      source.getCommand(file, workingDirectory, makeParameters), fullOutput));
@@ -683,18 +697,25 @@ PathResolutionResult MakeFileResolver::processOutput(const QString& fullOutput,
     auto it = includeRx.globalMatch(fullOutput);
     while (it.hasNext()) {
       const auto match = it.next();
-      QString path = match.captured(1);
+      QString path(match.captured(2));
       if (path.startsWith('"') || (path.startsWith('\'') && path.length() > 2)) {
-        //probable a quoted path
-        if (path.endsWith(path.left(1))) {
-          //Quotation is ok, remove it
-          path = path.mid(1, path.length() - 2);
-        }
+          //probable a quoted path
+          if (path.endsWith(path.left(1))) {
+            //Quotation is ok, remove it
+            path = path.mid(1, path.length() - 2);
+          }
       }
       if (QDir::isRelativePath(path))
         path = workingDirectory + '/' + path;
-
-      ret.paths << internPath(path);
+      const auto& internedPath = internPath(path);
+      const auto& type = match.captured(1);
+      const auto isFramework = type.startsWith(QLatin1String("-iframework"))
+        || type.startsWith(QLatin1String("-F"));
+      if (isFramework) {
+        ret.frameworkPaths << internedPath;
+      } else {
+        ret.paths << internedPath;
+      }
     }
   }
 
diff --git a/projectmanagers/custommake/makefileresolver/makefileresolver.h b/projectmanagers/custommake/makefileresolver/makefileresolver.h
index debe977..d030efb 100644
--- a/projectmanagers/custommake/makefileresolver/makefileresolver.h
+++ b/projectmanagers/custommake/makefileresolver/makefileresolver.h
@@ -40,6 +40,10 @@ struct PathResolutionResult
   KDevelop::ModificationRevisionSet includePathDependency;
 
   KDevelop::Path::List paths;
+  // the list of framework directories specified with explicit -iframework and/or -F arguments.
+  // Mainly for OS X, but available everywhere to avoid #ifdefs and
+  // because clang is an out-of-the-box cross-compiler.
+  KDevelop::Path::List frameworkPaths;
   QHash<QString, QString> defines;
 
   void mergeWith(const PathResolutionResult& rhs);
diff --git a/projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp b/projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
index 368e83e..04413ef 100644
--- a/projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
+++ b/projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
@@ -81,6 +81,30 @@ void TestCustomMake::testIncludeDirectories()
     QVERIFY(result.paths.contains(Path("/testFile4")));
 }
 
+void TestCustomMake::testFrameworkDirectories()
+{
+    QTemporaryDir tempDir;
+    int expectedPaths = 2;
+    {
+        QFile file( tempDir.path() + "/Makefile" );
+        createFile( file );
+        QFile testfile( tempDir.path() + "/testfile.cpp" );
+        createFile(testfile);
+        QTextStream stream1( &file );
+        stream1 << "testfile.o:\n\t clang++ testfile.cpp -iframework /System/Library/Frameworks -F/Library/Frameworks -o testfile";
+    }
+
+    MakeFileResolver mf;
+    auto result = mf.resolveIncludePath(tempDir.path() + "/testfile.cpp");
+    if (!result.success) {
+      qDebug() << result.errorMessage << result.longErrorMessage;
+      QFAIL("Failed to resolve include path.");
+    }
+    QCOMPARE(result.frameworkPaths.size(), expectedPaths);
+    QVERIFY(result.frameworkPaths.contains(Path("/System/Library/Frameworks")));
+    QVERIFY(result.frameworkPaths.contains(Path("/Library/Frameworks")));
+}
+
 void TestCustomMake::testDefines()
 {
     MakeFileResolver mf;
diff --git a/projectmanagers/custommake/makefileresolver/tests/test_custommake.h b/projectmanagers/custommake/makefileresolver/tests/test_custommake.h
index 3ad0f36..113523a 100644
--- a/projectmanagers/custommake/makefileresolver/tests/test_custommake.h
+++ b/projectmanagers/custommake/makefileresolver/tests/test_custommake.h
@@ -32,6 +32,7 @@ private slots:
     void initTestCase();
     void cleanupTestCase();
     void testIncludeDirectories();
+    void testFrameworkDirectories();
     void testDefines();
 };
 
diff --git a/projectmanagers/qmake/qmakemanager.cpp b/projectmanagers/qmake/qmakemanager.cpp
index 123b474..9f313bd 100644
--- a/projectmanagers/qmake/qmakemanager.cpp
+++ b/projectmanagers/qmake/qmakemanager.cpp
@@ -430,6 +430,12 @@ Path::List QMakeProjectManager::includeDirectories(ProjectBaseItem* item) const
     return list;
 }
 
+// TODO: investigate QMakeProjectFile::frameworkDirectories()
+Path::List QMakeProjectManager::frameworkDirectories(ProjectBaseItem* item) const
+{
+    return {};
+}
+
 QHash<QString, QString> QMakeProjectManager::defines(ProjectBaseItem* item) const
 {
     QHash<QString, QString> d;
diff --git a/projectmanagers/qmake/qmakemanager.h b/projectmanagers/qmake/qmakemanager.h
index e5e3266..69473ff 100644
--- a/projectmanagers/qmake/qmakemanager.h
+++ b/projectmanagers/qmake/qmakemanager.h
@@ -56,6 +56,7 @@ public:
     KDevelop::IProjectBuilder*  builder() const override;
     KDevelop::Path buildDirectory(KDevelop::ProjectBaseItem*) const override;
     KDevelop::Path::List includeDirectories(KDevelop::ProjectBaseItem*) const override;
+    KDevelop::Path::List frameworkDirectories(KDevelop::ProjectBaseItem* item) const override;
     QHash<QString,QString> defines(KDevelop::ProjectBaseItem*) const override;
     bool hasIncludesOrDefines(KDevelop::ProjectBaseItem*) const override;
 
diff --git a/languages/clang/clangparsejob.cpp b/languages/clang/clangparsejob.cpp
index 8375eb5..d849117 100644
--- a/languages/clang/clangparsejob.cpp
+++ b/languages/clang/clangparsejob.cpp
@@ -165,10 +165,12 @@ ClangParseJob::ClangParseJob(const IndexedString& url, ILanguageSupport* languag
     bool hasBuildSystemInfo;
     if (auto file = findProjectFileItem(tuUrl, &hasBuildSystemInfo)) {
         m_environment.addIncludes(IDefinesAndIncludesManager::manager()->includes(file));
+        m_environment.addFrameworkPaths(IDefinesAndIncludesManager::manager()->frameworkPaths(file));
         m_environment.addDefines(IDefinesAndIncludesManager::manager()->defines(file));
         m_environment.setParserSettings(ClangSettingsManager::self()->parserSettings(file));
     } else {
         m_environment.addIncludes(IDefinesAndIncludesManager::manager()->includes(tuUrl.str()));
+        m_environment.addFrameworkPaths(IDefinesAndIncludesManager::manager()->frameworkPaths(tuUrl.str()));
         m_environment.addDefines(IDefinesAndIncludesManager::manager()->defines(tuUrl.str()));
         m_environment.setParserSettings(ClangSettingsManager::self()->parserSettings(tuUrl.str()));
     }
@@ -230,6 +232,7 @@ void ClangParseJob::run(ThreadWeaver::JobPointer /*self*/, ThreadWeaver::Thread*
         }
 
         m_environment.addIncludes(IDefinesAndIncludesManager::manager()->includesInBackground(tuUrlStr));
+        m_environment.addFrameworkPaths(IDefinesAndIncludesManager::manager()->frameworkPathsInBackground(tuUrlStr));
         m_environment.addDefines(IDefinesAndIncludesManager::manager()->definesInBackground(tuUrlStr));
         m_environment.setPchInclude(userDefinedPchIncludeForFile(tuUrlStr));
     }
diff --git a/languages/clang/duchain/clangparsingenvironment.cpp b/languages/clang/duchain/clangparsingenvironment.cpp
index b515037..7c7e2ca 100644
--- a/languages/clang/duchain/clangparsingenvironment.cpp
+++ b/languages/clang/duchain/clangparsingenvironment.cpp
@@ -23,6 +23,15 @@
 
 using namespace KDevelop;
 
+#ifdef Q_OS_OSX
+ClangParsingEnvironment::ClangParsingEnvironment()
+{
+    m_frameworkPaths.clear();
+    m_frameworkPaths += Path(QString::fromUtf8("/Library/Frameworks"));
+    m_frameworkPaths += Path(QString::fromUtf8("/System/Library/Frameworks"));
+}
+#endif
+
 int ClangParsingEnvironment::type() const
 {
     return CppParsingEnvironment;
@@ -43,6 +52,11 @@ void ClangParsingEnvironment::addIncludes(const Path::List& includes)
     m_includes += includes;
 }
 
+void ClangParsingEnvironment::addFrameworkPaths(const KDevelop::Path::List& frameworkPaths)
+{
+    m_frameworkPaths += frameworkPaths;
+}
+
 ClangParsingEnvironment::IncludePaths ClangParsingEnvironment::includes() const
 {
     IncludePaths ret;
@@ -65,6 +79,28 @@ ClangParsingEnvironment::IncludePaths ClangParsingEnvironment::includes() const
     return ret;
 }
 
+ClangParsingEnvironment::FrameworkPaths ClangParsingEnvironment::frameworkPaths() const
+{
+    FrameworkPaths ret;
+    ret.project.reserve(m_frameworkPaths.size());
+    ret.system.reserve(m_frameworkPaths.size());
+    foreach (const auto& path, m_frameworkPaths) {
+        bool inProject = false;
+        foreach (const auto& project, m_projectPaths) {
+            if (project.isParentOf(path) || project == path) {
+                inProject = true;
+                break;
+            }
+        }
+        if (inProject) {
+            ret.project.append(path);
+        } else {
+            ret.system.append(path);
+        }
+    }
+    return ret;
+}
+
 void ClangParsingEnvironment::addDefines(const QHash<QString, QString>& defines)
 {
     for (auto it = defines.constBegin(); it != defines.constEnd(); ++it) {
diff --git a/languages/clang/duchain/clangparsingenvironment.h b/languages/clang/duchain/clangparsingenvironment.h
index c689132..410df31 100644
--- a/languages/clang/duchain/clangparsingenvironment.h
+++ b/languages/clang/duchain/clangparsingenvironment.h
@@ -32,6 +32,9 @@
 class KDEVCLANGPRIVATE_EXPORT ClangParsingEnvironment : public KDevelop::ParsingEnvironment
 {
 public:
+#ifdef Q_OS_OSX
+    ClangParsingEnvironment();
+#endif
     virtual ~ClangParsingEnvironment() = default;
     virtual int type() const override;
 
@@ -49,6 +52,11 @@ public:
      */
     void addIncludes(const KDevelop::Path::List& includes);
 
+    /**
+     * Add the given list of @p framework-directories to this environment.
+     */
+    void addFrameworkPaths(const KDevelop::Path::List& frameworkPaths);
+
     struct IncludePaths
     {
         /// This list contains all include paths outside the known projects paths.
@@ -61,6 +69,18 @@ public:
      */
     IncludePaths includes() const;
 
+    struct FrameworkPaths
+    {
+        /// This list contains all framework directories outside the known projects paths.
+        KDevelop::Path::List system;
+        /// This list contains all framework directories inside the known projects paths.
+        KDevelop::Path::List project;
+    };
+    /**
+     * Returns the list of framework directories, split into a list of system paths and project paths.
+     */
+    FrameworkPaths frameworkPaths() const;
+
     void addDefines(const QHash<QString, QString>& defines);
     QMap<QString, QString> defines() const;
 
@@ -101,6 +121,7 @@ public:
 private:
     KDevelop::Path::List m_projectPaths;
     KDevelop::Path::List m_includes;
+    KDevelop::Path::List m_frameworkPaths;
     // NOTE: As elements in QHash stored in an unordered sequence, we're using QMap instead
     QMap<QString, QString> m_defines;
     KDevelop::Path m_pchInclude;
diff --git a/languages/clang/duchain/parsesession.cpp b/languages/clang/duchain/parsesession.cpp
index aae0661..669359b 100644
--- a/languages/clang/duchain/parsesession.cpp
+++ b/languages/clang/duchain/parsesession.cpp
@@ -118,6 +119,28 @@ void addIncludes(QVector<const char*>* args, QVector<QByteArray>* otherArgs,
     }
 }
 
+void addFrameworkPaths(QVector<const char*>* args, QVector<QByteArray>* otherArgs,
+                 const Path::List& frameworkPaths, const char* cliSwitch)
+{
+    foreach (const Path& url, frameworkPaths) {
+        if (url.isEmpty()) {
+            continue;
+        }
+
+        QFileInfo info(url.toLocalFile());
+        QByteArray path = url.toLocalFile().toUtf8();
+
+        if (info.isDir()) {
+            otherArgs->append(cliSwitch);
+            otherArgs->append(path);
+            args->append(cliSwitch);
+            args->append(path.constData());
+        } else {
+            qWarning() << "supposed framework directory is not a directory:" << url.pathOrUrl();
+        }
+    }
+}
+
 QVector<CXUnsavedFile> toClangApi(const QVector<UnsavedFile>& unsavedFiles)
 {
     QVector<CXUnsavedFile> unsaved;
@@ -220,6 +243,10 @@ ParseSessionData::ParseSessionData(const QVector<UnsavedFile>& unsavedFiles, Cla
     addIncludes(&clangArguments, &smartArgs, includes.system, "-isystem");
     addIncludes(&clangArguments, &smartArgs, includes.project, "-I");
 
+    const auto& frameworkPaths = environment.frameworkPaths();
+    addFrameworkPaths(&clangArguments, &smartArgs, frameworkPaths.system, "-iframework");
+    addFrameworkPaths(&clangArguments, &smartArgs, frameworkPaths.project, "-F");
+
     smartArgs << writeDefinesFile(environment.defines());
     clangArguments << "-imacros" << smartArgs.last().constData();
 
diff --git a/languages/plugins/custom-definesandincludes/CMakeLists.txt b/languages/plugins/custom-definesandincludes/CMakeLists.txt
index 5a6c5b7..4f5cb5d 100644
--- a/languages/plugins/custom-definesandincludes/CMakeLists.txt
+++ b/languages/plugins/custom-definesandincludes/CMakeLists.txt
@@ -36,6 +36,7 @@ target_link_libraries( kdevdefinesandincludesmanager LINK_PRIVATE
 option(BUILD_kdev_includepathsconverter "Build utility to modify include paths of a project from command line." ON)
 if(BUILD_kdev_includepathsconverter)
     add_executable(kdev_includepathsconverter includepathsconverter.cpp)
+    ecm_mark_nongui_executable(kdev_includepathsconverter)
     target_link_libraries(kdev_includepathsconverter LINK_PRIVATE
         KDev::Project
         kdevcompilerprovider
diff --git a/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp b/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp
index 24e532a..a172c8e 100644
--- a/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp
+++ b/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp
@@ -152,6 +152,12 @@ Path::List CompilerProvider::includes( ProjectBaseItem* item ) const
     return config.compiler->includes(languageType == Utils::C ? config.parserArguments.cArguments : config.parserArguments.cppArguments);
 }
 
+// TODO : no idea if and what to return here
+Path::List CompilerProvider::frameworkPaths( ProjectBaseItem* item ) const
+{
+    return {};
+}
+
 IDefinesAndIncludesManager::Type CompilerProvider::type() const
 {
     return IDefinesAndIncludesManager::CompilerSpecific;
diff --git a/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h b/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h
index 7a5184f..f1331fa 100644
--- a/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h
+++ b/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h
@@ -40,6 +40,7 @@ public:
 
     KDevelop::Defines defines( KDevelop::ProjectBaseItem* item ) const override;
     KDevelop::Path::List includes( KDevelop::ProjectBaseItem* item ) const override;
+    KDevelop::Path::List frameworkPaths( KDevelop::ProjectBaseItem* item ) const override;
     KDevelop::IDefinesAndIncludesManager::Type type() const override;
 
     /// @return current compiler for the @p item
diff --git a/languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp b/languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp
index ebceb4d..047f3aa 100644
--- a/languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp
+++ b/languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp
@@ -184,6 +184,39 @@ Path::List DefinesAndIncludesManager::includes( ProjectBaseItem* item, Type type
     return includes;
 }
 
+Path::List DefinesAndIncludesManager::frameworkPaths( ProjectBaseItem* item, Type type ) const
+{
+    Q_ASSERT(QThread::currentThread() == qApp->thread());
+
+    if (!item) {
+        return m_settings->provider()->frameworkPaths(nullptr);
+    }
+
+    Path::List frameworkDirectories;
+
+    // TODO?
+//     if (type & UserDefined) {
+//         auto cfg = item->project()->projectConfiguration().data();
+// 
+//         frameworkDirectories += KDevelop::toPathList(findConfigForItem(m_settings->readPaths(cfg), item).frameworkDirectories);
+//     }
+
+    if ( type & ProjectSpecific ) {
+        auto buildManager = item->project()->buildSystemManager();
+        if ( buildManager ) {
+            frameworkDirectories += buildManager->frameworkDirectories(item);
+        }
+    }
+
+    for (auto provider : m_providers) {
+        if (provider->type() & type) {
+            frameworkDirectories += provider->frameworkPaths(item);
+        }
+    }
+
+    return frameworkDirectories;
+}
+
 bool DefinesAndIncludesManager::unregisterProvider(IDefinesAndIncludesManager::Provider* provider)
 {
     int idx = m_providers.indexOf(provider);
@@ -218,6 +251,11 @@ Path::List DefinesAndIncludesManager::includes(const QString& path) const
            + m_noProjectIPM->includesAndDefines(path).first;
 }
 
+Path::List DefinesAndIncludesManager::frameworkPaths(const QString& path) const
+{
+    return m_settings->provider()->frameworkPaths(nullptr);
+}
+
 void DefinesAndIncludesManager::openConfigurationDialog(const QString& pathToFile)
 {
     if (auto project = KDevelop::ICore::self()->projectController()->findProjectForUrl(QUrl::fromLocalFile(pathToFile))) {
@@ -238,6 +276,17 @@ Path::List DefinesAndIncludesManager::includesInBackground(const QString& path)
     return includes;
 }
 
+Path::List DefinesAndIncludesManager::frameworkPathsInBackground(const QString& path) const
+{
+    Path::List fwPaths;
+
+    for (auto provider: m_backgroundProviders) {
+        fwPaths += provider->frameworkPathsInBackground(path);
+    }
+
+    return fwPaths;
+}
+
 Defines DefinesAndIncludesManager::definesInBackground(const QString& path) const
 {
     QHash<QString, QString> defines;
diff --git a/languages/plugins/custom-definesandincludes/definesandincludesmanager.h b/languages/plugins/custom-definesandincludes/definesandincludesmanager.h
index 6d0d210..0d31ee7 100644
--- a/languages/plugins/custom-definesandincludes/definesandincludesmanager.h
+++ b/languages/plugins/custom-definesandincludes/definesandincludesmanager.h
@@ -49,14 +49,18 @@ public:
     KDevelop::Defines defines( KDevelop::ProjectBaseItem* item, Type type ) const override;
     ///@return list of all custom includes for @p item
     KDevelop::Path::List includes( KDevelop::ProjectBaseItem* item, Type type  ) const override;
+    ///@return list of all custom framework directories for @p item
+    KDevelop::Path::List frameworkPaths( KDevelop::ProjectBaseItem* item, Type type ) const override;
 
     KDevelop::Defines defines( const QString& path ) const override;
     KDevelop::Path::List includes( const QString& path ) const override;
+    KDevelop::Path::List frameworkPaths(const QString& path) const override;
 
     void registerProvider( Provider* provider ) override;
     bool unregisterProvider( Provider* provider ) override;
 
     KDevelop::Path::List includesInBackground( const QString& path ) const override;
+    KDevelop::Path::List frameworkPathsInBackground( const QString& path ) const override;
     KDevelop::Defines definesInBackground(const QString& path) const override;
 
     void registerBackgroundProvider(BackgroundProvider* provider) override;
diff --git a/languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h b/languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h
index 5da71f2..875bb44 100644
--- a/languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h
+++ b/languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h
@@ -72,6 +72,8 @@ public:
 
         virtual Path::List includes( ProjectBaseItem* item ) const = 0;
 
+        virtual Path::List frameworkPaths( ProjectBaseItem* item ) const = 0;
+
         /// @return the type of i/d this provider provides
         virtual Type type() const = 0;
     };
@@ -90,6 +92,8 @@ public:
 
         virtual Path::List includesInBackground( const QString& path ) const = 0;
 
+        virtual Path::List frameworkPathsInBackground( const QString& path ) const = 0;
+
         virtual Defines definesInBackground( const QString& path ) const = 0;
 
         /// @return the type of i/d this provider provides
@@ -106,6 +110,11 @@ public:
     ///NOTE: call it from the foreground thread only.
     virtual Path::List includes( ProjectBaseItem* item, Type type = All ) const = 0;
 
+    ///@param item project item
+    ///@return list of framework directories for @p item
+    ///NOTE: call it from the foreground thread only.
+    virtual Path::List frameworkPaths( ProjectBaseItem* item, Type type = All ) const = 0;
+
     ///@param path path to an out-of-project file.
     ///@return list of defines for @p path
     ///NOTE: call it from the foreground thread only.
@@ -116,6 +125,11 @@ public:
     ///NOTE: call it from the foreground thread only.
     virtual Path::List includes( const QString& path ) const = 0;
 
+    ///@param path path to an out-of-project file.
+    ///@return list of framework directories for @p path
+    ///NOTE: call it from the foreground thread only.
+    virtual Path::List frameworkPaths( const QString& path ) const = 0;
+
     /**
      * Computes include directories in background thread.
      *
@@ -126,6 +140,15 @@ public:
     virtual Path::List includesInBackground( const QString& path ) const = 0;
 
     /**
+     * Computes framework directories in background thread.
+     *
+     * This is especially useful for CustomMake projects.
+     *
+     * Call it from background thread if possible.
+    **/
+    virtual Path::List frameworkPathsInBackground( const QString& path ) const = 0;
+
+    /**
      * Computes defined macros in background thread.
      *
      * Call it from background thread if possible.
