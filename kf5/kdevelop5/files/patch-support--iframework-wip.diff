diff --git a/projectmanagers/cmake/cmakeimportjsonjob.cpp b/projectmanagers/cmake/cmakeimportjsonjob.cpp
index f064647..50ed3b4 100644
--- a/projectmanagers/cmake/cmakeimportjsonjob.cpp
+++ b/projectmanagers/cmake/cmakeimportjsonjob.cpp
@@ -86,6 +86,7 @@ CMakeJsonData importCommands(const Path& commandsFile)
 
         CMakeFile ret;
         ret.includes = result.paths;
+        ret.frameworkDirectories = result.frameworkDirectories;
         ret.defines = result.defines;
         // NOTE: we use the canonical file path to prevent issues with symlinks in the path
         //       leading to lookup failures
diff --git a/projectmanagers/cmake/cmakemanager.cpp b/projectmanagers/cmake/cmakemanager.cpp
index 5c15e2f..5d608d2 100644
--- a/projectmanagers/cmake/cmakemanager.cpp
+++ b/projectmanagers/cmake/cmakemanager.cpp
@@ -124,6 +124,8 @@ CMakeManager::~CMakeManager()
     parseLock()->unlock();
 }
 
+// TODO? should there be an equivalent hasFrameworkDirectories() method, or should
+// this method return true when an item has a frameworkDir specification? Works with either...
 bool CMakeManager::hasIncludesOrDefines(ProjectBaseItem* item) const
 {
     return m_projects[item->project()].jsonData.files.contains(item->path());
@@ -234,6 +236,11 @@ Path::List CMakeManager::includeDirectories(KDevelop::ProjectBaseItem *item) con
     return fileInformation(item).includes;
 }
 
+Path::List CMakeManager::frameworkDirectories(KDevelop::ProjectBaseItem *item) const
+{
+    return fileInformation(item).frameworkDirectories;
+}
+
 QHash<QString, QString> CMakeManager::defines(KDevelop::ProjectBaseItem *item ) const
 {
     return fileInformation(item).defines;
diff --git a/projectmanagers/cmake/cmakemanager.h b/projectmanagers/cmake/cmakemanager.h
index 3096b7d..c1c6cdb 100644
--- a/projectmanagers/cmake/cmakemanager.h
+++ b/projectmanagers/cmake/cmakemanager.h
@@ -89,6 +89,7 @@ public:
     bool hasIncludesOrDefines(KDevelop::ProjectBaseItem*) const override;
     KDevelop::Path buildDirectory(KDevelop::ProjectBaseItem*) const override;
     KDevelop::Path::List includeDirectories(KDevelop::ProjectBaseItem *) const override;
+    KDevelop::Path::List frameworkDirectories(KDevelop::ProjectBaseItem *item) const override;
     QHash<QString, QString> defines(KDevelop::ProjectBaseItem *) const override;
 
     KDevelop::ProjectTargetItem* createTarget( const QString&, KDevelop::ProjectFolderItem* ) override { return 0; }
diff --git a/projectmanagers/cmake/cmakeprojectdata.h b/projectmanagers/cmake/cmakeprojectdata.h
index 60e8773..af48678 100644
--- a/projectmanagers/cmake/cmakeprojectdata.h
+++ b/projectmanagers/cmake/cmakeprojectdata.h
@@ -36,6 +36,7 @@
 struct CMakeFile
 {
     KDevelop::Path::List includes;
+    KDevelop::Path::List frameworkDirectories;
     QHash<QString, QString> defines;
 };
 inline QDebug &operator<<(QDebug debug, const CMakeFile& file)
diff --git a/projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp b/projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp
index b04647e..bb2083b 100644
--- a/projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp
+++ b/projectmanagers/custom-buildsystem/custombuildsystemplugin.cpp
@@ -144,6 +144,11 @@ Path::List CustomBuildSystem::includeDirectories( ProjectBaseItem* ) const
     return {};
 }
 
+Path::List CustomBuildSystem::frameworkDirectories( ProjectBaseItem* ) const
+{
+    return {};
+}
+
 KJob* CustomBuildSystem::install( KDevelop::ProjectBaseItem* item, const QUrl &installPrefix )
 {
     auto job = new CustomBuildJob( this, item, CustomBuildSystemTool::Install );
diff --git a/projectmanagers/custom-buildsystem/custombuildsystemplugin.h b/projectmanagers/custom-buildsystem/custombuildsystemplugin.h
index 372b283..c5478c5 100644
--- a/projectmanagers/custom-buildsystem/custombuildsystemplugin.h
+++ b/projectmanagers/custom-buildsystem/custombuildsystemplugin.h
@@ -76,6 +76,7 @@ public:
     KDevelop::ProjectTargetItem* createTarget( const QString& target, KDevelop::ProjectFolderItem* parent ) override;
     QHash<QString, QString> defines( KDevelop::ProjectBaseItem* ) const override;
     KDevelop::Path::List includeDirectories( KDevelop::ProjectBaseItem* ) const override;
+    KDevelop::Path::List frameworkDirectories( KDevelop::ProjectBaseItem* ) const override;
     bool removeFilesFromTargets( const QList<KDevelop::ProjectFileItem*>& ) override;
     bool removeTarget( KDevelop::ProjectTargetItem* target ) override;
     QList<KDevelop::ProjectTargetItem*> targets( KDevelop::ProjectFolderItem* ) const override;
diff --git a/projectmanagers/custommake/custommakemanager.cpp b/projectmanagers/custommake/custommakemanager.cpp
index e2ce943..a0e6c5a 100644
--- a/projectmanagers/custommake/custommakemanager.cpp
+++ b/projectmanagers/custommake/custommakemanager.cpp
@@ -62,7 +62,7 @@ public:
         return {};
     }
 
-    Path::List includesInBackground(const QString& path) const override
+    Path::List resolvePathInBackground(const QString& path, const bool isFrameworks) const
     {
         {
             QReadLocker lock(&m_lock);
@@ -77,7 +77,21 @@ public:
             }
         }
 
-        return m_resolver->resolveIncludePath(path).paths;
+        if (isFrameworks) {
+            return m_resolver->resolveIncludePath(path).frameworkDirectories;
+        } else {
+            return m_resolver->resolveIncludePath(path).paths;
+        }
+    }
+
+    Path::List includesInBackground(const QString& path) const override
+    {
+        return resolvePathInBackground(path, false);
+    }
+
+    Path::List frameworkDirectoriesInBackground(const QString& path) const override
+    {
+        return resolvePathInBackground(path, true);
     }
 
     IDefinesAndIncludesManager::Type type() const override
@@ -137,6 +151,11 @@ Path::List CustomMakeManager::includeDirectories(KDevelop::ProjectBaseItem*) con
     return Path::List();
 }
 
+Path::List CustomMakeManager::frameworkDirectories(KDevelop::ProjectBaseItem*) const
+{
+    return Path::List();
+}
+
 QHash<QString,QString> CustomMakeManager::defines(KDevelop::ProjectBaseItem*) const
 {
     return QHash<QString,QString>();
diff --git a/projectmanagers/custommake/custommakemanager.h b/projectmanagers/custommake/custommakemanager.h
index 33c2997..3afcbf4 100644
--- a/projectmanagers/custommake/custommakemanager.h
+++ b/projectmanagers/custommake/custommakemanager.h
@@ -46,6 +46,11 @@ public:
     KDevelop::Path::List includeDirectories(KDevelop::ProjectBaseItem*) const override;
 
     /**
+     * Provide a list of framework directories.
+     */
+    KDevelop::Path::List frameworkDirectories(KDevelop::ProjectBaseItem*) const override;
+
+    /**
      * Provide a list of files that contain the preprocessor defines for the
      * project
      */
diff --git a/projectmanagers/custommake/makefileresolver/makefileresolver.cpp b/projectmanagers/custommake/makefileresolver/makefileresolver.cpp
index 97973d4..1a16a7e 100644
--- a/projectmanagers/custommake/makefileresolver/makefileresolver.cpp
+++ b/projectmanagers/custommake/makefileresolver/makefileresolver.cpp
@@ -66,6 +66,7 @@ namespace {
     { }
     ModificationRevisionSet modificationTime;
     Path::List paths;
+    Path::List frameworkDirectories;
     QHash<QString, QString> defines;
     QString errorMessage, longErrorMessage;
     bool failed;
@@ -248,12 +249,18 @@ namespace {
       bool m_shouldTouchFiles;
   };
 
-void PathResolutionResult::mergeWith(const PathResolutionResult& rhs)
+static void mergePaths(KDevelop::Path::List& destList, const KDevelop::Path::List& srcList)
 {
-    foreach(const Path& path, rhs.paths) {
-        if(!paths.contains(path))
-            paths.append(path);
+    foreach(const Path& path, srcList) {
+        if(!destList.contains(path))
+            destList.append(path);
     }
+}
+
+void PathResolutionResult::mergeWith(const PathResolutionResult& rhs)
+{
+    mergePaths(paths, rhs.paths);
+    mergePaths(frameworkDirectories, rhs.frameworkDirectories);
     includePathDependency += rhs.includePathDependency;
     defines.unite(rhs.defines);
 }
@@ -397,7 +404,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
       }
     }
 
-    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty())
+    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkDirectories.isEmpty())
       return resultOnFail;
     else
       return PathResolutionResult(false, i18n("Makefile is missing in folder \"%1\"", dir.absolutePath()), i18n("Problem while trying to resolve include paths for %1", file));
@@ -406,6 +413,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
   PushValue<bool> e(m_isResolving, true);
 
   Path::List cachedPaths; //If the call doesn't succeed, use the cached not up-to-date version
+  Path::List cachedFWDirs;
   QHash<QString, QString> cachedDefines;
   ModificationRevisionSet dependency;
   dependency.addModificationRevision(IndexedString(makeFile.filePath()), ModificationRevision::revisionForFile(IndexedString(makeFile.filePath())));
@@ -416,12 +424,14 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
     it = s_cache.find(dir.path());
     if (it != s_cache.end()) {
       cachedPaths = it->paths;
+      cachedFWDirs = it->frameworkDirectories;
       cachedDefines = it->defines;
       if (dependency == it->modificationTime) {
         if (!it->failed) {
           //We have a valid cached result
           PathResolutionResult ret(true);
           ret.paths = it->paths;
+          ret.frameworkDirectories = it->frameworkDirectories;
           ret.defines = it->defines;
           ret.mergeWith(resultOnFail);
           return ret;
@@ -432,6 +442,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
             ret.errorMessage = i18n("Cached: %1", it->errorMessage);
             ret.longErrorMessage = it->longErrorMessage;
             ret.paths = it->paths;
+            ret.frameworkDirectories = it->frameworkDirectories;
             ret.defines = it->defines;
             ret.mergeWith(resultOnFail);
             return ret;
@@ -454,7 +465,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 
   int dot;
   if ((dot = file.lastIndexOf('.')) == -1) {
-    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty())
+    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkDirectories.isEmpty())
       return resultOnFail;
     else
       return PathResolutionResult(false, i18n("Filename %1 seems to be malformed", file));
@@ -491,6 +502,10 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
       res.paths = cachedPaths; //We failed, maybe there is an old cached result, use that.
       res.defines = cachedDefines;
   }
+  // a build command could contain only one or more -iframework or -F specifications.
+  if (res.frameworkDirectories.isEmpty()) {
+      res.frameworkDirectories = cachedFWDirs;
+  }
 
   {
     QMutexLocker l(&s_cacheMutex);
@@ -499,6 +514,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 
     CacheEntry& ce(*it);
     ce.paths = res.paths;
+    ce.frameworkDirectories = res.frameworkDirectories;
     ce.modificationTime = dependency;
 
     if (!res) {
@@ -514,7 +530,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
   }
 
 
-  if (!res && (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty()))
+  if (!res && (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkDirectories.isEmpty()))
     return resultOnFail;
 
   return res;
@@ -523,7 +539,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 static QRegularExpression includeRegularExpression()
 {
   static const QRegularExpression expression(
-    "\\s(?:--include-dir=|-I\\s*|-isystem\\s+)("
+    "\\s(--include-dir=|-I\\s*|-isystem\\s+|-iframework\\s+|-F\\s*)("
     "\\'.*\\'|\\\".*\\\"" //Matches "hello", 'hello', 'hello"hallo"', etc.
     "|"
     "((?:\\\\.)?([\\S^\\\\]?))+" //Matches /usr/I\ am\ a\ strange\ path/include
@@ -639,7 +655,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePathInternal(const QString&
   ///STEP 2: Search the output for include-paths
 
   PathResolutionResult ret = processOutput(fullOutput, workingDirectory);
-  if (ret.paths.isEmpty())
+  if (ret.paths.isEmpty() && ret.frameworkDirectories.isEmpty())
     return PathResolutionResult(false, i18n("Could not extract include paths from make output"),
                                 i18n("Folder: \"%1\"  Command: \"%2\"  Output: \"%3\"", workingDirectory,
                                      source.getCommand(file, workingDirectory, makeParameters), fullOutput));
@@ -683,18 +699,25 @@ PathResolutionResult MakeFileResolver::processOutput(const QString& fullOutput,
     auto it = includeRx.globalMatch(fullOutput);
     while (it.hasNext()) {
       const auto match = it.next();
-      QString path = match.captured(1);
+      QString path(match.captured(2));
       if (path.startsWith('"') || (path.startsWith('\'') && path.length() > 2)) {
-        //probable a quoted path
-        if (path.endsWith(path.left(1))) {
-          //Quotation is ok, remove it
-          path = path.mid(1, path.length() - 2);
-        }
+          //probable a quoted path
+          if (path.endsWith(path.left(1))) {
+            //Quotation is ok, remove it
+            path = path.mid(1, path.length() - 2);
+          }
       }
       if (QDir::isRelativePath(path))
         path = workingDirectory + '/' + path;
-
-      ret.paths << internPath(path);
+      const auto& internedPath = internPath(path);
+      const auto& type = match.captured(1);
+      const auto isFramework = type.startsWith(QLatin1String("-iframework"))
+        || type.startsWith(QLatin1String("-F"));
+      if (isFramework) {
+        ret.frameworkDirectories << internedPath;
+      } else {
+        ret.paths << internedPath;
+      }
     }
   }
 
diff --git a/projectmanagers/custommake/makefileresolver/makefileresolver.h b/projectmanagers/custommake/makefileresolver/makefileresolver.h
index debe977..b23ceed 100644
--- a/projectmanagers/custommake/makefileresolver/makefileresolver.h
+++ b/projectmanagers/custommake/makefileresolver/makefileresolver.h
@@ -40,6 +40,10 @@ struct PathResolutionResult
   KDevelop::ModificationRevisionSet includePathDependency;
 
   KDevelop::Path::List paths;
+  // the list of framework directories specified with explicit -iframework and/or -F arguments.
+  // Mainly for OS X, but available everywhere to avoid #ifdefs and
+  // because clang is an out-of-the-box cross-compiler.
+  KDevelop::Path::List frameworkDirectories;
   QHash<QString, QString> defines;
 
   void mergeWith(const PathResolutionResult& rhs);
diff --git a/projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp b/projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
index 368e83e..87799f2 100644
--- a/projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
+++ b/projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
@@ -81,6 +81,30 @@ void TestCustomMake::testIncludeDirectories()
     QVERIFY(result.paths.contains(Path("/testFile4")));
 }
 
+void TestCustomMake::testFrameworkDirectories()
+{
+    QTemporaryDir tempDir;
+    int expectedPaths = 2;
+    {
+        QFile file( tempDir.path() + "/Makefile" );
+        createFile( file );
+        QFile testfile( tempDir.path() + "/testfile.cpp" );
+        createFile(testfile);
+        QTextStream stream1( &file );
+        stream1 << "testfile.o:\n\t clang++ testfile.cpp -iframework /System/Library/Frameworks -F/Library/Frameworks -o testfile";
+    }
+
+    MakeFileResolver mf;
+    auto result = mf.resolveIncludePath(tempDir.path() + "/testfile.cpp");
+    if (!result.success) {
+      qDebug() << result.errorMessage << result.longErrorMessage;
+      QFAIL("Failed to resolve include path.");
+    }
+    QCOMPARE(result.frameworkDirectories.size(), expectedPaths);
+    QVERIFY(result.frameworkDirectories.contains(Path("/System/Library/Frameworks")));
+    QVERIFY(result.frameworkDirectories.contains(Path("/Library/Frameworks")));
+}
+
 void TestCustomMake::testDefines()
 {
     MakeFileResolver mf;
diff --git a/projectmanagers/custommake/makefileresolver/tests/test_custommake.h b/projectmanagers/custommake/makefileresolver/tests/test_custommake.h
index 3ad0f36..113523a 100644
--- a/projectmanagers/custommake/makefileresolver/tests/test_custommake.h
+++ b/projectmanagers/custommake/makefileresolver/tests/test_custommake.h
@@ -32,6 +32,7 @@ private slots:
     void initTestCase();
     void cleanupTestCase();
     void testIncludeDirectories();
+    void testFrameworkDirectories();
     void testDefines();
 };
 
diff --git a/projectmanagers/qmake/qmakemanager.cpp b/projectmanagers/qmake/qmakemanager.cpp
index 123b474..9f313bd 100644
--- a/projectmanagers/qmake/qmakemanager.cpp
+++ b/projectmanagers/qmake/qmakemanager.cpp
@@ -430,6 +430,12 @@ Path::List QMakeProjectManager::includeDirectories(ProjectBaseItem* item) const
     return list;
 }
 
+// TODO: investigate QMakeProjectFile::frameworkDirectories()
+Path::List QMakeProjectManager::frameworkDirectories(ProjectBaseItem* item) const
+{
+    return {};
+}
+
 QHash<QString, QString> QMakeProjectManager::defines(ProjectBaseItem* item) const
 {
     QHash<QString, QString> d;
diff --git a/projectmanagers/qmake/qmakemanager.h b/projectmanagers/qmake/qmakemanager.h
index e5e3266..69473ff 100644
--- a/projectmanagers/qmake/qmakemanager.h
+++ b/projectmanagers/qmake/qmakemanager.h
@@ -56,6 +56,7 @@ public:
     KDevelop::IProjectBuilder*  builder() const override;
     KDevelop::Path buildDirectory(KDevelop::ProjectBaseItem*) const override;
     KDevelop::Path::List includeDirectories(KDevelop::ProjectBaseItem*) const override;
+    KDevelop::Path::List frameworkDirectories(KDevelop::ProjectBaseItem* item) const override;
     QHash<QString,QString> defines(KDevelop::ProjectBaseItem*) const override;
     bool hasIncludesOrDefines(KDevelop::ProjectBaseItem*) const override;
 
diff --git a/languages/clang/clangparsejob.cpp b/languages/clang/clangparsejob.cpp
index 8375eb5..2c10bfe 100644
--- a/languages/clang/clangparsejob.cpp
+++ b/languages/clang/clangparsejob.cpp
@@ -165,10 +165,12 @@ ClangParseJob::ClangParseJob(const IndexedString& url, ILanguageSupport* languag
     bool hasBuildSystemInfo;
     if (auto file = findProjectFileItem(tuUrl, &hasBuildSystemInfo)) {
         m_environment.addIncludes(IDefinesAndIncludesManager::manager()->includes(file));
+        m_environment.addFrameworkDirectories(IDefinesAndIncludesManager::manager()->frameworkDirectories(file));
         m_environment.addDefines(IDefinesAndIncludesManager::manager()->defines(file));
         m_environment.setParserSettings(ClangSettingsManager::self()->parserSettings(file));
     } else {
         m_environment.addIncludes(IDefinesAndIncludesManager::manager()->includes(tuUrl.str()));
+        m_environment.addFrameworkDirectories(IDefinesAndIncludesManager::manager()->frameworkDirectories(tuUrl.str()));
         m_environment.addDefines(IDefinesAndIncludesManager::manager()->defines(tuUrl.str()));
         m_environment.setParserSettings(ClangSettingsManager::self()->parserSettings(tuUrl.str()));
     }
@@ -230,6 +232,7 @@ void ClangParseJob::run(ThreadWeaver::JobPointer /*self*/, ThreadWeaver::Thread*
         }
 
         m_environment.addIncludes(IDefinesAndIncludesManager::manager()->includesInBackground(tuUrlStr));
+        m_environment.addFrameworkDirectories(IDefinesAndIncludesManager::manager()->frameworkDirectoriesInBackground(tuUrlStr));
         m_environment.addDefines(IDefinesAndIncludesManager::manager()->definesInBackground(tuUrlStr));
         m_environment.setPchInclude(userDefinedPchIncludeForFile(tuUrlStr));
     }
diff --git a/languages/clang/duchain/clangparsingenvironment.cpp b/languages/clang/duchain/clangparsingenvironment.cpp
index b515037..44bf759 100644
--- a/languages/clang/duchain/clangparsingenvironment.cpp
+++ b/languages/clang/duchain/clangparsingenvironment.cpp
@@ -43,14 +43,19 @@ void ClangParsingEnvironment::addIncludes(const Path::List& includes)
     m_includes += includes;
 }
 
-ClangParsingEnvironment::IncludePaths ClangParsingEnvironment::includes() const
+void ClangParsingEnvironment::addFrameworkDirectories(const KDevelop::Path::List& frameworkDirectories)
 {
-    IncludePaths ret;
-    ret.project.reserve(m_includes.size());
-    ret.system.reserve(m_includes.size());
-    foreach (const auto& path, m_includes) {
+    m_frameworkDirectories += frameworkDirectories;
+}
+
+template <typename PathType>
+static void appendPaths(PathType &ret, const KDevelop::Path::List &paths, const KDevelop::Path::List &projectPaths)
+{
+    ret.project.reserve(paths.size());
+    ret.system.reserve(paths.size());
+    foreach (const auto& path, paths) {
         bool inProject = false;
-        foreach (const auto& project, m_projectPaths) {
+        foreach (const auto& project, projectPaths) {
             if (project.isParentOf(path) || project == path) {
                 inProject = true;
                 break;
@@ -62,6 +67,19 @@ ClangParsingEnvironment::IncludePaths ClangParsingEnvironment::includes() const
             ret.system.append(path);
         }
     }
+}
+
+ClangParsingEnvironment::IncludePaths ClangParsingEnvironment::includes() const
+{
+    IncludePaths ret;
+    appendPaths(ret, m_includes, m_projectPaths);
+    return ret;
+}
+
+ClangParsingEnvironment::FrameworkDirectories ClangParsingEnvironment::frameworkDirectories() const
+{
+    FrameworkDirectories ret;
+    appendPaths(ret, m_frameworkDirectories, m_projectPaths);
     return ret;
 }
 
@@ -121,6 +139,11 @@ uint ClangParsingEnvironment::hash() const
         hash << qHash(include);
     }
 
+    hash << m_frameworkDirectories.size();
+    for (const auto& fwDir : m_frameworkDirectories) {
+        hash << qHash(fwDir);
+    }
+
     hash << qHash(m_pchInclude);
     hash << qHash(m_parserSettings.parserOptions);
     return hash;
@@ -130,6 +153,7 @@ bool ClangParsingEnvironment::operator==(const ClangParsingEnvironment& other) c
 {
     return m_defines == other.m_defines
         && m_includes == other.m_includes
+        && m_frameworkDirectories == other.m_frameworkDirectories
         && m_pchInclude == other.m_pchInclude
         && m_quality == other.m_quality
         && m_tuUrl == other.m_tuUrl
diff --git a/languages/clang/duchain/clangparsingenvironment.h b/languages/clang/duchain/clangparsingenvironment.h
index c689132..ccd5d1e 100644
--- a/languages/clang/duchain/clangparsingenvironment.h
+++ b/languages/clang/duchain/clangparsingenvironment.h
@@ -49,6 +49,11 @@ public:
      */
     void addIncludes(const KDevelop::Path::List& includes);
 
+    /**
+     * Add the given list of @p framework-directories to this environment.
+     */
+    void addFrameworkDirectories(const KDevelop::Path::List& frameworkDirectories);
+
     struct IncludePaths
     {
         /// This list contains all include paths outside the known projects paths.
@@ -61,6 +66,18 @@ public:
      */
     IncludePaths includes() const;
 
+    struct FrameworkDirectories
+    {
+        /// This list contains all framework directories outside the known projects paths.
+        KDevelop::Path::List system;
+        /// This list contains all framework directories inside the known projects paths.
+        KDevelop::Path::List project;
+    };
+    /**
+     * Returns the list of framework directories, split into a list of system paths and project paths.
+     */
+    FrameworkDirectories frameworkDirectories() const;
+
     void addDefines(const QHash<QString, QString>& defines);
     QMap<QString, QString> defines() const;
 
@@ -101,6 +118,7 @@ public:
 private:
     KDevelop::Path::List m_projectPaths;
     KDevelop::Path::List m_includes;
+    KDevelop::Path::List m_frameworkDirectories;
     // NOTE: As elements in QHash stored in an unordered sequence, we're using QMap instead
     QMap<QString, QString> m_defines;
     KDevelop::Path m_pchInclude;
diff --git a/languages/clang/duchain/parsesession.cpp b/languages/clang/duchain/parsesession.cpp
index aae0661..75ed2b6 100644
--- a/languages/clang/duchain/parsesession.cpp
+++ b/languages/clang/duchain/parsesession.cpp
@@ -68,7 +68,8 @@ QVector<QByteArray> extraArgs()
 QVector<QByteArray> argsForSession(const QString& path, ParseSessionData::Options options, const ParserSettings& parserSettings)
 {
     QMimeDatabase db;
-    if(db.mimeTypeForFile(path).name() == QStringLiteral("text/x-objcsrc")) {
+    QString mimeType = db.mimeTypeForFile(path).name();
+    if( mimeType == QStringLiteral("text/x-objcsrc") || mimeType == QStringLiteral("text/x-objc++src")) {
         return {QByteArrayLiteral("-xobjective-c++")};
     }
 
@@ -118,6 +119,28 @@ void addIncludes(QVector<const char*>* args, QVector<QByteArray>* otherArgs,
     }
 }
 
+void addFrameworkDirectories(QVector<const char*>* args, QVector<QByteArray>* otherArgs,
+                 const Path::List& frameworkDirectories, const char* cliSwitch)
+{
+    foreach (const Path& url, frameworkDirectories) {
+        if (url.isEmpty()) {
+            continue;
+        }
+
+        QFileInfo info(url.toLocalFile());
+        QByteArray path = url.toLocalFile().toUtf8();
+
+        if (info.isDir()) {
+            otherArgs->append(cliSwitch);
+            otherArgs->append(path);
+            args->append(cliSwitch);
+            args->append(path.constData());
+        } else {
+            qWarning() << "supposed framework directory is not a directory:" << url.pathOrUrl();
+        }
+    }
+}
+
 QVector<CXUnsavedFile> toClangApi(const QVector<UnsavedFile>& unsavedFiles)
 {
     QVector<CXUnsavedFile> unsaved;
@@ -220,6 +243,10 @@ ParseSessionData::ParseSessionData(const QVector<UnsavedFile>& unsavedFiles, Cla
     addIncludes(&clangArguments, &smartArgs, includes.system, "-isystem");
     addIncludes(&clangArguments, &smartArgs, includes.project, "-I");
 
+    const auto& frameworkDirectories = environment.frameworkDirectories();
+    addFrameworkDirectories(&clangArguments, &smartArgs, frameworkDirectories.system, "-iframework");
+    addFrameworkDirectories(&clangArguments, &smartArgs, frameworkDirectories.project, "-F");
+
     smartArgs << writeDefinesFile(environment.defines());
     clangArguments << "-imacros" << smartArgs.last().constData();
 
diff --git a/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp b/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp
index 24e532a..aefcd3a 100644
--- a/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp
+++ b/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.cpp
@@ -152,6 +152,11 @@ Path::List CompilerProvider::includes( ProjectBaseItem* item ) const
     return config.compiler->includes(languageType == Utils::C ? config.parserArguments.cArguments : config.parserArguments.cppArguments);
 }
 
+Path::List CompilerProvider::frameworkDirectories( ProjectBaseItem* item ) const
+{
+    return {};
+}
+
 IDefinesAndIncludesManager::Type CompilerProvider::type() const
 {
     return IDefinesAndIncludesManager::CompilerSpecific;
diff --git a/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h b/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h
index 7a5184f..a76b592 100644
--- a/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h
+++ b/languages/plugins/custom-definesandincludes/compilerprovider/compilerprovider.h
@@ -40,6 +40,7 @@ public:
 
     KDevelop::Defines defines( KDevelop::ProjectBaseItem* item ) const override;
     KDevelop::Path::List includes( KDevelop::ProjectBaseItem* item ) const override;
+    KDevelop::Path::List frameworkDirectories( KDevelop::ProjectBaseItem* item ) const override;
     KDevelop::IDefinesAndIncludesManager::Type type() const override;
 
     /// @return current compiler for the @p item
diff --git a/languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp b/languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp
index ebceb4d..9ed74e8 100644
--- a/languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp
+++ b/languages/plugins/custom-definesandincludes/definesandincludesmanager.cpp
@@ -111,6 +111,10 @@ DefinesAndIncludesManager::DefinesAndIncludesManager( QObject* parent, const QVa
 {
     KDEV_USE_EXTENSION_INTERFACE(IDefinesAndIncludesManager);
     registerProvider(m_settings->provider());
+#ifdef Q_OS_OSX
+    m_defaultFrameworkDirectories += Path(QStringLiteral("/Library/Frameworks"));
+    m_defaultFrameworkDirectories += Path(QStringLiteral("/System/Library/Frameworks"));
+#endif
 }
 
 DefinesAndIncludesManager::~DefinesAndIncludesManager() = default;
@@ -184,6 +188,32 @@ Path::List DefinesAndIncludesManager::includes( ProjectBaseItem* item, Type type
     return includes;
 }
 
+Path::List DefinesAndIncludesManager::frameworkDirectories( ProjectBaseItem* item, Type type ) const
+{
+    Q_ASSERT(QThread::currentThread() == qApp->thread());
+
+    if (!item) {
+        return m_settings->provider()->frameworkDirectories(nullptr);
+    }
+
+    Path::List frameworkDirectories = m_defaultFrameworkDirectories;
+
+    if ( type & ProjectSpecific ) {
+        auto buildManager = item->project()->buildSystemManager();
+        if ( buildManager ) {
+            frameworkDirectories += buildManager->frameworkDirectories(item);
+        }
+    }
+
+    for (auto provider : m_providers) {
+        if (provider->type() & type) {
+            frameworkDirectories += provider->frameworkDirectories(item);
+        }
+    }
+
+    return frameworkDirectories;
+}
+
 bool DefinesAndIncludesManager::unregisterProvider(IDefinesAndIncludesManager::Provider* provider)
 {
     int idx = m_providers.indexOf(provider);
@@ -218,6 +248,11 @@ Path::List DefinesAndIncludesManager::includes(const QString& path) const
            + m_noProjectIPM->includesAndDefines(path).first;
 }
 
+Path::List DefinesAndIncludesManager::frameworkDirectories(const QString& path) const
+{
+    return m_settings->provider()->frameworkDirectories(nullptr);
+}
+
 void DefinesAndIncludesManager::openConfigurationDialog(const QString& pathToFile)
 {
     if (auto project = KDevelop::ICore::self()->projectController()->findProjectForUrl(QUrl::fromLocalFile(pathToFile))) {
@@ -238,6 +273,17 @@ Path::List DefinesAndIncludesManager::includesInBackground(const QString& path)
     return includes;
 }
 
+Path::List DefinesAndIncludesManager::frameworkDirectoriesInBackground(const QString& path) const
+{
+    Path::List fwDirs;
+
+    for (auto provider: m_backgroundProviders) {
+        fwDirs += provider->frameworkDirectoriesInBackground(path);
+    }
+
+    return fwDirs;
+}
+
 Defines DefinesAndIncludesManager::definesInBackground(const QString& path) const
 {
     QHash<QString, QString> defines;
diff --git a/languages/plugins/custom-definesandincludes/definesandincludesmanager.h b/languages/plugins/custom-definesandincludes/definesandincludesmanager.h
index 6d0d210..d3b7a57 100644
--- a/languages/plugins/custom-definesandincludes/definesandincludesmanager.h
+++ b/languages/plugins/custom-definesandincludes/definesandincludesmanager.h
@@ -49,14 +49,18 @@ public:
     KDevelop::Defines defines( KDevelop::ProjectBaseItem* item, Type type ) const override;
     ///@return list of all custom includes for @p item
     KDevelop::Path::List includes( KDevelop::ProjectBaseItem* item, Type type  ) const override;
+    ///@return list of all custom framework directories for @p item
+    KDevelop::Path::List frameworkDirectories( KDevelop::ProjectBaseItem* item, Type type ) const override;
 
     KDevelop::Defines defines( const QString& path ) const override;
     KDevelop::Path::List includes( const QString& path ) const override;
+    KDevelop::Path::List frameworkDirectories(const QString& path) const override;
 
     void registerProvider( Provider* provider ) override;
     bool unregisterProvider( Provider* provider ) override;
 
     KDevelop::Path::List includesInBackground( const QString& path ) const override;
+    KDevelop::Path::List frameworkDirectoriesInBackground( const QString& path ) const override;
     KDevelop::Defines definesInBackground(const QString& path) const override;
 
     void registerBackgroundProvider(BackgroundProvider* provider) override;
@@ -78,6 +82,7 @@ private:
     QVector<BackgroundProvider*> m_backgroundProviders;
     SettingsManager* m_settings;
     QScopedPointer<NoProjectIncludePathsManager> m_noProjectIPM;
+    KDevelop::Path::List m_defaultFrameworkDirectories;
 };
 
 #endif // CUSTOMDEFINESANDINCLUDESMANAGER_H
diff --git a/languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h b/languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h
index 5da71f2..6ee4611 100644
--- a/languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h
+++ b/languages/plugins/custom-definesandincludes/idefinesandincludesmanager.h
@@ -72,6 +72,8 @@ public:
 
         virtual Path::List includes( ProjectBaseItem* item ) const = 0;
 
+        virtual Path::List frameworkDirectories( ProjectBaseItem* item ) const = 0;
+
         /// @return the type of i/d this provider provides
         virtual Type type() const = 0;
     };
@@ -90,6 +92,8 @@ public:
 
         virtual Path::List includesInBackground( const QString& path ) const = 0;
 
+        virtual Path::List frameworkDirectoriesInBackground( const QString& path ) const = 0;
+
         virtual Defines definesInBackground( const QString& path ) const = 0;
 
         /// @return the type of i/d this provider provides
@@ -106,6 +110,11 @@ public:
     ///NOTE: call it from the foreground thread only.
     virtual Path::List includes( ProjectBaseItem* item, Type type = All ) const = 0;
 
+    ///@param item project item
+    ///@return list of framework directories for @p item
+    ///NOTE: call it from the foreground thread only.
+    virtual Path::List frameworkDirectories( ProjectBaseItem* item, Type type = All ) const = 0;
+
     ///@param path path to an out-of-project file.
     ///@return list of defines for @p path
     ///NOTE: call it from the foreground thread only.
@@ -116,6 +125,11 @@ public:
     ///NOTE: call it from the foreground thread only.
     virtual Path::List includes( const QString& path ) const = 0;
 
+    ///@param path path to an out-of-project file.
+    ///@return list of framework directories for @p path
+    ///NOTE: call it from the foreground thread only.
+    virtual Path::List frameworkDirectories( const QString& path ) const = 0;
+
     /**
      * Computes include directories in background thread.
      *
@@ -126,6 +140,15 @@ public:
     virtual Path::List includesInBackground( const QString& path ) const = 0;
 
     /**
+     * Computes framework directories in background thread.
+     *
+     * This is especially useful for CustomMake projects.
+     *
+     * Call it from background thread if possible.
+    **/
+    virtual Path::List frameworkDirectoriesInBackground( const QString& path ) const = 0;
+
+    /**
      * Computes defined macros in background thread.
      *
      * Call it from background thread if possible.
