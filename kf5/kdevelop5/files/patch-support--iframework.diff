diff --git projectmanagers/custommake/makefileresolver/makefileresolver.cpp projectmanagers/custommake/makefileresolver/makefileresolver.cpp
index ab069bb..20fd26e 100644
--- projectmanagers/custommake/makefileresolver/makefileresolver.cpp
+++ projectmanagers/custommake/makefileresolver/makefileresolver.cpp
@@ -66,6 +66,7 @@ namespace {
     { }
     ModificationRevisionSet modificationTime;
     Path::List paths;
+    Path::List frameworkDirs;
     QHash<QString, QString> defines;
     QString errorMessage, longErrorMessage;
     bool failed;
@@ -254,6 +255,10 @@ void PathResolutionResult::mergeWith(const PathResolutionResult& rhs)
         if(!paths.contains(path))
             paths.append(path);
     }
+    foreach(const Path& path, rhs.frameworkDirs) {
+        if(!frameworkDirs.contains(path))
+            frameworkDirs.append(path);
+    }
     includePathDependency += rhs.includePathDependency;
     defines.unite(rhs.defines);
 }
@@ -397,7 +402,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
       }
     }
 
-    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty())
+    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkDirs.isEmpty())
       return resultOnFail;
     else
       return PathResolutionResult(false, i18n("Makefile is missing in folder \"%1\"", dir.absolutePath()), i18n("Problem while trying to resolve include paths for %1", file));
@@ -406,6 +411,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
   PushValue<bool> e(m_isResolving, true);
 
   Path::List cachedPaths; //If the call doesn't succeed, use the cached not up-to-date version
+  Path::List cachedFWDirs;
   QHash<QString, QString> cachedDefines;
   ModificationRevisionSet dependency;
   dependency.addModificationRevision(IndexedString(makeFile.filePath()), ModificationRevision::revisionForFile(IndexedString(makeFile.filePath())));
@@ -416,12 +422,14 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
     it = s_cache.find(dir.path());
     if (it != s_cache.end()) {
       cachedPaths = it->paths;
+      cachedFWDirs = it->frameworkDirs;
       cachedDefines = it->defines;
       if (dependency == it->modificationTime) {
         if (!it->failed) {
           //We have a valid cached result
           PathResolutionResult ret(true);
           ret.paths = it->paths;
+          ret.frameworkDirs = it->frameworkDirs;
           ret.defines = it->defines;
           ret.mergeWith(resultOnFail);
           return ret;
@@ -432,6 +440,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
             ret.errorMessage = i18n("Cached: %1", it->errorMessage);
             ret.longErrorMessage = it->longErrorMessage;
             ret.paths = it->paths;
+            ret.frameworkDirs = it->frameworkDirs;
             ret.defines = it->defines;
             ret.mergeWith(resultOnFail);
             return ret;
@@ -454,7 +463,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 
   int dot;
   if ((dot = file.lastIndexOf('.')) == -1) {
-    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty())
+    if (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkDirs.isEmpty())
       return resultOnFail;
     else
       return PathResolutionResult(false, i18n("Filename %1 seems to be malformed", file));
@@ -491,6 +500,10 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
       res.paths = cachedPaths; //We failed, maybe there is an old cached result, use that.
       res.defines = cachedDefines;
   }
+  // a build command could contain only one or more -iframework or -F specifications.
+  if (res.frameworkDirs.isEmpty()) {
+      res.frameworkDirs = cachedFWDirs;
+  }
 
   {
     QMutexLocker l(&s_cacheMutex);
@@ -499,6 +512,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 
     CacheEntry& ce(*it);
     ce.paths = res.paths;
+    ce.frameworkDirs = res.frameworkDirs;
     ce.modificationTime = dependency;
 
     if (!res) {
@@ -514,7 +528,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
   }
 
 
-  if (!res && (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty()))
+  if (!res && (!resultOnFail.errorMessage.isEmpty() || !resultOnFail.paths.isEmpty() || !resultOnFail.frameworkDirs.isEmpty()))
     return resultOnFail;
 
   return res;
@@ -523,7 +537,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePath(const QString& file, c
 static QRegularExpression includeRegularExpression()
 {
   static const QRegularExpression expression(
-    "\\s(?:--include-dir=|-I\\s*|-isystem\\s+)("
+    "\\s(?:--include-dir=|-I\\s*|-isystem\\s+|-iframework\\s+|-F\\s+)("
     "\\'.*\\'|\\\".*\\\"" //Matches "hello", 'hello', 'hello"hallo"', etc.
     "|"
     "((?:\\\\.)?([\\S^\\\\]?))+" //Matches /usr/I\ am\ a\ strange\ path/include
@@ -639,7 +653,7 @@ PathResolutionResult MakeFileResolver::resolveIncludePathInternal(const QString&
   ///STEP 2: Search the output for include-paths
 
   PathResolutionResult ret = processOutput(fullOutput, workingDirectory);
-  if (ret.paths.isEmpty())
+  if (ret.paths.isEmpty() && ret.frameworkDirs.isEmpty())
     return PathResolutionResult(false, i18n("Could not extract include paths from make output"),
                                 i18n("Folder: \"%1\"  Command: \"%2\"  Output: \"%3\"", workingDirectory,
                                      source.getCommand(file, workingDirectory, makeParameters), fullOutput));
@@ -683,18 +697,36 @@ PathResolutionResult MakeFileResolver::processOutput(const QString& fullOutput,
     auto it = includeRx.globalMatch(fullOutput);
     while (it.hasNext()) {
       const auto match = it.next();
-      QString path = match.captured(1);
-      if (path.startsWith('"') || (path.startsWith('\'') && path.length() > 2)) {
-        //probable a quoted path
-        if (path.endsWith(path.left(1))) {
-          //Quotation is ok, remove it
-          path = path.mid(1, path.length() - 2);
+      QStringList pathList;
+      if (match.captured(0).contains(QLatin1String("-iframework ")) || match.captured(0).contains(QLatin1String("-F "))) {
+        // add the directory regardless of whether it exists
+        ret.frameworkDirs << internPath(match.captured(1));
+        QDir fwDir(match.captured(1));
+        QStringList fwFilter(QString::fromUtf8("*.framework"));
+        QStringList frameworkList(fwDir.entryList(fwFilter));
+        foreach (const auto& p, frameworkList) {
+          QString fwHeaderDir = p + QString::fromUtf8("/Headers");
+          if (fwDir.exists(fwHeaderDir)) {
+            pathList << fwDir.filePath(fwHeaderDir);
+          }
         }
+      } else {
+        pathList << match.captured(1);
       }
-      if (QDir::isRelativePath(path))
-        path = workingDirectory + '/' + path;
+      foreach (const auto& p, pathList) {
+        QString path(p);
+        if (path.startsWith('"') || (path.startsWith('\'') && path.length() > 2)) {
+            //probable a quoted path
+            if (path.endsWith(path.left(1))) {
+            //Quotation is ok, remove it
+            path = path.mid(1, path.length() - 2);
+            }
+        }
+        if (QDir::isRelativePath(path))
+            path = workingDirectory + '/' + path;
 
-      ret.paths << internPath(path);
+        ret.paths << internPath(path);
+      }
     }
   }
 
diff --git projectmanagers/custommake/makefileresolver/makefileresolver.h projectmanagers/custommake/makefileresolver/makefileresolver.h
index 22f9dba..d043624 100644
--- projectmanagers/custommake/makefileresolver/makefileresolver.h
+++ projectmanagers/custommake/makefileresolver/makefileresolver.h
@@ -40,6 +40,9 @@ struct PathResolutionResult
   KDevelop::ModificationRevisionSet includePathDependency;
 
   KDevelop::Path::List paths;
+  // the list of framework directories specified with explicit.
+  // Should be used only on OS X, available everywhere to avoid #ifdefs
+  KDevelop::Path::List frameworkDirs;
   QHash<QString, QString> defines;
 
   void mergeWith(const PathResolutionResult& rhs);
diff --git projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
index 368e83e..9de4cab 100644
--- projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
+++ projectmanagers/custommake/makefileresolver/tests/test_custommake.cpp
@@ -22,9 +22,12 @@
 #include "test_custommake.h"
 
 #include <QFile>
+#include <QDir>
 #include <QTextStream>
 #include <QDebug>
 #include <QTemporaryDir>
+#include <QString>
+#include <QStringList>
 
 #include <tests/autotestshell.h>
 #include <tests/testcore.h>
@@ -59,13 +62,14 @@ void TestCustomMake::cleanupTestCase()
 void TestCustomMake::testIncludeDirectories()
 {
     QTemporaryDir tempDir;
+    int expectedPaths = 6;
     {
         QFile file( tempDir.path() + "/Makefile" );
         createFile( file );
         QFile testfile( tempDir.path() + "/testfile.cpp" );
         createFile(testfile);
         QTextStream stream1( &file );
-        stream1 << "testfile.o:\n\t g++ testfile.cpp -I/testFile1 -I /testFile2 -isystem /testFile3 --include-dir=/testFile4 -o testfile";
+        stream1 << "testfile.o:\n\t g++ testfile.cpp -I/testFile1 -I /testFile2 -isystem /testFile3 -iframework /System/Library/Frameworks -F /Library/Frameworks --include-dir=/testFile4 -o testfile";
     }
 
     MakeFileResolver mf;
@@ -74,11 +78,35 @@ void TestCustomMake::testIncludeDirectories()
       qDebug() << result.errorMessage << result.longErrorMessage;
       QFAIL("Failed to resolve include path.");
     }
-    QCOMPARE(result.paths.size(), 4);
+#ifdef Q_OS_OSX
+    // on OS X we don't know how many frameworks are installed
+    QVERIFY(result.paths.size() >= expectedPaths);
+#else
+    // elsewhere the system framework directories ought to be empty
+    QCOMPARE(result.paths.size(), expectedPaths);
+#endif
     QVERIFY(result.paths.contains(Path("/testFile1")));
     QVERIFY(result.paths.contains(Path("/testFile2")));
     QVERIFY(result.paths.contains(Path("/testFile3")));
     QVERIFY(result.paths.contains(Path("/testFile4")));
+#ifdef Q_OS_OSX
+    // we should at least have found the CoreFoundation framework
+    QVERIFY(result.paths.contains(Path("/System/Library/Frameworks/CoreFoundation.framework/Headers")));
+#endif
+    QVERIFY(result.frameworkDirs.contains(Path("/System/Library/Frameworks")));
+    QVERIFY(result.frameworkDirs.contains(Path("/Library/Frameworks")));
+#ifdef Q_OS_OSX
+    qWarning() << "paths:" << result.paths.size();
+    QStringList pathList, fwDirs;
+    foreach (const auto &p, result.paths) {
+        pathList << p.path();
+    }
+    foreach (const auto &p, result.frameworkDirs) {
+        fwDirs << p.path();
+    }
+    qWarning() << "pathList:" << pathList;
+    qWarning() << "fwDirs:" << fwDirs;
+#endif
 }
 
 void TestCustomMake::testDefines()
