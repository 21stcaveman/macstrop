diff --git serialization/itemrepository.h serialization/itemrepository.h
index a557da6..6f4399b 100644
--- serialization/itemrepository.h
+++ serialization/itemrepository.h
@@ -547,8 +547,20 @@ class Bucket {
         currentIndex = followerIndex(currentIndex);
         //If this assertion triggers, the deleted item was not registered under the given hash
         Q_ASSERT(currentIndex);
+        if (!currentIndex) {
+          qWarning() << Q_FUNC_INFO << "early return because currentIndex==0";
+          return;
+        } else if (currentIndex == previousIndex) {
+          qWarning() << Q_FUNC_INFO << "early return because currentIndex==previousIndex==" << currentIndex;
+          return;
+        }
       }
       Q_ASSERT(currentIndex == index);
+      if (currentIndex != index) {
+        qWarning() << Q_FUNC_INFO << "early return because currentIndex != index ("
+          << currentIndex << "!=" << index;
+        return;
+      }
 
       if(!previousIndex)
         //The item was directly in the object map
@@ -937,13 +949,14 @@ class Bucket {
 
     /// @param index the index of an item @return The index of the next item in the chain of items with a same local hash, or zero
     inline unsigned short followerIndex(unsigned short index) const {
-      Q_ASSERT(index >= 2);
-      return *reinterpret_cast<unsigned short*>(m_data+(index-2));
+//       Q_ASSERT(index >= 2);
+      return (index >= 2) ? *reinterpret_cast<unsigned short*>(m_data+(index-2)) : 0;
     }
 
     void setFollowerIndex(unsigned short index, unsigned short follower) {
-      Q_ASSERT(index >= 2);
-      *reinterpret_cast<unsigned short*>(m_data+(index-2)) = follower;
+//       Q_ASSERT(index >= 2);
+      if (index >= 2)
+        *reinterpret_cast<unsigned short*>(m_data+(index-2)) = follower;
     }
     // Only returns the current value if the item is actually free
     inline unsigned short freeSize(unsigned short index) const {
diff --git language/duchain/duchain.cpp language/duchain/duchain.cpp
index ec801c27b..75f627743 100644
--- language/duchain/duchain.cpp
+++ language/duchain/duchain.cpp
@@ -723,7 +723,7 @@ public:
       //Here we wait for all parsing-threads to stop their processing
       foreach(const auto language, languages) {
         if (lockFlag == TryLock) {
-          if (!language->parseLock()->tryLockForWrite()) {
+          if (!language->parseLock() || !language->parseLock()->tryLockForWrite()) {
             qCDebug(LANGUAGE) << "Aborting cleanup because language plugin is still parsing:" << language->name();
             // some language is still parsing, don't interfere with the cleanup
             foreach(auto* lock, locked) {
@@ -1582,11 +1582,16 @@ static void finalCleanup()
   qCDebug(LANGUAGE) << "doing final cleanup";
 
   int cleaned = 0;
+  int passes = 0;
   while((cleaned = globalItemRepositoryRegistry().finalCleanup())) {
+    passes += 1;
     qCDebug(LANGUAGE) << "cleaned" << cleaned << "B";
     if(cleaned < 1000) {
       qCDebug(LANGUAGE) << "cleaned enough";
       break;
+    } else if (passes >= 100) {
+      qCWarning(LANGUAGE) << "cleaned" << passes << "passes, last was" << cleaned << "B; that's enough";
+      break;
     }
   }
   qCDebug(LANGUAGE) << "final cleanup ready";
