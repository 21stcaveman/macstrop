diff --git a/duchain/contextbuilder.cpp b/duchain/contextbuilder.cpp
index ba32ae6..182e8a6 100644
--- a/duchain/contextbuilder.cpp
+++ b/duchain/contextbuilder.cpp
@@ -63,14 +63,14 @@ ReferencedTopDUContext ContextBuilder::build(const IndexedString& url, Ast* node
         }
     }
     if (updateContext) {
-        qDebug() << " ====> DUCHAIN ====>     rebuilding duchain for" << url.str() << "(was built before)";
+//         qDebug() << " ====> DUCHAIN ====>     rebuilding duchain for" << url.str() << "(was built before)";
         DUChainWriteLocker lock(DUChain::lock());
         Q_ASSERT(updateContext->type() == DUContext::Global);
         updateContext->clearImportedParentContexts();
         updateContext->parsingEnvironmentFile()->clearModificationRevisions();
         updateContext->clearProblems();
     } else {
-        qDebug() << " ====> DUCHAIN ====>     building duchain for" << url.str();
+//         qDebug() << " ====> DUCHAIN ====>     building duchain for" << url.str();
     }
     return ContextBuilderBase::build(url, node, updateContext);
 }
diff --git a/parser/astbuilder.cpp b/parser/astbuilder.cpp
index 5ab027e..f1b4b3e 100644
--- a/parser/astbuilder.cpp
+++ b/parser/astbuilder.cpp
@@ -472,7 +472,7 @@ struct PythonInitializer : private QMutexLocker {
 
 CodeAst::Ptr AstBuilder::parse(const QUrl& filename, QString &contents)
 {
-    qDebug() << " ====> AST     ====>     building abstract syntax tree for " << filename.path();
+//     qDebug() << " ====> AST     ====>     building abstract syntax tree for " << filename.path();
     
     Py_NoSiteFlag = 1;
     
diff --git a/pythonparsejob.cpp b/pythonparsejob.cpp
index e58ea10..9b0cef5 100644
--- a/pythonparsejob.cpp
+++ b/pythonparsejob.cpp
@@ -101,7 +101,7 @@ void ParseJob::run(ThreadWeaver::JobPointer /*self*/, ThreadWeaver::Thread* /*th
         return abortJob();
     }
     
-    qDebug() << " ====> PARSING ====> parsing file " << document().toUrl() << "; has priority" << parsePriority();
+//     qDebug() << " ====> PARSING ====> parsing file " << document().toUrl() << "; has priority" << parsePriority();
 
     {
         QMutexLocker l(&Helper::projectPathLock);
@@ -125,7 +125,7 @@ void ParseJob::run(ThreadWeaver::JobPointer /*self*/, ThreadWeaver::Thread* /*th
                 continue;
             }
             if ( ! file->needsUpdate() && file->featuresSatisfied(minimumFeatures()) && file->topContext() ) {
-                qDebug() << " ====> NOOP    ====> Already up to date:" << document().str();
+//                 qDebug() << " ====> NOOP    ====> Already up to date:" << document().str();
                 setDuChain(file->topContext());
                 if ( ICore::self()->languageController()->backgroundParser()->trackerForUrl(document()) ) {
                     lock.unlock();
@@ -179,7 +179,7 @@ void ParseJob::run(ThreadWeaver::JobPointer /*self*/, ThreadWeaver::Thread* /*th
         
         // check whether any unresolved imports were encountered
         bool needsReparse = ! builder.unresolvedImports().isEmpty();
-        qDebug() << "Document needs update because of unresolved identifiers: " << needsReparse;
+//         qDebug() << "Document needs update because of unresolved identifiers: " << needsReparse;
         if ( needsReparse ) {
             // check whether one of the imports is queued for parsing, this is to avoid deadlocks
             // it's also ok if the duchain is now available (and thus has been parsed before already)
@@ -211,7 +211,7 @@ void ParseJob::run(ThreadWeaver::JobPointer /*self*/, ThreadWeaver::Thread* /*th
             DUChain::self()->updateContextEnvironment(m_duContext, parsingEnvironmentFile.data());
         }
         
-        qDebug() << "---- Parsing Succeeded ----";
+//         qDebug() << "---- Parsing Succeeded ----";
         
         if ( abortRequested() ) {
             return abortJob();
