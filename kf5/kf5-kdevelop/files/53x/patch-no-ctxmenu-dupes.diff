diff --git kdevplatform/shell/textdocument.h kdevplatform/shell/textdocument.h
index 04d12abfca11f276ae475fd02dd873901a95133c..b9c1fdb3f01288224dd792d852c333804f07d757 100644
--- kdevplatform/shell/textdocument.h
+++ kdevplatform/shell/textdocument.h
@@ -85,7 +85,6 @@ private:
     Q_PRIVATE_SLOT(d, void modifiedOnDisk(KTextEditor::Document *, bool, KTextEditor::ModificationInterface::ModifiedOnDiskReason))
 
     void newDocumentStatus(KTextEditor::Document*);
-    void populateContextMenu(KTextEditor::View*, QMenu*);
     void textChanged(KTextEditor::Document*);
     void documentUrlChanged(KTextEditor::Document*);
     void slotDocumentLoaded();
diff --git kdevplatform/shell/textdocument.cpp kdevplatform/shell/textdocument.cpp
index e5f92beee45e5fec5823447d727b34b4069339bd..0aef6b78a4d0d5f1b86866068086b4a099faab49 100644
--- kdevplatform/shell/textdocument.cpp
+++ kdevplatform/shell/textdocument.cpp
@@ -76,22 +76,74 @@ static void selectAndReveal( KTextEditor::View* view, const KTextEditor::Range&
     }
 }
 
+class TextDocumentContextMenuData : public QObject
+{
+    Q_OBJECT
+public:
+    TextDocumentContextMenuData(QObject* parent)
+        : QObject(parent)
+        , addedContextMenu(nullptr)
+    {
+        lastShownMenu.clear();
+    }
+
+    // dtor has to be out-of-line, after 
+    ~TextDocumentContextMenuData();
+
+    void populateContextMenu( KTextEditor::View* v, QMenu* menu )
+    {
+        if (!lastShownMenu.isNull() && addedContextMenu) {
+            qCDebug(SHELL) << "Removing items from previous contextmenu" << lastShownMenu;
+            foreach ( QAction* action, addedContextMenu->actions() ) {
+                lastShownMenu->removeAction(action);
+            }
+        }
+
+        delete addedContextMenu;
+        addedContextMenu = new QMenu();
+
+        EditorContext c(v, v->cursorPosition());
+        auto extensions = Core::self()->pluginController()->queryPluginsForContextMenuExtensions(&c, addedContextMenu);
+
+        ContextMenuExtension::populateMenu(addedContextMenu, extensions);
+
+        foreach ( QAction* action, addedContextMenu->actions() ) {
+            menu->addAction(action);
+        }
+        if (menu != lastShownMenu.data()) {
+            if (lastShownMenuSet) {
+                // don't warn about setting the cache for the 1st time
+                qCWarning(SHELL) << "Added items to new contextmenu" << menu;
+            }
+            lastShownMenu = menu;
+            lastShownMenuSet = true;
+        }
+
+        menu->setTearOffEnabled(true);
+    }
+
+    // we want to remove the previously added stuff before
+    // the menu shows again.
+    // This has to be a static instance because multiple views
+    // can share the same context menu instance.
+    QMenu* addedContextMenu;
+    QPointer<QMenu> lastShownMenu;
+    bool lastShownMenuSet = false;
+};
+
 class TextDocumentPrivate
 {
 public:
-    explicit TextDocumentPrivate(TextDocument *textDocument)
+    explicit TextDocumentPrivate(TextDocument *textDocument, ICore* core)
         : q(textDocument)
     {
+        if (!contextMenuData) {
+            contextMenuData = new TextDocumentContextMenuData(core->uiController()->activeMainWindow());
+        }
     }
 
     ~TextDocumentPrivate()
     {
-        // Handle the case we are being deleted while the context menu is not yet hidden.
-        // We want to remove all actions we added to it, especially those not owned by the document
-        // but by the plugins (i.e. created on-the-fly during ContextMenuExtension::populateMenu
-        // with ownership set to our addedContextMenu)
-        cleanContextMenu();
-
         saveSessionConfig();
         delete document;
     }
@@ -228,42 +280,33 @@ public:
         setStatus(document, dirty);
     }
 
-    void cleanContextMenu()
-    {
-        if (!addedContextMenu) {
-            return;
-        }
-
-        if (currentContextMenu) {
-            const auto actions = addedContextMenu->actions();
-            for (QAction* action : actions) {
-                currentContextMenu->removeAction(action);
-            }
-            currentContextMenu.clear();
-        }
-
-        // The addedContextMenu owns those actions created on-the-fly for the context menu
-        // (other than those actions only shared for the context menu, but also used elsewhere)
-        // and thuse deletes then on its own destruction.
-        // Some actions potentially could be connected to triggered-signal handlers
-        // using Qt::QueuedConnection (at least SwitchToBuddyPlugin does so currently).
-        // Deleting them here also would also delete the connection before the handler is triggered.
-        // So we delay the menu's and thus their destruction to the next eventloop by default.
-        addedContextMenu->deleteLater();
-        addedContextMenu = nullptr;
-    }
-
     TextDocument * const q;
 
     QPointer<KTextEditor::Document> document;
     IDocument::DocumentState state = IDocument::Clean;
     QString encoding;
     bool loaded = false;
-    // we want to remove the added stuff when the menu hides
-    QMenu* addedContextMenu = nullptr;
-    QPointer<QMenu> currentContextMenu;
+    // there is only a single contextmenu at a time so use a single (static)
+    // instance of the class keeping track of added menu actions.
+    static TextDocumentContextMenuData* contextMenuData;
 };
 
+TextDocumentContextMenuData* TextDocumentPrivate::contextMenuData = nullptr;
+
+TextDocumentContextMenuData::~TextDocumentContextMenuData()
+{
+    //qWarning() << Q_FUNC_INFO << parent();
+    // don't assume there will ever be only 1 MainWindow in KDevelop:
+    // (this is why we have to be out-of-line)
+    if (TextDocumentPrivate::contextMenuData == this) {
+        TextDocumentPrivate::contextMenuData = nullptr;
+    }
+    delete addedContextMenu;
+    addedContextMenu = nullptr;
+
+    lastShownMenu.clear();
+}
+
 class TextViewPrivate
 {
 public:
@@ -275,7 +318,7 @@ public:
 };
 
 TextDocument::TextDocument(const QUrl &url, ICore* core, const QString& encoding)
-    :PartDocument(url, core), d(new TextDocumentPrivate(this))
+    :PartDocument(url, core), d(new TextDocumentPrivate(this, core))
 {
     d->encoding = encoding;
 }
@@ -288,7 +331,7 @@ bool TextDocument::isTextDocument() const
     {
         /// @todo Somehow it can happen that d->document is zero, which makes
         /// code relying on "isTextDocument() == (bool)textDocument()" crash
-        qCWarning(SHELL) << "Broken text-document: " << url();
+        qCDebug(SHELL) << "Broken text-document: " << url();
         return false;
     }
 
@@ -374,7 +417,7 @@ QWidget *TextDocument::createViewWidget(QWidget *parent)
 
     view->setStatusBarEnabled(Core::self()->partControllerInternal()->showTextEditorStatusBar());
 
-    connect(view, &KTextEditor::View::contextMenuAboutToShow, this, &TextDocument::populateContextMenu);
+    connect(view, &KTextEditor::View::contextMenuAboutToShow, d->contextMenuData, &TextDocumentContextMenuData::populateContextMenu);
 
     if (KTextEditor::CodeCompletionInterface* cc = dynamic_cast<KTextEditor::CodeCompletionInterface*>(view))
         cc->setAutomaticInvocationEnabled(core()->languageController()->completionSettings()->automaticCompletionEnabled());
@@ -699,37 +742,6 @@ void KDevelop::TextDocument::textChanged(KTextEditor::Document *document)
     notifyContentChanged();
 }
 
-void KDevelop::TextDocument::unpopulateContextMenu()
-{
-    auto* menu = qobject_cast<QMenu*>(sender());
-
-    disconnect(menu, &QMenu::aboutToHide, this, &TextDocument::unpopulateContextMenu);
-
-    d->cleanContextMenu();
-}
-
-void KDevelop::TextDocument::populateContextMenu( KTextEditor::View* v, QMenu* menu )
-{
-    if (d->addedContextMenu) {
-        qCWarning(SHELL) << "populateContextMenu() called while we still handled another menu.";
-        d->cleanContextMenu();
-    }
-
-    d->currentContextMenu = menu;
-    connect(menu, &QMenu::aboutToHide, this, &TextDocument::unpopulateContextMenu);
-
-    d->addedContextMenu = new QMenu();
-
-    EditorContext c(v, v->cursorPosition());
-    auto extensions = Core::self()->pluginController()->queryPluginsForContextMenuExtensions(&c, d->addedContextMenu);
-
-    ContextMenuExtension::populateMenu(d->addedContextMenu, extensions);
-
-    foreach ( QAction* action, d->addedContextMenu->actions() ) {
-        menu->addAction(action);
-    }
-}
-
 void KDevelop::TextDocument::repositoryCheckFinished(bool canRecreate) {
     if ( d->state != IDocument::Dirty && d->state != IDocument::DirtyAndModified ) {
         // document is not dirty for whatever reason, nothing to do.
@@ -776,3 +788,4 @@ void KDevelop::TextDocument::documentUrlChanged(KTextEditor::Document* document)
 }
 
 #include "moc_textdocument.cpp"
+#include "textdocument.moc"
