diff --git kdevplatform/shell/core.cpp kdevplatform/shell/core.cpp
index c1fd662f89cf826baea3247bf90c5348aead7c00..fbe092deddf0eac70fab2ccc97e650bd5f64f4f0 100644
--- kdevplatform/shell/core.cpp
+++ kdevplatform/shell/core.cpp
@@ -21,6 +21,7 @@
 #include "core_p.h"
 
 #include <QApplication>
+#include <QSocketNotifier>
 
 #include <KLocalizedString>
 
@@ -51,13 +52,27 @@
 #include <csignal>
 
 namespace {
-void shutdownGracefully(int sig)
+static KDevelop::CorePrivate *corePrivateInstance = nullptr;
+static int signalPipeRead = -1;
+static int signalPipeWrite = -1;
+static volatile std::sig_atomic_t signalReceived = 0;
+static QSocketNotifier* signalNotifier = nullptr;
+
+void shutdownGracefully()
 {
     static volatile std::sig_atomic_t handlingSignal = 0;
+    int sig = signalReceived;
+
+    signalReceived = 0;
 
-    if ( !handlingSignal ) {
+    // exit as quickly as possible when a SIGHUP is received.
+    if ( !handlingSignal
+#ifdef SIGHUP
+       && sig != SIGHUP
+#endif
+    ) {
         handlingSignal = 1;
-        qCDebug(SHELL) << "signal " << sig << " received, shutting down gracefully";
+        qCWarning(SHELL) << "Going down on signal" << sig;
         QCoreApplication* app = QCoreApplication::instance();
         if (QApplication* guiApp = qobject_cast<QApplication*>(app)) {
             guiApp->closeAllWindows();
@@ -66,22 +81,36 @@ void shutdownGracefully(int sig)
         return;
     }
 
-    // re-raise signal with default handler and trigger program termination
     std::signal(sig, SIG_DFL);
+
+    if (corePrivateInstance->m_core) {
+       // shutdown core functionality, in particular the DUChain subsystem
+       // in an effort to prevent cache corruption. It's only cache, but
+       // regenerating it can be very time-consuming.
+       corePrivateInstance->m_core->shutdown();
+    }
+
+    signalNotifier->setEnabled(false);
+
+    // re-raise signal with default handler and trigger program termination
     std::raise(sig);
 }
 
+void signalHandler(int sig)
+{
+    signalReceived = sig;
+    if (signalPipeWrite != -1) {
+        qCDebug(SHELL) << "signal" << sig << " received, shutting down gracefully";
+        write(signalPipeWrite, &sig, sizeof(sig));
+    }
+}
+
 void installSignalHandler()
 {
-#ifdef SIGHUP
-    std::signal(SIGHUP, shutdownGracefully);
-#endif
-#ifdef SIGINT
-    std::signal(SIGINT, shutdownGracefully);
-#endif
-#ifdef SIGTERM
-    std::signal(SIGTERM, shutdownGracefully);
-#endif
+   std::signal(SIGHUP, signalHandler);
+   std::signal(SIGINT, signalHandler);
+   std::signal(SIGTERM, signalHandler);
+   signalNotifier->setEnabled(true);
 }
 }
 
@@ -121,6 +150,7 @@ KAboutData createAboutData()
 }
 
 CorePrivate::CorePrivate(Core *core):
+    QObject(nullptr),
     m_aboutData( createAboutData() ), m_core(core), m_cleanedUp(false), m_shuttingDown(false)
 {
 }
@@ -289,7 +319,27 @@ bool CorePrivate::initialize(Core::Setup mode, const QString& session )
     testController->initialize();
     runtimeController->initialize();
 
-    installSignalHandler();
+//     A "proper" exit-on-signal approach:
+//     Open a pipe or an eventfd, then install your signal handler. In that signal
+//     handler, write anything to the writing end or write uint64_t(1) the eventfd.
+//     Create a QSocketNotifier on the reading end of the pipe or on the eventfd,
+//     connect its activation signal to a slot that does what you want.
+
+#ifdef Q_OS_UNIX
+    if (!corePrivateInstance) {
+        int pp[2];
+        if (pipe(pp)) {
+            qCWarning(SHELL) << "Error opening signal handler pipe" << strerror(errno);
+        } else {
+            signalPipeRead = pp[0];
+            signalPipeWrite = pp[1];
+            signalNotifier = new QSocketNotifier(signalPipeRead, QSocketNotifier::Read, this);
+            connect(signalNotifier, &QSocketNotifier::activated, this, &CorePrivate::shutdownGracefully);
+            installSignalHandler();
+        }
+        corePrivateInstance = this;
+    }
+#endif
 
     qCDebug(SHELL) << "Done initializing controllers";
 
@@ -328,8 +378,23 @@ CorePrivate::~CorePrivate()
     workingSetController.clear();
     testController.clear();
     runtimeController.clear();
+
+#ifdef USE_QSOCKETNOTIFIER
+    if (signalPipeWrite != -1) {
+        close(signalPipeWrite);
+    }
+    if (signalPipeRead != -1) {
+        close(signalPipeRead);
+    }
+#endif
 }
 
+void CorePrivate::shutdownGracefully()
+{
+   ::shutdownGracefully();
+}
+
+
 bool Core::initialize(Setup mode, const QString& session)
 {
     if (m_self)
@@ -604,4 +669,3 @@ QString Core::version()
 }
 
 }
-
diff --git kdevplatform/shell/core_p.h kdevplatform/shell/core_p.h
index d5ed3525cc9114642a2e18301bb98f60c0e0e98f..f621dbad214455ea09059d2af33745b235ae4652 100644
--- kdevplatform/shell/core_p.h
+++ kdevplatform/shell/core_p.h
@@ -47,11 +47,15 @@ class WorkingSetController;
 class TestController;
 class RuntimeController;
 
-class KDEVPLATFORMSHELL_EXPORT CorePrivate {
+class KDEVPLATFORMSHELL_EXPORT CorePrivate : public QObject {
+    Q_OBJECT
+
 public:
     explicit CorePrivate(Core *core);
     ~CorePrivate();
     bool initialize( Core::Setup mode, const QString& session );
+    void shutdownGracefully();
+
     QPointer<PluginController> pluginController;
     QPointer<UiController> uiController;
     QPointer<ProjectController> projectController;
