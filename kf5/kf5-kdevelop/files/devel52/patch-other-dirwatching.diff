diff --git a/kdevplatform/project/CMakeLists.txt b/kdevplatform/project/CMakeLists.txt
index c61e8de32e80c29a648766fe88c62b78f5561c36..d8b14d82407b1ec5a886d2fbd60dd77bd8bceb33 100644
--- a/kdevplatform/project/CMakeLists.txt
+++ b/kdevplatform/project/CMakeLists.txt
@@ -15,6 +15,7 @@ set(KDevPlatformProject_LIB_SRCS
     abstractfilemanagerplugin.cpp
     filemanagerlistjob.cpp
     projectfiltermanager.cpp
+    projectwatcher.cpp
     interfaces/iprojectbuilder.cpp
     interfaces/iprojectfilemanager.cpp
     interfaces/ibuildsystemmanager.cpp
diff --git a/kdevplatform/project/abstractfilemanagerplugin.cpp b/kdevplatform/project/abstractfilemanagerplugin.cpp
index 5ad558fc7fba026736bcc721539ecf51af5a7e00..9abc41b230b61ae934d80b9b9e6535611142ef99 100644
--- a/kdevplatform/project/abstractfilemanagerplugin.cpp
+++ b/kdevplatform/project/abstractfilemanagerplugin.cpp
@@ -1,3 +1,4 @@
+#define TIME_IMPORT_JOB
 /***************************************************************************
  *   This file is part of KDevelop                                         *
  *   Copyright 2010-2012 Milian Wolff <mail@milianw.de>                    *
@@ -27,6 +28,9 @@
 #include <QHashIterator>
 #include <QFileInfo>
 #include <QApplication>
+#ifdef TIME_IMPORT_JOB
+#include <QElapsedTimer>
+#endif
 
 #include <KMessageBox>
 #include <KLocalizedString>
@@ -38,6 +42,7 @@
 #include <serialization/indexedstring.h>
 
 #include "projectfiltermanager.h"
+#include "projectwatcher.h"
 #include "debug.h"
 
 #define ifDebug(x)
@@ -86,7 +91,7 @@ public:
                      const KIO::UDSEntryList& entries);
 
     void deleted(const QString &path);
-    void created(const QString &path);
+    void dirty(const QString &path);
 
     void projectClosing(IProject* project);
     void jobFinished(KJob* job);
@@ -100,7 +105,7 @@ public:
 
     void removeFolder(ProjectFolderItem* folder);
 
-    QHash<IProject*, KDirWatch*> m_watchers;
+    QHash<IProject*, ProjectWatcher*> m_watchers;
     QHash<IProject*, QList<FileManagerListJob*> > m_projectJobs;
     QVector<QString> m_stoppedFolders;
     ProjectFilterManager m_filters;
@@ -117,13 +122,25 @@ void AbstractFileManagerPluginPrivate::projectClosing(IProject* project)
         }
         m_projectJobs.remove(project);
     }
+#ifdef TIME_IMPORT_JOB
+    QElapsedTimer timer;
+    if (m_watchers.contains(project)) {
+        timer.start();
+    }
+#endif
     delete m_watchers.take(project);
+#ifdef TIME_IMPORT_JOB
+    if (timer.isValid()) {
+        qCInfo(FILEMANAGER) << "Deleting dir watcher took" << timer.elapsed() / 1000.0 << "seconds for project" << project->name();
+    }
+#endif
     m_filters.remove(project);
 }
 
 KIO::Job* AbstractFileManagerPluginPrivate::eventuallyReadFolder(ProjectFolderItem* item)
 {
-    FileManagerListJob* listJob = new FileManagerListJob( item );
+    ProjectWatcher* watcher = m_watchers.value( item->project(), nullptr );
+    FileManagerListJob* listJob = new FileManagerListJob( item, watcher );
     m_projectJobs[ item->project() ] << listJob;
     qCDebug(FILEMANAGER) << "adding job" << listJob << item << item->path() << "for project" << item->project();
 
@@ -247,9 +264,9 @@ void AbstractFileManagerPluginPrivate::addJobItems(FileManagerListJob* job,
     }
 }
 
-void AbstractFileManagerPluginPrivate::created(const QString& path_)
+void AbstractFileManagerPluginPrivate::dirty(const QString& path_)
 {
-    qCDebug(FILEMANAGER) << "created:" << path_;
+    qCDebug(FILEMANAGER) << "dirty:" << path_;
     QFileInfo info(path_);
 
     ///FIXME: share memory with parent
@@ -257,7 +274,7 @@ void AbstractFileManagerPluginPrivate::created(const QString& path_)
     const IndexedString indexedPath(path.pathOrUrl());
     const IndexedString indexedParent(path.parent().pathOrUrl());
 
-    QHashIterator<IProject*, KDirWatch*> it(m_watchers);
+    QHashIterator<IProject*, ProjectWatcher*> it(m_watchers);
     while (it.hasNext()) {
         const auto p = it.next().key();
         if ( !p->projectItem()->model() ) {
@@ -290,12 +307,16 @@ void AbstractFileManagerPluginPrivate::created(const QString& path_)
                 ProjectFolderItem* folder = q->createFolderItem( p, path, parentItem );
                 if (folder) {
                     emit q->folderAdded( folder );
+                    // FIXME: convert to qCDebug() before committing
+                    qCWarning(FILEMANAGER) << "force reload of" << folder << "of" << parentItem;
                     auto job = eventuallyReadFolder( folder );
                     job->start();
                 }
             } else {
                 ProjectFileItem* file = q->createFileItem( p, path, parentItem );
                 if (file) {
+                    // FIXME: convert to qCDebug() before committing
+                    qCWarning(FILEMANAGER) << "added file" << file;
                     emit q->fileAdded( file );
                 }
             }
@@ -320,7 +341,7 @@ void AbstractFileManagerPluginPrivate::deleted(const QString& path_)
     const Path path(QUrl::fromLocalFile(path_));
     const IndexedString indexed(path.pathOrUrl());
 
-    QHashIterator<IProject*, KDirWatch*> it(m_watchers);
+    QHashIterator<IProject*, ProjectWatcher*> it(m_watchers);
     while (it.hasNext()) {
         const auto p = it.next().key();
         if (path == p->path()) {
@@ -388,8 +409,8 @@ void AbstractFileManagerPluginPrivate::stopWatcher(ProjectFolderItem* folder)
     if ( !folder->path().isLocalFile() ) {
         return;
     }
-    Q_ASSERT(m_watchers.contains(folder->project()));
     const QString path = folder->path().toLocalFile();
+    Q_ASSERT(m_watchers.contains(folder->project()));
     m_watchers[folder->project()]->stopDirScan(path);
     m_stoppedFolders.append(path);
 }
@@ -399,9 +420,14 @@ void AbstractFileManagerPluginPrivate::continueWatcher(ProjectFolderItem* folder
     if ( !folder->path().isLocalFile() ) {
         return;
     }
-    Q_ASSERT(m_watchers.contains(folder->project()));
+    auto watcher = m_watchers.value(folder->project(), nullptr);
+    Q_ASSERT(watcher);
     const QString path = folder->path().toLocalFile();
-    m_watchers[folder->project()]->restartDirScan(path);
+    if (!watcher->restartDirScan(path)) {
+        // path wasn't being watched yet - can we be 100% certain of that will never happen?
+        qCWarning(FILEMANAGER) << "Folder" << path << "in project" << folder->project()->name() << "wasn't yet being watched";
+        watcher->addDir(path);
+    }
     const int idx = m_stoppedFolders.indexOf(path);
     if (idx != -1) {
         m_stoppedFolders.remove(idx);
@@ -431,6 +457,9 @@ void AbstractFileManagerPluginPrivate::removeFolder(ProjectFolderItem* folder)
             job->removeSubDir(folder);
         }
     }
+    ProjectWatcher* watcher = m_watchers.value(folder->project(), nullptr);
+    Q_ASSERT(watcher);
+    watcher->removeDir(folder->path().toLocalFile());
     folder->parent()->removeRow( folder->row() );
 }
 
@@ -472,14 +501,13 @@ ProjectFolderItem *AbstractFileManagerPlugin::import( IProject *project )
 
     ///TODO: check if this works for remote files when something gets changed through another KDE app
     if ( project->path().isLocalFile() ) {
-        d->m_watchers[project] = new KDirWatch( project );
+        d->m_watchers[project] = new ProjectWatcher(project);
 
-        connect(d->m_watchers[project], &KDirWatch::created,
-                this, [&] (const QString& path_) { d->created(path_); });
+        // set up the signal handling; feeding the dirwatcher is handled by FileManagerListJob.
+        connect(d->m_watchers[project], &KDirWatch::dirty,
+                this, [&] (const QString& path_) { d->dirty(path_); });
         connect(d->m_watchers[project], &KDirWatch::deleted,
                 this, [&] (const QString& path_) { d->deleted(path_); });
-
-        d->m_watchers[project]->addDir(project->path().toLocalFile(), KDirWatch::WatchSubDirs | KDirWatch:: WatchFiles );
     }
 
     d->m_filters.add(project);
@@ -656,6 +684,18 @@ KDirWatch* AbstractFileManagerPlugin::projectWatcher( IProject* project ) const
     return d->m_watchers.value( project, nullptr );
 }
 
+int AbstractFileManagerPlugin::watchedItems( IProject* project ) const
+{
+    auto watcher = d->m_watchers.value( project, nullptr );
+    Q_ASSERT(watcher);
+    return watcher->size();
+}
+
+void AbstractFileManagerPlugin::detach( IProject *project )
+{
+    d->projectClosing(project);
+}
+
 //END Plugin
 
 #include "moc_abstractfilemanagerplugin.cpp"
diff --git a/kdevplatform/project/abstractfilemanagerplugin.h b/kdevplatform/project/abstractfilemanagerplugin.h
index c99e7e0c2316bf24df76d303fdb599a8095193da..fbbaef2797698f9b88c12886bbde23a3901c95b8 100644
--- a/kdevplatform/project/abstractfilemanagerplugin.h
+++ b/kdevplatform/project/abstractfilemanagerplugin.h
@@ -35,6 +35,8 @@ namespace KDevelop {
 
 class AbstractFileManagerPluginPrivate;
 
+class ProjectWatcher;
+
 /**
  * This class can be used as a common base for file managers.
  *
@@ -103,6 +105,17 @@ protected:
      */
     KDirWatch* projectWatcher( IProject* project ) const;
 
+    /**
+     * @return the number of watched directories for the given @p project.
+     */
+    int watchedItems( IProject* project ) const;
+
+    /**
+     * unregisters the given @p project, deleting dirwatchers,
+     * stopping associated jobs, etc. Intended for testing only.
+     */
+    void detach( IProject *project );
+
 Q_SIGNALS:
     void reloadedFileItem(KDevelop::ProjectFileItem* file);
     void reloadedFolderItem(KDevelop::ProjectFolderItem* folder);
diff --git a/kdevplatform/project/filemanagerlistjob.cpp b/kdevplatform/project/filemanagerlistjob.cpp
index 06e1d69c70ba762cc476086794a79324871401f9..bb051b19b6a9050420794865c8216184b2ad5460 100644
--- a/kdevplatform/project/filemanagerlistjob.cpp
+++ b/kdevplatform/project/filemanagerlistjob.cpp
@@ -18,6 +18,7 @@
 */
 
 #include "filemanagerlistjob.h"
+#include "projectwatcher.h"
 
 #include <interfaces/iproject.h>
 #include <project/projectmodel.h>
@@ -28,10 +29,12 @@
 #include <QtConcurrentRun>
 #include <QDir>
 
+#include <KDirWatch>
+
 using namespace KDevelop;
 
-FileManagerListJob::FileManagerListJob(ProjectFolderItem* item)
-    : KIO::Job(), m_item(item), m_aborted(false)
+FileManagerListJob::FileManagerListJob(ProjectFolderItem* item, ProjectWatcher* watcher)
+    : KIO::Job(), m_item(item), m_aborted(false), m_watcher(watcher)
 {
     qRegisterMetaType<KIO::UDSEntryList>("KIO::UDSEntryList");
     qRegisterMetaType<KIO::Job*>();
@@ -95,12 +98,14 @@ void FileManagerListJob::startNextJob()
             if (m_aborted) {
                 return;
             }
+            m_watcher->addDir(path.toLocalFile());
             KIO::UDSEntryList results;
-            std::transform(entries.begin(), entries.end(), std::back_inserter(results), [] (const QFileInfo& info) -> KIO::UDSEntry {
+            std::transform(entries.begin(), entries.end(), std::back_inserter(results), [this] (const QFileInfo& info) -> KIO::UDSEntry {
                 KIO::UDSEntry entry;
                 entry.insert(KIO::UDSEntry::UDS_NAME, info.fileName());
                 if (info.isDir()) {
                     entry.insert(KIO::UDSEntry::UDS_FILE_TYPE, QT_STAT_DIR);
+                    m_watcher->addDir(info.absoluteFilePath());
                 }
                 if (info.isSymLink()) {
                     entry.insert(KIO::UDSEntry::UDS_LINK_DEST, info.symLinkTarget());
diff --git a/kdevplatform/project/filemanagerlistjob.h b/kdevplatform/project/filemanagerlistjob.h
index 0d32c992c47ebc7d084a019badb64988f0be9ec0..92b101de4e6a44bb1962274d4bc39064bf914aa8 100644
--- a/kdevplatform/project/filemanagerlistjob.h
+++ b/kdevplatform/project/filemanagerlistjob.h
@@ -33,13 +33,14 @@
 namespace KDevelop
 {
     class ProjectFolderItem;
+    class ProjectWatcher;
 
 class FileManagerListJob : public KIO::Job
 {
     Q_OBJECT
 
 public:
-    explicit FileManagerListJob(ProjectFolderItem* item);
+    explicit FileManagerListJob(ProjectFolderItem* item, ProjectWatcher* watcher);
     ProjectFolderItem* item() const;
 
     void addSubDir(ProjectFolderItem* item);
@@ -73,6 +74,7 @@ private:
     QElapsedTimer m_subTimer;
     qint64 m_subWaited = 0;
 #endif
+    ProjectWatcher* m_watcher;
 };
 
 }
diff --git a/kdevplatform/project/projectwatcher.cpp b/kdevplatform/project/projectwatcher.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..717ede3cf465cfd45e8f6c3f12572219572f1f44
--- /dev/null
+++ b/kdevplatform/project/projectwatcher.cpp
@@ -0,0 +1,57 @@
+/***************************************************************************
+ *   This file is part of KDevelop                                         *
+ *   Copyright 2017 René Bertin <rjvbertin@gmail.com>                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU Library General Public License as       *
+ *   published by the Free Software Foundation; either version 2 of the    *
+ *   License, or (at your option) any later version.                       *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU Library General Public     *
+ *   License along with this program; if not, write to the                 *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.         *
+ ***************************************************************************/
+
+#include "projectwatcher.h"
+
+#include <QMutexLocker>
+
+#include <KDirWatch>
+
+using namespace KDevelop;
+
+QMutex KDevelop::ProjectWatcher::m_mutex;
+
+KDevelop::ProjectWatcher::ProjectWatcher(QObject* parent)
+    : KDirWatch(parent)
+    , m_watchedCount(0)
+{}
+
+void KDevelop::ProjectWatcher::addDir(const QString& path, WatchModes watchModes)
+{
+    // The QFileSystemWatcher backend doesn't like to be called
+    // too often/concurrently; prevent concurrent calls (can happen
+    // in trees with lots of few-element directories).
+    // (On Mac, this improves speeds, on Linux I've seen the occasional
+    // memory allocation issue without this barrier.)
+    QMutexLocker lock(&m_mutex);
+    if (!contains(path)) {
+        KDirWatch::addDir(path, watchModes);
+        m_watchedCount += 1;
+    }
+}
+
+void KDevelop::ProjectWatcher::removeDir(const QString& path)
+{
+    QMutexLocker lock(&m_mutex);
+    if (contains(path)) {
+        KDirWatch::removeDir(path);
+        m_watchedCount -= 1;
+    }
+}
diff --git a/kdevplatform/project/projectwatcher.h b/kdevplatform/project/projectwatcher.h
new file mode 100644
index 0000000000000000000000000000000000000000..9635ab2a7b17b903d13166d2617c834c2192df35
--- /dev/null
+++ b/kdevplatform/project/projectwatcher.h
@@ -0,0 +1,47 @@
+/***************************************************************************
+ *   This file is part of KDevelop                                         *
+ *   Copyright 2017 René Bertin <rjvbertin@gmail.com>                      *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU Library General Public License as       *
+ *   published by the Free Software Foundation; either version 2 of the    *
+ *   License, or (at your option) any later version.                       *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU Library General Public     *
+ *   License along with this program; if not, write to the                 *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.         *
+ ***************************************************************************/
+
+#ifndef KDEVPLATFORM_PROJECTWATCHER_H
+#define KDEVPLATFORM_PROJECTWATCHER_H
+
+#include <KDirWatch>
+#include <QMutex>
+
+namespace KDevelop {
+
+class ProjectWatcher : public KDirWatch
+{
+public:
+    explicit ProjectWatcher(QObject* parent = nullptr);
+
+    void addDir(const QString& path, WatchModes watchModes = WatchDirOnly);
+    void removeDir(const QString& path);
+
+    int size() {
+        return m_watchedCount;
+    }
+
+private:
+    static QMutex m_mutex;
+    int m_watchedCount;
+};
+
+}
+#endif //KDEVPLATFORM_PROJECTWATCHER_H
diff --git a/kdevplatform/project/tests/CMakeLists.txt b/kdevplatform/project/tests/CMakeLists.txt
index 74e5baada32fcc570f410e50c26bfc83a5066830..5a8d80cfe1a933bb839114cf7059152fc235adbd 100644
--- a/kdevplatform/project/tests/CMakeLists.txt
+++ b/kdevplatform/project/tests/CMakeLists.txt
@@ -21,3 +21,12 @@ target_link_libraries(abstractfilemanagerpluginimporttest
     KDev::Tests
     Qt5::QuickWidgets
 )
+
+add_executable(abstractfilemanagerpluginimportbenchmark
+    abstractfilemanagerpluginimportbenchmark.cpp
+)
+ecm_mark_nongui_executable(abstractfilemanagerpluginimportbenchmark)
+target_link_libraries(abstractfilemanagerpluginimportbenchmark
+    KDev::Project
+    KDev::Tests
+)
diff --git a/kdevplatform/project/tests/abstractfilemanagerpluginimportbenchmark.cpp b/kdevplatform/project/tests/abstractfilemanagerpluginimportbenchmark.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..2c52f0afd485bcedc7dc6da6b71a93482391e32f
--- /dev/null
+++ b/kdevplatform/project/tests/abstractfilemanagerpluginimportbenchmark.cpp
@@ -0,0 +1,137 @@
+/* This file is part of KDevelop
+    Copyright 2016 Milian Wolff <mail@milianw.de>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include <project/abstractfilemanagerplugin.h>
+#include <project/projectmodel.h>
+
+#include <tests/autotestshell.h>
+#include <tests/testcore.h>
+#include <tests/testproject.h>
+
+#include <util/path.h>
+
+#include <KJob>
+#include <KDirWatch>
+
+#include <QCoreApplication>
+#include <QList>
+#include <QFileInfo>
+#include <QElapsedTimer>
+#include <QDebug>
+
+using namespace KDevelop;
+
+class AFMPBenchmark : public AbstractFileManagerPlugin {
+    Q_OBJECT
+public:
+    AFMPBenchmark(const QString& path, QObject* parent)
+        : AbstractFileManagerPlugin({}, parent)
+    {
+        if (QFileInfo(path).isDir()) {
+            m_project = new TestProject(Path(path));
+        } else {
+            qWarning() << path << "is not a directory, ignoring";
+            m_project = nullptr;
+        }
+    }
+
+    void start()
+    {
+        if (m_project) {
+            auto root = import(m_project);
+            auto import = createImportJob(root);
+            QObject::connect(import, &KJob::finished, this, &AFMPBenchmark::projectImportDone);
+            m_projectNumber = s_count++;
+            qInfo() << "Starting import of project #" << m_projectNumber << "at" << root->path();
+            m_timer.start();
+            import->start();
+        }
+    }
+
+    void detach()
+    {
+        m_timer.restart();
+        AbstractFileManagerPlugin::detach(m_project);
+        int elapsed = m_timer.elapsed();
+        qInfo() << "\tclosing project" << m_projectNumber << "took" << elapsed / 1000.0 << "seconds";
+    }
+
+    TestProject* m_project;
+    QElapsedTimer m_timer;
+    int m_projectNumber;
+
+    static int s_count;
+
+Q_SIGNALS:
+    void finished();
+
+private Q_SLOTS:
+    void projectImportDone(KJob* job)
+    {
+        Q_UNUSED(job);
+        int elapsed = m_timer.elapsed();
+        qInfo() << "imported project" << m_projectNumber
+            << "with" << m_project->fileSet().size() << "files (watched:" << watchedItems(m_project) << ") in" << elapsed / 1000.0 << "seconds";
+
+        s_count -= 1;
+        if (s_count <= 0) {
+            qInfo() << "Done.";
+            emit finished();
+        }
+    }
+
+};
+
+int AFMPBenchmark::s_count = 0;
+
+static QList<AFMPBenchmark*> benchmarks;
+
+int main(int argc, char** argv)
+{
+    if (argc < 2) {
+        qWarning() << "Usage:" << argv[0] << "projectDir1 [...projectDirN]";
+        return 1;
+    }
+    QCoreApplication app(argc, argv);
+
+    AutoTestShell::init();
+    auto core = TestCore::initialize(Core::NoUi);
+
+
+    for (int i = 1 ; i < argc ; ++i) {
+        const auto benchmark = new AFMPBenchmark(QString::fromUtf8(argv[i]), core);
+        benchmarks << benchmark;
+        QObject::connect(benchmark, &AFMPBenchmark::finished,
+                     &app, [] {
+                        foreach (auto benchmark, benchmarks) {
+                            benchmark->detach();
+                        }
+                        QCoreApplication::instance()->quit();
+                     });
+    }
+    foreach (auto benchmark, benchmarks) {
+        benchmark->start();
+    }
+
+    if (benchmarks.first()->s_count > 0) {
+        return app.exec();
+    }
+}
+
+#include "abstractfilemanagerpluginimportbenchmark.moc"
