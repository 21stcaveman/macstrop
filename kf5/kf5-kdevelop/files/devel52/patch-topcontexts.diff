diff --git a/kdevplatform/language/CMakeLists.txt b/kdevplatform/language/CMakeLists.txt
index 7b2e83876b..26c5daa6cd 100644
--- a/kdevplatform/language/CMakeLists.txt
+++ b/kdevplatform/language/CMakeLists.txt
@@ -6,6 +6,21 @@ include(CheckSymbolExists)
 check_include_file("malloc.h" HAVE_MALLOC_H)
 check_symbol_exists(malloc_trim "malloc.h" HAVE_MALLOC_TRIM)
 
+# find LMDB and lmdbxx
+find_path(LMDBXX_INCLUDE_DIRS NAMES "lmdb++.h" HINTS "$ENV{LMDB_DIR}/include")
+find_path(LMDB_INCLUDE_DIRS NAMES "lmdb.h" HINTS "$ENV{LMDB_DIR}/include")
+find_library(LMDB_LIBRARIES NAMES lmdb HINTS $ENV{LMDB_DIR}/lib )
+find_package_handle_standard_args(LMDB DEFAULT_MSG LMDB_INCLUDE_DIRS LMDB_LIBRARIES)
+find_package_handle_standard_args(LMDBXX DEFAULT_MSG LMDBXX_INCLUDE_DIRS)
+# # find LevelDB stuff
+# find_path(LEVELDB_INCLUDE_DIRS NAMES "leveldb" HINTS "$ENV{LEVELDB_DIR}/include")
+# find_library(LEVELDB_LIBRARIES NAMES leveldb HINTS $ENV{LEVELDB_DIR}/lib )
+# find_package_handle_standard_args(LEVELDB DEFAULT_MSG LEVELDB_INCLUDE_DIRS LEVELDB_LIBRARIES)
+# find KyotoCabinet stuff
+include(FindPkgConfig)
+pkg_check_modules(PKG_KYOTOCABINET kyotocabinet REQUIRED)
+find_package_handle_standard_args(KYOTOCABINET DEFAULT_MSG PKG_KYOTOCABINET_INCLUDEDIR PKG_KYOTOCABINET_LIBRARIES)
+
 if(BUILD_TESTING)
     add_subdirectory(highlighting/tests)
     add_subdirectory(duchain/tests)
@@ -48,6 +63,7 @@ set(KDevPlatformLanguage_LIB_SRCS
     duchain/localindexeddeclaration.cpp
     duchain/topducontext.cpp
     duchain/topducontextdynamicdata.cpp
+    duchain/topducontextdynamicdata_p.cpp
     duchain/topducontextutils.cpp
     duchain/functiondefinition.cpp
     duchain/declaration.cpp
@@ -177,6 +193,10 @@ ki18n_wrap_ui(KDevPlatformLanguage_LIB_SRCS
 
 kdevplatform_add_library(KDevPlatformLanguage SOURCES ${KDevPlatformLanguage_LIB_SRCS})
 target_include_directories(KDevPlatformLanguage PRIVATE ${Boost_INCLUDE_DIRS})
+target_include_directories(KDevPlatformLanguage PRIVATE ${LMDB_INCLUDE_DIRS} ${LMDBXX_INCLUDE_DIRS})
+# target_include_directories(KDevPlatformLanguage PRIVATE ${LEVELDB_INCLUDE_DIRS})
+target_include_directories(KDevPlatformLanguage PRIVATE ${PKG_KYOTOCABINET_INCLUDEDIR})
+kde_source_files_enable_exceptions(duchain/topducontextdynamicdata_p.cpp)
 target_link_libraries(KDevPlatformLanguage LINK_PUBLIC
         KF5::ThreadWeaver
         KDev::Interfaces
@@ -191,6 +211,9 @@ LINK_PRIVATE
         KDev::Util
         KDev::Project
 )
+target_link_libraries(KDevPlatformLanguage LINK_PRIVATE ${LMDB_LIBRARIES})
+# target_link_libraries(KDevPlatformLanguage LINK_PRIVATE ${LEVELDB_LIBRARIES})
+target_link_libraries(KDevPlatformLanguage LINK_PRIVATE ${PKG_KYOTOCABINET_LIBRARIES})
 
 install(FILES
     assistant/renameaction.h
diff --git a/kdevplatform/language/duchain/tests/CMakeLists.txt b/kdevplatform/language/duchain/tests/CMakeLists.txt
index 7b8e50f415e9df16918c15cbbf0e58378f50d283..a598651e2b0e5bee32aba789f443712c60b53859 100644
--- a/kdevplatform/language/duchain/tests/CMakeLists.txt
+++ b/kdevplatform/language/duchain/tests/CMakeLists.txt
@@ -10,6 +10,9 @@ ecm_add_test(test_identifier.cpp
 ecm_add_test(test_stringhelpers.cpp
     LINK_LIBRARIES Qt5::Test KDev::Tests KDev::Language)
 
+ecm_add_test(test_topcontextstore.cpp
+    LINK_LIBRARIES Qt5::Test KDev::Tests KDev::Language)
+
 if(NOT COMPILER_OPTIMIZATIONS_DISABLED)
     ecm_add_test(bench_hashes.cpp
         LINK_LIBRARIES Qt5::Test KDev::Tests KDev::Language)
diff --git a/kdevplatform/language/duchain/tests/test_topcontextstore.cpp b/kdevplatform/language/duchain/tests/test_topcontextstore.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..20df5b3244b3026f2dca25d966c6db46d8a6d25f
--- /dev/null
+++ b/kdevplatform/language/duchain/tests/test_topcontextstore.cpp
@@ -0,0 +1,315 @@
+/*
+ * This file is part of KDevelop
+ *
+ * Copyright 2016 Milian Wolff <mail@milianw.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Library General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+// results using perf stat -r 5 on Linux 4.14 running on an 1.6Ghz Intel N3150 and ZFSonLinux 0.7.6
+
+// KDEV_TOPCONTEXTS_USE_FILES:
+// QINFO  : TestTopDUContextStore::benchTopContextStore() 6000 items, max length= 32761
+// INFO   : TestTopDUContextStore::benchTopContextStore() warmup stage result      : 10862
+// INFO   : TestTopDUContextStore::benchTopContextStore() accumulation stage result: 8229
+// PASS   : TestTopDUContextStore::benchTopContextStore()
+// RESULT : TestTopDUContextStore::benchTopContextStore():
+//      2,057 msecs per iteration (total: 8,229, iterations: 4)
+// INFO   : TestTopDUContextStore::benchTopContextStoreRead() warmup stage result      : 10028
+// INFO   : TestTopDUContextStore::benchTopContextStoreRead() accumulation stage result: 9881
+// PASS   : TestTopDUContextStore::benchTopContextStoreRead()
+// RESULT : TestTopDUContextStore::benchTopContextStoreRead():
+//      617.5 msecs per iteration (total: 9,881, iterations: 16)
+// INFO   : TestTopDUContextStore::benchTopContextStoreRemove() warmup stage result      : 5795
+// INFO   : TestTopDUContextStore::benchTopContextStoreRemove() accumulation stage result: 5908
+// PASS   : TestTopDUContextStore::benchTopContextStoreRemove()
+// RESULT : TestTopDUContextStore::benchTopContextStoreRemove():
+//      184.6 msecs per iteration (total: 5,908, iterations: 32)
+// PASS   : TestTopDUContextStore::cleanupTestCase()
+// Totals: 37 passed, 0 failed, 0 skipped, 0 blacklisted, 138444ms
+// ********* Finished testing of TestTopDUContextStore *********
+// 
+//  Performance counter stats for 'test_topcontextstore -vb -minimumvalue 5000 -nocrashhandler' (3 runs):
+// 
+//      111490.122769      task-clock:u (msec)       #    0.783 CPUs utilized            ( +-  1.88% )
+//                  0      context-switches:u        #    0.000 K/sec                  
+//                  0      cpu-migrations:u          #    0.000 K/sec                  
+//             42,616      page-faults:u             #    0.382 K/sec                    ( +-  0.25% )
+//     54,822,064,888      cycles:u                  #    0.492 GHz                      ( +-  3.28% )
+//     21,199,857,430      instructions:u            #    0.39  insn per cycle           ( +-  1.58% )
+//      4,913,883,246      branches:u                #   44.075 M/sec                    ( +-  1.65% )
+//        407,727,735      branch-misses:u           #    8.30% of all branches          ( +-  1.86% )
+// 
+//      142.383317779 seconds time elapsed                                          ( +-  2.27% )
+// ## Idem, with only 1500 keys (not how the times are > 4x shorter!)
+// QINFO  : TestTopDUContextStore::benchTopContextStore() 1500 items, max length= 32711
+// INFO   : TestTopDUContextStore::benchTopContextStore() warmup stage result      : 5522
+// INFO   : TestTopDUContextStore::benchTopContextStore() accumulation stage result: 5706
+// PASS   : TestTopDUContextStore::benchTopContextStore()
+// RESULT : TestTopDUContextStore::benchTopContextStore():
+//      356.6 msecs per iteration (total: 5,706, iterations: 16)
+// INFO   : TestTopDUContextStore::benchTopContextStoreRead() warmup stage result      : 8734
+// INFO   : TestTopDUContextStore::benchTopContextStoreRead() accumulation stage result: 8422
+// PASS   : TestTopDUContextStore::benchTopContextStoreRead()
+// RESULT : TestTopDUContextStore::benchTopContextStoreRead():
+//      131.5 msecs per iteration (total: 8,422, iterations: 64)
+// INFO   : TestTopDUContextStore::benchTopContextStoreRemove() warmup stage result      : 5643
+// INFO   : TestTopDUContextStore::benchTopContextStoreRemove() accumulation stage result: 5316
+// PASS   : TestTopDUContextStore::benchTopContextStoreRemove()
+// RESULT : TestTopDUContextStore::benchTopContextStoreRemove():
+//      41.53 msecs per iteration (total: 5,316, iterations: 128)
+// PASS   : TestTopDUContextStore::cleanupTestCase()
+// Totals: 37 passed, 0 failed, 0 skipped, 0 blacklisted, 90721ms
+// ********* Finished testing of TestTopDUContextStore *********
+// 
+//  Performance counter stats for 'test_topcontextstore -vb -minimumvalue 5000 -nocrashhandler' (3 runs):
+// 
+//       91115.790068      task-clock:u (msec)       #    0.940 CPUs utilized            ( +-  3.52% )
+//                  0      context-switches:u        #    0.000 K/sec                  
+//                  0      cpu-migrations:u          #    0.000 K/sec                  
+//             24,728      page-faults:u             #    0.271 K/sec                    ( +-  0.26% )
+//     45,178,093,031      cycles:u                  #    0.496 GHz                      ( +-  5.36% )
+//     13,621,283,170      instructions:u            #    0.30  insn per cycle           ( +-  5.39% )
+//      3,193,754,429      branches:u                #   35.052 M/sec                    ( +-  5.72% )
+//        246,420,944      branch-misses:u           #    7.72% of all branches          ( +-  5.08% )
+// 
+//       96.917260787 seconds time elapsed                                          ( +-  3.22% )
+
+// KDEV_TOPCONTEXTS_USE_LMDB:
+// QINFO  : TestTopDUContextStore::benchTopContextStore() 1500 items, max length= 32758
+// INFO   : TestTopDUContextStore::benchTopContextStore() warmup stage result      : 7445
+// INFO   : TestTopDUContextStore::benchTopContextStore() accumulation stage result: 7678
+// PASS   : TestTopDUContextStore::benchTopContextStore()
+// RESULT : TestTopDUContextStore::benchTopContextStore():
+//      7,678 msecs per iteration (total: 7,678, iterations: 1)
+//   QINFO  : TestTopDUContextStore::benchTopContextStore() 1500 items, max length= 32751
+//   INFO   : TestTopDUContextStore::benchTopContextStore() warmup stage result      : 31684
+//   INFO   : TestTopDUContextStore::benchTopContextStore() accumulation stage result: 27500
+//   PASS   : TestTopDUContextStore::benchTopContextStore()
+//   RESULT : TestTopDUContextStore::benchTopContextStore():
+//        27,500 msecs per iteration (total: 27,500, iterations: 1)
+// INFO   : TestTopDUContextStore::benchTopContextStoreRead() warmup stage result      : 8334
+// INFO   : TestTopDUContextStore::benchTopContextStoreRead() accumulation stage result: 8290
+// PASS   : TestTopDUContextStore::benchTopContextStoreRead()
+// RESULT : TestTopDUContextStore::benchTopContextStoreRead():
+//      32.38 msecs per iteration (total: 8,290, iterations: 256)
+// INFO   : TestTopDUContextStore::benchTopContextStoreRemove() warmup stage result      : 38746
+// INFO   : TestTopDUContextStore::benchTopContextStoreRemove() accumulation stage result: 47755
+// PASS   : TestTopDUContextStore::benchTopContextStoreRemove()
+// RESULT : TestTopDUContextStore::benchTopContextStoreRemove():
+//      47,755 msecs per iteration (total: 47,755, iterations: 1)
+// PASS   : TestTopDUContextStore::cleanupTestCase()
+// Totals: 37 passed, 0 failed, 0 skipped, 0 blacklisted, 352469ms
+// ********* Finished testing of TestTopDUContextStore *********
+// 
+//  Performance counter stats for 'test_topcontextstore -vb -minimumvalue 5000 -nocrashhandler' (3 runs):
+// 
+//       52737.669071      task-clock:u (msec)       #    0.213 CPUs utilized            ( +-  4.44% )
+//                  0      context-switches:u        #    0.000 K/sec                  
+//                  0      cpu-migrations:u          #    0.000 K/sec                  
+//             32,549      page-faults:u             #    0.617 K/sec                    ( +-  0.00% )
+//     40,396,836,895      cycles:u                  #    0.766 GHz                      ( +-  1.35% )
+//     17,878,882,925      instructions:u            #    0.44  insn per cycle           ( +-  1.78% )
+//      3,343,663,399      branches:u                #   63.402 M/sec                    ( +-  2.10% )
+//        170,298,115      branch-misses:u           #    5.09% of all branches          ( +-  2.41% )
+// 
+//      247.312770371 seconds time elapsed                                          ( +- 26.32% )
+
+
+#include "test_topcontextstore.h"
+
+#include <QTest>
+#include <QDir>
+
+#include <tests/autotestshell.h>
+#include <tests/testcore.h>
+
+#include <language/duchain/duchain.h>
+#include <language/codegen/coderepresentation.h>
+
+#include <language/duchain/topducontextdynamicdata_p.h>
+#include <language/duchain/topducontextdynamicdata.h>
+
+QTEST_MAIN(TestTopDUContextStore)
+
+using namespace KDevelop;
+
+uint TestTopDUContextStore::testKeys = 32;
+uint TestTopDUContextStore::benchKeys = 1500;
+
+static QString basePath()
+{
+  return globalItemRepositoryRegistry().path() + "/topcontexts/";
+}
+
+void TestTopDUContextStore::initTestCase()
+{
+  AutoTestShell::init();
+  TestCore::initialize(Core::NoUi);
+
+  DUChain::self()->disablePersistentStorage();
+  CodeRepresentation::setDiskChangesForbidden(true);
+  QDir().mkpath(basePath());
+}
+
+void TestTopDUContextStore::cleanupTestCase()
+{
+  TestCore::shutdown();
+}
+
+void TestTopDUContextStore::testTopContextStore_data()
+{
+  QTest::addColumn<uint>("key");
+  QTest::addColumn<QByteArray>("value");
+  QTest::addColumn<int>("size");
+
+  for (uint i = 0 ; i < testKeys ; ++i) {
+    TopDUContextStore writer(i);
+    QByteArray data;
+    uint size = qrand() * 32767.0 / RAND_MAX;
+    data.resize(size);
+    char *d = data.data();
+    for (uint j = 0 ; j < size ; ++j) {
+      d[j] = qrand() * 256.0 / RAND_MAX;
+    }
+    QTest::newRow("keyval") << i << data << data.size();
+    if (writer.open(QIODevice::WriteOnly)) {
+      writer.write(d, size);
+      writer.commit();
+      const auto errString = writer.errorString();
+      if (!errString.isEmpty() && errString != "Unknown error") {
+        qCritical() << "Failed to write entry for key" << i << "to" << writer.fileName() << ":" << writer.errorString();
+      }
+    } else {
+      qCritical() << "Failed to open" << writer.fileName();
+    }
+  }
+}
+
+void TestTopDUContextStore::testTopContextStore()
+{
+  QFETCH(uint, key);
+  QFETCH(QByteArray, value);
+  QFETCH(int, size);
+//     QCOMPARE(formatComment(input), output);
+  TopDUContextStore reader(key);
+  QByteArray testval;
+  if (reader.open(QIODevice::ReadOnly)) {
+    testval = reader.readAll();
+    if (testval.isEmpty() && !reader.errorString().isEmpty()) {
+      qCritical() << "Failed to read entry for key" << key  << "from" << reader.fileName() << ":" << reader.errorString();
+    }
+  } else {
+    qCritical() << "Failed to open" << reader.fileName();
+  }
+  QCOMPARE(testval.size(), size);
+  QCOMPARE(testval, value);
+  QVERIFY(TopDUContextStore::exists(key));
+  QVERIFY(TopDUContextStore::remove(key));
+  QVERIFY(!TopDUContextStore::exists(key));
+}
+
+void TestTopDUContextStore::benchTopContextStore_data()
+{
+  uint maxSize = 0;
+  benchValues.reserve(benchKeys);
+  for (uint i = 0 ; i < benchKeys ; ++i) {
+    QByteArray data;
+    uint size = qrand() * 32767.0 / RAND_MAX;
+    if (size > maxSize) {
+      maxSize = size;
+    }
+    data.resize(size);
+    char *d = data.data();
+    for (uint j = 0 ; j < size ; ++j) {
+      d[j] = qrand() * 256.0 / RAND_MAX;
+    }
+    benchValues.append(data);
+  }
+  qInfo() << benchValues.size() << "items, max length=" << maxSize;
+}
+
+void TestTopDUContextStore::benchTopContextStore()
+{
+  QBENCHMARK {
+    for (uint i = 0 ; i < benchKeys ; ++i)
+    {
+      TopDUContextStore writer(i);
+      if (writer.open(QIODevice::WriteOnly)) {
+        QByteArray data = benchValues.at(i);
+        writer.write(data.constData(), data.size());
+        writer.commit();
+      }
+    }
+  }
+  // make sure that we always time writing and not overwriting
+  for (uint i = 0 ; i < benchKeys ; ++i) {
+    TopDUContextStore::remove(i);
+  }
+}
+
+void TestTopDUContextStore::benchTopContextStoreRead_data()
+{
+  for (uint i = 0 ; i < benchKeys ; ++i) {
+    TopDUContextStore writer(i);
+    if (writer.open(QIODevice::WriteOnly)) {
+      QByteArray data = benchValues.at(i);
+      writer.write(data.constData(), data.size());
+      writer.commit();
+    }
+  }
+}
+
+void TestTopDUContextStore::benchTopContextStoreRead()
+{
+  QBENCHMARK {
+    for (uint i = 0 ; i < benchKeys ; ++i)
+    {
+      TopDUContextStore reader(i);
+      if (reader.open(QIODevice::ReadOnly)) {
+        QByteArray data = reader.readAll();
+      }
+    }
+  }
+}
+
+void TestTopDUContextStore::benchTopContextStoreRemove_data()
+{
+  // clean
+  for (uint i = 0 ; i < benchKeys ; ++i) {
+    TopDUContextStore::remove(i);
+  }
+}
+
+void TestTopDUContextStore::benchTopContextStoreRemove()
+{
+  // restore
+  for (uint i = 0 ; i < benchKeys ; ++i) {
+    TopDUContextStore writer(i);
+    if (writer.open(QIODevice::WriteOnly)) {
+      QByteArray data = benchValues.at(i);
+      writer.write(data.constData(), data.size());
+      writer.commit();
+    }
+  }
+  QBENCHMARK {
+    for (uint i = 0 ; i < benchKeys ; ++i)
+    {
+      TopDUContextStore::remove(i);
+    }
+  }
+  qInfo() << Q_FUNC_INFO << "Done";
+}
diff --git a/kdevplatform/language/duchain/tests/test_topcontextstore.h b/kdevplatform/language/duchain/tests/test_topcontextstore.h
new file mode 100644
index 0000000000000000000000000000000000000000..5d2a558c35c50a7c5c15fb5a813c44e00bd52a2e
--- /dev/null
+++ b/kdevplatform/language/duchain/tests/test_topcontextstore.h
@@ -0,0 +1,51 @@
+/*
+ * This file is part of KDevelop
+ *
+ * Copyright 2016 Milian Wolff <mail@milianw.de>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Library General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef KDEVPLATFORM_TEST_TOPCONTEXTSTORE_H
+#define KDEVPLATFORM_TEST_TOPCONTEXTSTORE_H
+
+#include <QObject>
+#include <QVector>
+#include <QByteArray>
+
+class TestTopDUContextStore : public QObject
+{
+    Q_OBJECT
+private Q_SLOTS:
+    void initTestCase();
+    void cleanupTestCase();
+    void testTopContextStore_data();
+    void testTopContextStore();
+
+    void benchTopContextStore_data();
+    void benchTopContextStore();
+    void benchTopContextStoreRead_data();
+    void benchTopContextStoreRead();
+    void benchTopContextStoreRemove_data();
+    void benchTopContextStoreRemove();
+
+private:
+    static uint testKeys;
+    static uint benchKeys;
+    QVector<QByteArray> benchValues;
+};
+
+#endif // KDEVPLATFORM_TEST_TOPCONTEXTSTORE_H
diff --git a/kdevplatform/language/duchain/topducontextdynamicdata.cpp b/kdevplatform/language/duchain/topducontextdynamicdata.cpp
index 5a857fc657cc8276fb861b5478d5d79de92b07df..de5b072ba5967d5c4d7c75da1a4d3dcf1e33e5f9 100644
--- a/kdevplatform/language/duchain/topducontextdynamicdata.cpp
+++ b/kdevplatform/language/duchain/topducontextdynamicdata.cpp
@@ -18,6 +18,7 @@
    Boston, MA 02110-1301, USA.
 */
 
+#include "topducontextdynamicdata_p.h"
 #include "topducontextdynamicdata.h"
 
 #include <typeinfo>
@@ -37,9 +38,13 @@
 #include <debug.h>
 
 //#define DEBUG_DATA_INFO
+#include <QElapsedTimer>
 
 //This might be problematic on some systems, because really many mmaps are created
+#if defined(KDEV_TOPCONTEXTS_USE_FILES) && !defined(KDEV_TOPCONTEXTS_DONT_MMAP)
 #define USE_MMAP
+#endif
+
 using namespace KDevelop;
 
 namespace {
@@ -149,16 +154,6 @@ void verifyDataInfo(const TopDUContextDynamicData::ItemDataInfo& info, const QVe
 #endif
 }
 
-QString basePath()
-{
-  return globalItemRepositoryRegistry().path() + "/topcontexts/";
-}
-
-QString pathForTopContext(const uint topContextIndex)
-{
-  return basePath() + QString::number(topContextIndex);
-}
-
 enum LoadType {
   PartialLoad, ///< Only load the direct member data
   FullLoad     ///< Load everything, including appended lists
@@ -166,16 +161,16 @@ enum LoadType {
 template<typename F>
 void loadTopDUContextData(const uint topContextIndex, LoadType loadType, F callback)
 {
-  QFile file(pathForTopContext(topContextIndex));
-  if (!file.open(QIODevice::ReadOnly)) {
+  TopDUContextStore store(topContextIndex);
+  if (!store.open(QIODevice::ReadOnly)) {
     return;
   }
 
   uint readValue;
-  file.read((char*)&readValue, sizeof(uint));
+  store.read((char*)&readValue, sizeof(uint));
   // now readValue is filled with the top-context data size
   Q_ASSERT(readValue >= sizeof(TopDUContextData));
-  const QByteArray data = file.read(loadType == FullLoad ? readValue : sizeof(TopDUContextData));
+  const QByteArray data = store.read(loadType == FullLoad ? readValue : sizeof(TopDUContextData));
   const TopDUContextData* topData = reinterpret_cast<const TopDUContextData*>(data.constData());
   callback(topData);
 }
@@ -386,13 +381,18 @@ Item TopDUContextDynamicData::DUChainItemStorage<Item>::getItemForIndex(uint ind
       reinterpret_cast<const DUChainBaseData*>(data->pointerInData(offsets[realIndex].dataOffset))
     );
 
-    auto& item = items[realIndex];
-    item = dynamic_cast<typename PtrType<Item>::value>(DUChainItemSystem::self().create(itemData));
-    if (!item) {
-      //When this happens, the item has not been registered correctly.
-      //We can stop here, because else we will get crashes later.
-      qCritical() << "Failed to load item with identity" << itemData->classId;
-      return {};
+    if (itemData) {
+      auto& item = items[realIndex];
+      item = dynamic_cast<typename PtrType<Item>::value>(DUChainItemSystem::self().create(itemData));
+      if (!item) {
+        //When this happens, the item has not been registered correctly.
+        //We can stop here, because else we will get crashes later.
+        qCritical() << "Failed to load item with identity" << itemData->classId;
+        return {};
+      }
+    } else {
+        qCritical() << "Failed to load item at realIndex" << realIndex << "itemData=" << itemData;
+        return {};
     }
 
     if (isSharedDataItem<Item>()) {
@@ -424,27 +424,27 @@ void TopDUContextDynamicData::DUChainItemStorage<Item>::deleteOnDisk()
 }
 
 template<class Item>
-void TopDUContextDynamicData::DUChainItemStorage<Item>::loadData(QFile* file) const
+void TopDUContextDynamicData::DUChainItemStorage<Item>::loadData(TopDUContextStore* store) const
 {
   Q_ASSERT(offsets.isEmpty());
   Q_ASSERT(items.isEmpty());
 
   uint readValue;
-  file->read((char*)&readValue, sizeof(uint));
+  store->read((char*)&readValue, sizeof(uint));
   offsets.resize(readValue);
 
-  file->read((char*)offsets.data(), sizeof(ItemDataInfo) * offsets.size());
+  store->read((char*)offsets.data(), sizeof(ItemDataInfo) * offsets.size());
 
   //Fill with zeroes for now, will be initialized on-demand
   items.resize(offsets.size());
 }
 
 template<class Item>
-void TopDUContextDynamicData::DUChainItemStorage<Item>::writeData(QFile* file)
+void TopDUContextDynamicData::DUChainItemStorage<Item>::writeData(TopDUContextStore* store)
 {
   uint writeValue = offsets.size();
-  file->write((char*)&writeValue, sizeof(uint));
-  file->write((char*)offsets.data(), sizeof(ItemDataInfo) * offsets.size());
+  store->write((char*)&writeValue, sizeof(uint));
+  store->write((char*)offsets.data(), sizeof(ItemDataInfo) * offsets.size());
 }
 
 //END DUChainItemStorage
@@ -495,7 +495,7 @@ void KDevelop::TopDUContextDynamicData::unmap() {
 
 bool TopDUContextDynamicData::fileExists(uint topContextIndex)
 {
-  return QFile::exists(pathForTopContext(topContextIndex));
+  return TopDUContextStore::exists(topContextIndex);
 }
 
 QList<IndexedDUContext> TopDUContextDynamicData::loadImporters(uint topContextIndex) {
@@ -537,63 +537,63 @@ void TopDUContextDynamicData::loadData() const {
   Q_ASSERT(!m_dataLoaded);
   Q_ASSERT(m_data.isEmpty());
 
-  QFile* file = new QFile(pathForTopContext(m_topContext->ownIndex()));
-  bool open = file->open(QIODevice::ReadOnly);
+  TopDUContextStore* store = new TopDUContextStore(m_topContext->ownIndex());
+  bool open = store->open(QIODevice::ReadOnly);
   Q_UNUSED(open);
   Q_ASSERT(open);
-  Q_ASSERT(file->size());
+  Q_ASSERT(store->size());
 
   //Skip the offsets, we're already read them
   //Skip top-context data
   uint readValue;
-  file->read((char*)&readValue, sizeof(uint));
-  file->seek(readValue + file->pos());
+  store->read((char*)&readValue, sizeof(uint));
+  store->seek(readValue + store->pos());
 
-  m_contexts.loadData(file);
-  m_declarations.loadData(file);
-  m_problems.loadData(file);
+  m_contexts.loadData(store);
+  m_declarations.loadData(store);
+  m_problems.loadData(store);
 
 #ifdef USE_MMAP
 
-  m_mappedData = file->map(file->pos(), file->size() - file->pos());
+  m_mappedData = store->map(store->pos(), store->size() - store->pos());
   if(m_mappedData) {
-    m_mappedFile = file;
-    m_mappedDataSize = file->size() - file->pos();
-    file->close(); //Close the file, so there is less open file descriptors(May be problematic)
+    m_mappedFile = store;
+    m_mappedDataSize = store->size() - store->pos();
+    store->commit(); //Close the store, so there are less open file descriptors (May be problematic)
   }else{
-    qCDebug(LANGUAGE) << "Failed to map" << file->fileName();
+    qCDebug(LANGUAGE) << "Failed to map" << store->fileName();
   }
 
 #endif
 
   if(!m_mappedFile) {
-    QByteArray data = file->readAll();
+    QByteArray data = store->readAll();
     m_data.append({data, (uint)data.size()});
-    delete file;
+    delete store;
   }
 
   m_dataLoaded = true;
 }
 
 TopDUContext* TopDUContextDynamicData::load(uint topContextIndex) {
-  QFile file(pathForTopContext(topContextIndex));
-  if(file.open(QIODevice::ReadOnly)) {
-    if(file.size() == 0) {
-      qCWarning(LANGUAGE) << "Top-context file is empty" << file.fileName();
+  TopDUContextStore store(topContextIndex);
+  if(store.open(QIODevice::ReadOnly)) {
+    if(store.size() == 0) {
+      qCWarning(LANGUAGE) << "Top-context store is empty" << store.fileName();
       return nullptr;
     }
     QVector<ItemDataInfo> contextDataOffsets;
     QVector<ItemDataInfo> declarationDataOffsets;
 
     uint readValue;
-    file.read((char*)&readValue, sizeof(uint));
+    store.read((char*)&readValue, sizeof(uint));
     //now readValue is filled with the top-context data size
-    QByteArray topContextData = file.read(readValue);
+    QByteArray topContextData = store.read(readValue);
 
     DUChainBaseData* topData = reinterpret_cast<DUChainBaseData*>(topContextData.data());
     TopDUContext* ret = dynamic_cast<TopDUContext*>(DUChainItemSystem::self().create(topData));
     if(!ret) {
-      qCWarning(LANGUAGE) << "Cannot load a top-context from file" << file.fileName() << "- the required language-support for handling ID" << topData->classId << "is probably not loaded";
+      qCWarning(LANGUAGE) << "Cannot load a top-context from store" << store.fileName() << "- the required language-support for handling ID" << topData->classId << "is probably not loaded";
       return nullptr;
     }
 
@@ -630,12 +630,22 @@ void TopDUContextDynamicData::deleteOnDisk() {
 
   m_onDisk = false;
 
-  bool successfullyRemoved = QFile::remove(filePath());
+  bool successfullyRemoved = TopDUContextStore::remove(m_topContext->ownIndex());
   Q_UNUSED(successfullyRemoved);
   Q_ASSERT(successfullyRemoved);
   qCDebug(LANGUAGE) << "deletion ready";
 }
 
+QString TopDUContextDynamicData::basePath()
+{
+  return globalItemRepositoryRegistry().path() + "/topcontexts/";
+}
+
+QString TopDUContextDynamicData::pathForTopContext(const uint topContextIndex)
+{
+  return basePath() + QString::number(topContextIndex);
+}
+
 QString KDevelop::TopDUContextDynamicData::filePath() const {
   return pathForTopContext(m_topContext->ownIndex());
 }
@@ -650,6 +660,102 @@ bool TopDUContextDynamicData::hasChanged() const
 void TopDUContextDynamicData::store() {
 //   qCDebug(LANGUAGE) << "storing" << m_topContext->url().str() << m_topContext->ownIndex() << "import-count:" << m_topContext->importedParentContexts().size();
 
+#ifdef KDEV_TOPCONTEXTS_DB_TESTING
+      static bool testdone = false;
+      if (!testdone) {
+        quint64 val = 0xdeadbeefcafebabe;
+#ifdef KDEV_TOPCONTEXTS_USE_LMDB
+        TopDUContextLMDB testwrite1(-1);
+        if (!testwrite1.errorString().isEmpty()) {
+            qWarning() << "While creating testwrite1:" << testwrite1.errorString();
+        }
+        if(testwrite1.open(QIODevice::WriteOnly)) {
+          testwrite1.write((char*)&val, sizeof(val));
+          testwrite1.commit();
+            if (!testwrite1.errorString().isEmpty()) {
+                qWarning() << "While committing testwrite1:" << testwrite1.errorString();
+            }
+        } else {
+            qWarning() << "Cannot open LMDB test store item for writing:" << testwrite1.errorString();
+        }
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_LEVELDB
+        TopDUContextLevelDB testwrite2(-1);
+        if (!testwrite2.errorString().isEmpty()) {
+            qWarning() << "While creating testwrite2:" << testwrite2.errorString();
+        }
+        if(testwrite2.open(QIODevice::WriteOnly)) {
+          testwrite2.write((char*)&val, sizeof(val));
+          testwrite2.commit();
+            if (!testwrite2.errorString().isEmpty()) {
+                qWarning() << "While committing testwrite2:" << testwrite2.errorString();
+            }
+        } else {
+            qWarning() << "Cannot open LevelDB test store item for writing:" << testwrite2.errorString();
+        }
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_KYOTO
+        TopDUContextKyotoCabinet testwrite3(-1);
+        if (!testwrite3.errorString().isEmpty()) {
+            qWarning() << "While creating testwrite3:" << testwrite3.errorString();
+        }
+        if(testwrite3.open(QIODevice::WriteOnly)) {
+          testwrite3.write((char*)&val, sizeof(val));
+          testwrite3.commit();
+            if (!testwrite3.errorString().isEmpty()) {
+                qWarning() << "While committing testwrite3:" << testwrite3.errorString();
+            }
+        } else {
+            qWarning() << "Cannot open KyotoCabinet test store item for writing:" << testwrite3.errorString();
+        }
+#endif
+
+#ifdef KDEV_TOPCONTEXTS_USE_LMDB
+        TopDUContextLMDB testread1(-1);
+        if (!testread1.errorString().isEmpty()) {
+            qWarning() << "While creating testread1:" << testread1.errorString();
+        }
+        if (testread1.open(QIODevice::ReadOnly)) {
+          QByteArray testval = testread1.readAll();
+          quint64 rval = *(reinterpret_cast<const quint64*>(testval.constData()));
+          qWarning() << "LMDB test read:" << testval.toHex() << "size=" << testval.size()
+            << "val=" << rval;
+        } else {
+            qWarning() << "Cannot open LMDB test store item for reading:" << testread1.errorString();
+        }
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_LEVELDB
+        TopDUContextLevelDB testread2(-1);
+        if (!testread2.errorString().isEmpty()) {
+            qWarning() << "While creating testread2:" << testread2.errorString();
+        }
+        if (testread2.open(QIODevice::ReadOnly)) {
+          QByteArray testval = testread2.readAll();
+          quint64 rval = *(reinterpret_cast<const quint64*>(testval.constData()));
+          qWarning() << "LevelDB test read:" << testval.toHex() << "size=" << testval.size()
+            << "val=" << rval;
+        } else {
+            qWarning() << "Cannot open LevelDB test store item for reading:" << testread2.errorString();
+        }
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_KYOTO
+        TopDUContextKyotoCabinet testread3(-1);
+        if (!testread3.errorString().isEmpty()) {
+            qWarning() << "While creating testread3:" << testread3.errorString();
+        }
+        if (testread3.open(QIODevice::ReadOnly)) {
+          QByteArray testval = testread3.readAll();
+          quint64 rval = *(reinterpret_cast<const quint64*>(testval.constData()));
+          qWarning() << "KyotoCabinet test read:" << testval.toHex() << "size=" << testval.size()
+            << "val=" << rval;
+        } else {
+            qWarning() << "Cannot open KyotoCabinet test store item for reading:" << testread3.errorString();
+        }
+#endif
+        testdone = true;
+      }
+#endif //KDEV_TOPCONTEXTS_DB_TESTING
+
   //Check if something has changed. If nothing has changed, don't store to disk.
   bool contentDataChanged = hasChanged();
   if (!contentDataChanged) {
@@ -713,32 +819,55 @@ void TopDUContextDynamicData::store() {
 
     QDir().mkpath(basePath());
 
-    QFile file(filePath());
-    if(file.open(QIODevice::WriteOnly)) {
+    QElapsedTimer timer;
+    qint64 nBytes = 0;
+    if (Q_LIKELY(QFileInfo(basePath()).isWritable())) {
+      timer.start();
+      TopDUContextStore store(m_topContext->ownIndex());
+      if(store.open(QIODevice::WriteOnly)) {
 
-      file.resize(0);
+        store.resize(0);
 
-      file.write((char*)&topContextDataSize, sizeof(uint));
-      foreach(const ArrayWithPosition& pos, m_topContextData)
-        file.write(pos.array.constData(), pos.position);
+        store.write((char*)&topContextDataSize, sizeof(uint));
+        foreach(const ArrayWithPosition& pos, m_topContextData)
+          store.write(pos.array.constData(), pos.position);
 
-      m_contexts.writeData(&file);
-      m_declarations.writeData(&file);
-      m_problems.writeData(&file);
+        m_contexts.writeData(&store);
+        m_declarations.writeData(&store);
+        m_problems.writeData(&store);
 
-      foreach(const ArrayWithPosition& pos, m_data)
-        file.write(pos.array.constData(), pos.position);
+        foreach(const ArrayWithPosition& pos, m_data)
+          store.write(pos.array.constData(), pos.position);
 
-      m_onDisk = true;
+        m_onDisk = true;
 
-      if (file.size() == 0) {
-        qCWarning(LANGUAGE) << "Saving zero size top ducontext data";
+        nBytes = store.size();
+        if (store.size() == 0) {
+          qCWarning(LANGUAGE) << "Saving zero size top ducontext data";
+        }
+        store.commit();
+      } else {
+        qCWarning(LANGUAGE) << "Cannot open topcontext" << store.fileName() << "for writing:" << store.errorString();
       }
-      file.close();
+//     qCDebug(LANGUAGE) << "stored" << m_topContext->url().str() << m_topContext->ownIndex() << "import-count:" << m_topContext->importedParentContexts().size();
     } else {
-      qCWarning(LANGUAGE) << "Cannot open top-context for writing";
+      static bool warned = false;
+      if (!warned) {
+        qCWarning(LANGUAGE) << "Topcontexts directory" << basePath() << "is not writable, topcontext files won't be stored.";
+        warned = true;
+      }
+    }
+    if (timer.isValid()) {
+      auto elapsed = timer.elapsed();
+      static quint64 totalBytes = 0;
+      static double totalElapsed = 0.0;
+      totalBytes += nBytes;
+      totalElapsed += elapsed / 1000.0;
+      if (totalBytes && totalElapsed >= 0.5) {
+        qCInfo(LANGUAGE) << "Stored" << totalBytes << "topcontext bytes at" << totalBytes / totalElapsed << "bytes/second";
+        totalBytes = 0, totalElapsed = 0.0;
+      }
     }
-//   qCDebug(LANGUAGE) << "stored" << m_topContext->url().str() << m_topContext->ownIndex() << "import-count:" << m_topContext->importedParentContexts().size();
 }
 
 TopDUContextDynamicData::ItemDataInfo TopDUContextDynamicData::writeDataInfo(const ItemDataInfo& info, const DUChainBaseData* data, uint& totalDataOffset) {
diff --git a/kdevplatform/language/duchain/topducontextdynamicdata.h b/kdevplatform/language/duchain/topducontextdynamicdata.h
index 1212afc73cd56bcbdbeca45d699154b0181f79ad..870e8fc242c8a6d22671141e7c96a1b5c614ddab 100644
--- a/kdevplatform/language/duchain/topducontextdynamicdata.h
+++ b/kdevplatform/language/duchain/topducontextdynamicdata.h
@@ -21,10 +21,9 @@
 
 #include <QVector>
 #include <QByteArray>
+#include <QFile>
 #include "problem.h"
 
-class QFile;
-
 namespace KDevelop {
 
 class TopDUContext;
@@ -34,6 +33,18 @@ class IndexedString;
 class IndexedDUContext;
 class DUChainBaseData;
 
+#ifdef KDEV_TOPCONTEXTS_USE_FILES
+using TopDUContextStore = TopDUContextFile;
+#elif defined(KDEV_TOPCONTEXTS_USE_LMDB)
+using TopDUContextStore = TopDUContextLMDB;
+#elif defined(KDEV_TOPCONTEXTS_USE_LEVELDB)
+using TopDUContextStore = TopDUContextLevelDB;
+#elif defined(KDEV_TOPCONTEXTS_USE_KYOTO)
+using TopDUContextStore = TopDUContextKyotoCabinet;
+#else
+class TopDUContextStore;
+#endif
+
 ///This class contains dynamic data of a top-context, and also the repository that contains all the data within this top-context.
 class TopDUContextDynamicData {
   public:
@@ -118,6 +129,9 @@ class TopDUContextDynamicData {
     uint position;
   };
 
+  static QString basePath();
+  static QString pathForTopContext(const uint topContextIndex);
+
   private:
     bool hasChanged() const;
 
@@ -153,8 +167,8 @@ class TopDUContextDynamicData {
       void deleteOnDisk();
       bool isItemForIndexLoaded(uint index) const;
 
-      void loadData(QFile* file) const;
-      void writeData(QFile* file);
+      void loadData(TopDUContextStore* file) const;
+      void writeData(TopDUContextStore* file);
 
       //May contain zero items if they were deleted
       mutable QVector<Item> items;
@@ -174,7 +188,7 @@ class TopDUContextDynamicData {
     bool m_onDisk;
     mutable bool m_dataLoaded;
 
-    mutable QFile* m_mappedFile;
+    mutable TopDUContextStore* m_mappedFile;
     mutable uchar* m_mappedData;
     mutable size_t m_mappedDataSize;
     mutable bool m_itemRetrievalForbidden;
diff --git a/kdevplatform/language/duchain/topducontextdynamicdata_p.cpp b/kdevplatform/language/duchain/topducontextdynamicdata_p.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..bdefb7cc0be4820a6281f6d474f3561117bf6bc6
--- /dev/null
+++ b/kdevplatform/language/duchain/topducontextdynamicdata_p.cpp
@@ -0,0 +1,1023 @@
+/* This  is part of KDevelop
+
+   Copyright 2018 R.J.V. Bertin <rjvbertin@gmail.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "topducontextdynamicdata_p.h"
+#include "topducontextdynamicdata.h"
+
+#include <QFileInfo>
+
+#ifndef KDEV_TOPCONTEXTS_USE_FILES
+#ifdef KDEV_TOPCONTEXTS_USE_LMDB
+#include <lmdb++.h>
+#else
+#define MDB_RDONLY 0x20000
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_LEVELDB
+#include <leveldb/db.h>
+#include <leveldb/comparator.h>
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_KYOTO
+#include <kcpolydb.h>
+#endif
+#endif
+
+#include <debug.h>
+
+//#define DEBUG_DATA_INFO
+
+using namespace KDevelop;
+
+#ifndef KDEV_TOPCONTEXTS_USE_FILES
+
+bool TopDUContextDB::open(QIODevice::OpenMode mode, const QString& backendName)
+{
+  if (isValid() && !m_currentKey.isEmpty()) {
+    int lmMode = mode == QIODevice::ReadOnly ? MDB_RDONLY : 0;
+    if (lmMode == MDB_RDONLY && !currentKeyExists()) {
+      // migration: see if the index file exists
+      if (migrateFromFile()) {
+        return true;
+      }
+      m_errorString = QStringLiteral("No item #") + QByteArray::number(m_currentIndex) + QStringLiteral(" in database");
+      return false;
+    }
+    m_mode = lmMode;
+    m_currentValue.clear();
+    m_currentLen = 0;
+    m_readCursor = -1;
+    m_errorString.clear();
+    return true;
+  }
+  m_errorString = QStringLiteral("%1 database backend not initialised properly").arg(backendName);
+  return false;
+}
+
+QString TopDUContextDB::fileName() const
+{
+  return TopDUContextDynamicData::basePath() + "...#" + QByteArray::number(m_currentIndex);
+}
+
+QString TopDUContextDB::errorString() const
+{
+  return m_errorString;
+}
+
+bool TopDUContextDB::resize(qint64)
+{
+  return m_mode != MDB_RDONLY;
+}
+
+qint64 TopDUContextDB::write(const char* data, qint64 len)
+{
+#ifdef KDEV_TOPCONTEXTS_DB_TESTING
+#ifdef KDEV_TOPCONTEXTS_USE_LEVELDB
+  if (lvldbStore) {
+    reinterpret_cast<TopDUContextLevelDB*>(lvldbStore)->write(data, len);
+  }
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_KYOTO
+  if (kyodbStore) {
+    reinterpret_cast<TopDUContextKyotoCabinet*>(kyodbStore)->write(data, len);
+  }
+#endif
+#endif
+  if (m_mode != MDB_RDONLY) {
+    m_currentValue.append(QByteArray::fromRawData(data, len));
+    m_currentLen += len;
+    return len;
+  }
+  return 0;
+}
+
+// read the current key value into m_currentValue if necessary, and return the
+// requested @p maxSize bytes from the current read position in @p data. Update
+// the read position afterwards, and reset m_currentValue when all data has
+// been returned.
+// Special case: data==NULL and maxSize==-1; return the number of remaining bytes
+// and do NOT reset m_currentValue
+qint64 TopDUContextDB::read(char* data, qint64 maxSize)
+{
+  if (isValid() && !m_currentKey.isEmpty() && m_mode == MDB_RDONLY) {
+    if (!getCurrentKeyValue()) {
+      return -1;
+    }
+    if (m_readCursor >= 0 && m_readCursor < m_currentLen) {
+      qint64 rlen = m_currentLen - m_readCursor;
+      if (Q_LIKELY(maxSize >= 0)) {
+          if (maxSize < rlen) {
+              rlen = maxSize;
+          }
+          const char *val = m_currentValue.constData();
+          memcpy(data, &val[m_readCursor], rlen);
+          m_readCursor += rlen;
+          if (m_readCursor >= m_currentLen) {
+            // all read, clear the cache
+            m_currentValue.clear();
+            m_currentLen = 0;
+            m_readCursor = -1;
+          }
+      } else {
+          // special case: don't update m_readCursor;
+      }
+      return rlen;
+    }
+  }
+  return -1;
+}
+
+QByteArray TopDUContextDB::read(qint64 maxSize)
+{
+  QByteArray data;
+  data.resize(maxSize);
+  auto len = read(data.data(), maxSize);
+  data.resize(len >= 0 ? len : 0);
+  return data;
+}
+
+// Reads all the remaining data, returned as a QByteArray
+QByteArray TopDUContextDB::readAll()
+{
+  QByteArray data;
+  auto readLen = read(nullptr, -1);
+  if (readLen > 0) {
+    // should always be true:
+    if (Q_LIKELY(m_readCursor >= 0 && m_readCursor + readLen <= m_currentValue.size())) {
+      if (m_readCursor == 0) {
+        data = m_currentValue;
+      } else {
+        data.resize(readLen);
+        const char *val = m_currentValue.constData();
+        memcpy(data.data(), &val[m_readCursor], readLen);
+      }
+    } else {
+      qCWarning(LANGUAGE) << Q_FUNC_INFO << "m_readCursor=" << m_readCursor << "readLen=" << readLen
+        << "m_currentValue.size=" << m_currentValue.size();
+      if (readLen == m_currentValue.size()) {
+        // m_readCursor should have been 0!!!
+        qCWarning(LANGUAGE) << "\tm_readCursor should have been 0!!";
+        data = m_currentValue;
+      }
+    }
+    // all read, clear the cache
+    m_currentValue.clear();
+    m_currentLen = 0;
+    m_readCursor = -1;
+  }
+  return data;
+}
+
+qint64 TopDUContextDB::pos() const
+{
+  return m_readCursor < 0 ? 0 : m_readCursor;
+}
+
+bool TopDUContextDB::seek(qint64 pos)
+{
+  if (pos <= m_currentLen) {
+    m_readCursor = pos;
+    return true;
+  }
+  return false;
+}
+
+qint64 TopDUContextDB::size()
+{
+  if (!m_currentLen && m_mode == MDB_RDONLY) {
+    // cache the key value
+    read(nullptr, -1);
+  }
+  return m_currentLen;
+}
+
+QByteArray TopDUContextDB::indexKey(uint idx)
+{
+  return QByteArray::number(idx);
+}
+
+// NB: @p idx must point to a variable that will not be outlived by the returned QByteArray!
+QByteArray TopDUContextDB::indexKey(uint* idx)
+{
+  return QByteArray::fromRawData(reinterpret_cast<const char*>(idx), sizeof(uint));
+}
+
+bool TopDUContextDB::migrateFromFile()
+{
+  TopDUContextFile migrateFile(m_currentIndex);
+  if (migrateFile.open(QIODevice::ReadOnly)) {
+    // should we care about empty files here?
+    qCDebug(LANGUAGE) << "Migrating" << migrateFile.fileName();
+    const QByteArray content = migrateFile.readAll();
+    migrateFile.close();
+    m_mode = 0;
+    m_currentValue = content;
+    m_currentLen = content.size();
+    // commit() will reset the key so we need to cache it
+    const QByteArray key = m_currentKey;
+    m_errorString.clear();
+    commit();
+    if (m_errorString.isEmpty()) {
+      // migration was successful, remove the file
+      QFile::remove(migrateFile.fileName());
+    }
+    m_errorString.clear();
+    // take care that we don't have to read the data back in
+    m_currentKey = key;
+    m_currentValue = content;
+    m_currentLen = content.size();
+    m_readCursor = 0;
+    m_mode = MDB_RDONLY;
+    return true;
+  }
+  return false;
+}
+
+#ifdef KDEV_TOPCONTEXTS_USE_LMDB
+// TopDUContextLMDB : wraps the QFile API needed for TopDUContexts around LMDB
+
+static QString lmdbxx_exception_handler(const lmdb::error& e, const QString& operation)
+{
+  const QString msg = QStringLiteral("LMDB exception in \"%1\": %2").arg(operation).arg(e.what());
+  qCWarning(LANGUAGE) << msg;
+  if (qEnvironmentVariableIsSet("KDEV_TOPCONTEXTS_STORE_FAILURE_ABORT")) {
+    qFatal(msg.toLatin1());
+  }
+  return msg;
+}
+
+// there is exactly 1 topcontexts directory per session, so we can make do with a single
+// global static LMDB env instance which is not exported at all (= no need to include
+// lmdb.h and/or lmdbxx.h in our own headerfile).
+static lmdb::env lmdbEnv{nullptr};
+bool TopDUContextLMDB::s_envExists = false;
+// set the initial map size to 64Mb
+size_t TopDUContextLMDB::s_mapSize = 1024UL * 1024UL * 64UL;
+
+TopDUContextLMDB::TopDUContextLMDB(uint topContextIndex)
+{
+  if (!s_envExists && Q_LIKELY(QFileInfo(TopDUContextDynamicData::basePath()).isWritable())) {
+    try {
+      lmdbEnv = lmdb::env::create();
+      lmdbEnv.open(TopDUContextDynamicData::basePath().toLatin1().constData());
+      MDB_envinfo stat;
+      lmdb::env_info(lmdbEnv.handle(), &stat);
+      if (stat.me_mapsize > s_mapSize) {
+        s_mapSize = stat.me_mapsize;
+      }
+      lmdbEnv.set_mapsize(s_mapSize);
+      s_envExists = true;
+      qCDebug(LANGUAGE) << "lmdbEnv=" << lmdbEnv << "mapsize=" << stat.me_mapsize;
+    }
+    catch (const lmdb::error& e) {
+      m_errorString = lmdbxx_exception_handler(e, QStringLiteral("database creation"));
+    }
+  }
+  if (s_envExists) {
+    m_currentIndex = topContextIndex;
+    m_currentKey = indexKey(m_currentIndex);
+#ifdef KDEV_TOPCONTEXTS_DB_TESTING
+#ifdef KDEV_TOPCONTEXTS_USE_LEVELDB
+    auto ltest = new TopDUContextLevelDB(topContextIndex);
+    if (!ltest->errorString().isEmpty()) {
+      qWarning() << "While creating LevelDB test for" << topContextIndex << ":" << ltest->errorString();
+    }
+    lvldbStore = reinterpret_cast<void*>(ltest);
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_KYOTO
+    auto ktest = new TopDUContextKyotoCabinet(topContextIndex);
+    if (!ktest->errorString().isEmpty()) {
+      qWarning() << "While creating LevelDB test for" << topContextIndex << ":" << ktest->errorString();
+    }
+    kyodbStore = reinterpret_cast<void*>(ktest);
+#endif
+#endif
+  }
+  m_currentLen = -1;
+  // the remaining member vars are initialised elsewhere intentionally.
+}
+
+TopDUContextLMDB::~TopDUContextLMDB()
+{
+#ifdef KDEV_TOPCONTEXTS_DB_TESTING
+#ifdef KDEV_TOPCONTEXTS_USE_LEVELDB
+  if (lvldbStore) {
+    delete reinterpret_cast<TopDUContextLevelDB*>(lvldbStore);
+  }
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_KYOTO
+  if (kyodbStore) {
+    delete reinterpret_cast<TopDUContextKyotoCabinet*>(kyodbStore);
+  }
+#endif
+#endif
+  if (s_envExists) {
+    // todo: use a refcounting scheme to know when to close lmdbEnv?
+    try {
+      lmdbEnv.sync();
+    }
+    catch (const lmdb::error& e) {
+      m_errorString = lmdbxx_exception_handler(e, QStringLiteral("database flush"));
+    }
+  }
+}
+
+bool TopDUContextLMDB::open(QIODevice::OpenMode mode)
+{
+#ifdef KDEV_TOPCONTEXTS_DB_TESTING
+#ifdef KDEV_TOPCONTEXTS_USE_LEVELDB
+  if (lvldbStore) {
+    reinterpret_cast<TopDUContextLevelDB*>(lvldbStore)->open(mode);
+  }
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_KYOTO
+  if (kyodbStore) {
+    reinterpret_cast<TopDUContextKyotoCabinet*>(kyodbStore)->open(mode);
+  }
+#endif
+#endif
+  return TopDUContextDB::open(mode, QStringLiteral("LMDB"));
+}
+
+void TopDUContextLMDB::commit()
+{
+#ifdef KDEV_TOPCONTEXTS_DB_TESTING
+#ifdef KDEV_TOPCONTEXTS_USE_LEVELDB
+  if (lvldbStore) {
+    reinterpret_cast<TopDUContextLevelDB*>(lvldbStore)->commit();
+  }
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_KYOTO
+  if (kyodbStore) {
+    reinterpret_cast<TopDUContextKyotoCabinet*>(kyodbStore)->commit();
+  }
+#endif
+#endif
+  if (s_envExists && m_mode != MDB_RDONLY) {
+    if (m_currentValue.size() != m_currentLen) {
+      // m_currentLen is the true size
+      qCDebug(LANGUAGE) << "TopDUContextLMDB index" << QByteArray::number(m_currentIndex) << "internal size mismatch:"
+        << m_currentValue.size() << "vs" << m_currentLen;
+    }
+    // ensure that there's a NUL byte at the end (after the range we'll commit to the store)
+    if (!m_currentValue.endsWith('\0')) {
+      m_currentValue.append('\0');
+    }
+    lmdb::val key(m_currentKey.constData(), m_currentKey.size());
+    lmdb::val value(m_currentValue.constData(), m_currentLen);
+    try {
+      auto txn = lmdb::txn::begin(lmdbEnv);
+      auto dbi = lmdb::dbi::open(txn, nullptr);
+      try {
+        lmdb::dbi_put(txn, dbi, key, value);
+        txn.commit();
+      }
+      catch (const lmdb::error& e) {
+        if (e.code() == MDB_MAP_FULL) {
+          try {
+            qCDebug(LANGUAGE) << "aborting LMDB write to grow mapsize";
+            txn.abort();
+            lmdb::dbi_close(lmdbEnv, dbi);
+            s_mapSize *= 2;
+            qCDebug(LANGUAGE) << "\tgrowing mapsize to" << s_mapSize;
+            lmdbEnv.set_mapsize(s_mapSize);
+            commit();
+          }
+          catch (const lmdb::error& e) {
+            m_errorString = lmdbxx_exception_handler(e, QStringLiteral("growing mapsize to ") + QString::number(s_mapSize));
+          }
+        } else {
+          m_errorString = lmdbxx_exception_handler(e, QStringLiteral("committing index ")
+            + QByteArray::number(m_currentIndex) + " size " + QString::number(m_currentLen));
+        }
+      }
+    }
+    catch (const lmdb::error& e) {
+      m_errorString = lmdbxx_exception_handler(e, QStringLiteral("committing index ")
+        + QByteArray::number(m_currentIndex) + " size " + QString::number(m_currentLen));
+    }
+    m_currentKey.clear();
+    m_currentValue.clear();
+    m_currentLen = 0;
+  }
+}
+
+bool TopDUContextLMDB::getCurrentKeyValue()
+{
+  // we only return false if a read error occurred; if a key doesn't exist
+  // m_currentValue will remain empty.
+  bool ret = true;
+  if (m_currentValue.isEmpty()) {
+    // read the key value from storage into cache
+    try {
+      auto rtxn = lmdb::txn::begin(lmdbEnv, nullptr, MDB_RDONLY);
+      auto dbi = lmdb::dbi::open(rtxn, nullptr);
+      auto cursor = lmdb::cursor::open(rtxn, dbi);
+      lmdb::val key(m_currentKey.constData(), m_currentKey.size());
+      lmdb::val val{};
+      bool found = cursor.get(key, val, MDB_SET);
+      if (found) {
+        m_currentValue = QByteArray(val.data(), val.size());
+        m_currentLen = m_currentValue.size();
+        m_readCursor = 0;
+      }
+      cursor.close();
+      rtxn.abort();
+    }
+    catch (const lmdb::error& e) {
+      m_errorString = lmdbxx_exception_handler(e, QStringLiteral("reading index ") + QByteArray::number(m_currentIndex));
+      ret = false;
+    }
+#ifdef KDEV_TOPCONTEXTS_DB_TESTING
+#ifdef KDEV_TOPCONTEXTS_USE_LEVELDB
+    if (lvldbStore) {
+      QByteArray temp = reinterpret_cast<TopDUContextLevelDB*>(lvldbStore)->readAll();
+      if (temp != m_currentValue) {
+        qWarning() << "LevelDB backend returns len=" << temp.size() << "instead of" << m_currentLen;
+        if (temp.size() < 132 && m_currentLen < 132) {
+          qWarning() << "! leveldb:" << temp.toHex();
+          qWarning() << "! LMDB:" << m_currentValue.toHex();
+        }
+        qWarning() << "! leveldb=" << *(reinterpret_cast<const uint*>(temp.constData()))
+          << "LMDB=" << *(reinterpret_cast<const uint*>(m_currentValue.constData()));
+      }
+    }
+#endif
+#ifdef KDEV_TOPCONTEXTS_USE_KYOTO
+    if (kyodbStore) {
+      QByteArray temp = reinterpret_cast<TopDUContextKyotoCabinet*>(kyodbStore)->readAll();
+      if ((temp.size() != m_currentValue.size() || temp != m_currentValue) && reinterpret_cast<TopDUContextKyotoCabinet*>(kyodbStore)->exists(m_currentIndex)) {
+        qWarning() << "KyotoCabinet backend returns len=" << temp.size() << "instead of" << m_currentLen;
+        if (temp.size() < 132 && m_currentLen < 132) {
+          qWarning() << "! KyotoCabinet:" << temp.toHex();
+          qWarning() << "! LMDB:" << m_currentValue.toHex();
+        }
+        qWarning() << "! KyotoCabinet=" << *(reinterpret_cast<const uint*>(temp.constData()))
+          << "LMDB=" << *(reinterpret_cast<const uint*>(m_currentValue.constData()));
+      }
+    }
+#endif
+#endif
+  }
+  return ret;
+}
+
+bool TopDUContextLMDB::isValid()
+{
+  return s_envExists;
+}
+
+bool TopDUContextLMDB::currentKeyExists()
+{
+  return exists(m_currentKey);
+}
+
+bool TopDUContextLMDB::exists(const QByteArray& key)
+{
+  if (lmdbEnv.handle() != nullptr) {
+    try {
+      auto rtxn = lmdb::txn::begin(lmdbEnv, nullptr, MDB_RDONLY);
+      auto dbi = lmdb::dbi::open(rtxn, nullptr);
+      auto cursor = lmdb::cursor::open(rtxn, dbi);
+      lmdb::val k(key.constData(), key.size());
+      bool ret = cursor.get(k, nullptr, MDB_SET);
+      cursor.close();
+      rtxn.abort();
+      return ret;
+    }
+    catch (const lmdb::error& e) {
+      lmdbxx_exception_handler(e, QStringLiteral("checking for index") + key);
+    }
+  }
+  return false;
+}
+
+QString TopDUContextLMDB::fileName() const
+{
+  return TopDUContextDynamicData::basePath() + "data.mdb" + ":#" + QByteArray::number(m_currentIndex);
+}
+
+bool TopDUContextLMDB::exists(uint topContextIndex)
+{
+  return exists(indexKey(topContextIndex));
+}
+
+bool TopDUContextLMDB::remove(uint topContextIndex)
+{
+  if (s_envExists) {
+    const auto key = indexKey(topContextIndex);
+    lmdb::val k{key.constData(), static_cast<size_t>(key.size())};
+    try {
+      auto txn = lmdb::txn::begin(lmdbEnv);
+      auto dbi = lmdb::dbi::open(txn, nullptr);
+      bool ret = lmdb::dbi_del(txn, dbi, k, nullptr);
+      txn.commit();
+      lmdbEnv.sync();
+      // also remove the file if it (still) exists
+      QFile::remove(TopDUContextDynamicData::pathForTopContext(topContextIndex));
+      return ret;
+    }
+    catch (const lmdb::error& e) {
+      lmdbxx_exception_handler(e, QStringLiteral("removing index %1").arg(topContextIndex));
+    }
+  }
+  return false;
+}
+#endif
+
+#ifdef KDEV_TOPCONTEXTS_USE_LEVELDB
+// LevelDB storage backend
+static QString leveldb_exception_handler(const std::exception& e, const QString& operation)
+{
+  const QString msg = QStringLiteral("LevelDB exception in \"%1\": %2").arg(operation).arg(e.what());
+  qCWarning(LANGUAGE) << msg;
+  if (qEnvironmentVariableIsSet("KDEV_TOPCONTEXTS_STORE_FAILURE_ABORT")) {
+    qFatal(msg.toLatin1());
+  }
+  return msg;
+}
+
+// our keys are uint values and stored as uint* in the original QByteArray m_currentKey
+// use that knowledge to avoid sorting lexographically.
+class QuickSortingComparator : public leveldb::Comparator {
+ public:
+  // Comparison function that doesn't result in any sorting
+  int Compare(const leveldb::Slice& a, const leveldb::Slice& b) const
+  {
+    const uint *ia = reinterpret_cast<const uint*>(a.data());
+    const uint *ib = reinterpret_cast<const uint*>(b.data());
+    return *ia - *ib;
+  }
+
+  const char* Name() const { return "QuickSortingComparator"; }
+  void FindShortestSeparator(std::string*, const leveldb::Slice&) const {}
+  void FindShortSuccessor(std::string*) const {}
+};
+static QuickSortingComparator leveldbComparator;
+
+// there is exactly 1 topcontexts directory per session, so we can make do with a single
+// global static LevelDB instance which is not exported at all (= no need to include
+// db.h in our own headerfile).
+
+class LevelDBHook {
+public:
+  ~LevelDBHook()
+  {
+    if (s_levelDB) {
+      delete s_levelDB;
+    }
+  }
+
+  static const leveldb::Status init()
+  {
+    leveldb::Options options;
+    options.create_if_missing = true;
+    options.comparator = &leveldbComparator;
+    int attempts = 0;
+    leveldb::Status status;
+    do {
+      attempts += 1;
+      leveldb::Status status = leveldb::DB::Open(options, TopDUContextDynamicData::basePath().toStdString(), &s_levelDB);
+      if (!status.ok()) {
+        s_levelDB = nullptr;
+        if (status.IsInvalidArgument()) {
+          // retry opening a fresh store
+          leveldb::DestroyDB(TopDUContextDynamicData::basePath().toStdString(), options);
+        }
+      }
+    } while (!s_levelDB && attempts < 2);
+    return status;
+  }
+
+  inline leveldb::DB* instance()
+  {
+    return s_levelDB;
+  }
+
+  static leveldb::DB* s_levelDB;
+};
+static LevelDBHook levelDB;
+
+leveldb::DB* LevelDBHook::s_levelDB = nullptr;
+uint TopDUContextLevelDB::s_DbRefCount = 0;
+
+TopDUContextLevelDB::TopDUContextLevelDB(uint topContextIndex)
+{
+  if (!levelDB.instance() && Q_LIKELY(QFileInfo(TopDUContextDynamicData::basePath()).isWritable())) {
+    leveldb::Status status = LevelDBHook::init();
+    if (!status.ok()) {
+      m_errorString = QStringLiteral("Error opening LevelDB database:") + QString::fromStdString(status.ToString());
+      qCWarning(LANGUAGE) << m_errorString;
+    }
+  }
+  if (levelDB.instance()) {
+    m_currentIndex = topContextIndex;
+    m_currentKey = indexKey(&m_currentIndex);
+    s_DbRefCount += 1;
+  }
+  m_currentLen = -1;
+  // the remaining member vars are initialised elsewhere intentionally.
+}
+
+TopDUContextLevelDB::~TopDUContextLevelDB()
+{
+  if (levelDB.instance()) {
+    s_DbRefCount -= 1;
+    if (s_DbRefCount <= 0) {
+      // optimisation: don't delete the global DB handle; too many TopDUContextLevelDB
+      // instances are created too frequently that are deleted immediately after a
+      // single use.
+      s_DbRefCount = 0;
+    }
+  } else {
+    s_DbRefCount = 0;
+  }
+}
+
+bool TopDUContextLevelDB::open(QIODevice::OpenMode mode)
+{
+  return TopDUContextDB::open(mode, QStringLiteral("LevelDB"));
+}
+
+void TopDUContextLevelDB::commit()
+{
+  if (isValid() && m_mode != MDB_RDONLY) {
+    if (m_currentValue.size() != m_currentLen) {
+      // m_currentLen is the true size
+      qCDebug(LANGUAGE) << "TopDUContextLevelDB index" << QByteArray::number(m_currentIndex) << "internal size mismatch:"
+        << m_currentValue.size() << "vs" << m_currentLen;
+    }
+    leveldb::Status status;
+    leveldb::Slice key(m_currentKey.constData(), m_currentKey.size());
+    leveldb::Slice value(m_currentValue.constData(), m_currentLen);
+    try {
+      status = levelDB.instance()->Put(leveldb::WriteOptions(), key, value);
+    }
+    catch (const std::exception& e) {
+        m_errorString = leveldb_exception_handler(e, QStringLiteral("committing value for ") + QByteArray::number(m_currentIndex));
+        qCWarning(LANGUAGE) << m_errorString;
+    }
+    if (!status.ok()) {
+      m_errorString = QStringLiteral("Error committing index ")
+        + QByteArray::number(m_currentIndex) + " size " + QString::number(m_currentLen)
+        + QStringLiteral(": ") + QString::fromStdString(status.ToString());
+      qCWarning(LANGUAGE) << m_errorString;
+    }
+    m_currentKey.clear();
+    m_currentValue.clear();
+    m_currentLen = 0;
+  }
+}
+
+bool TopDUContextLevelDB::getCurrentKeyValue()
+{
+  // we only return false if a read error occurred; if a key doesn't exist
+  // m_currentValue will remain empty.
+  bool ret = true;
+  if (m_currentValue.isEmpty()) {
+    // read the key value from storage into cache
+      leveldb::Slice key(m_currentKey.constData(), m_currentKey.size());
+      std::string value;
+      leveldb::Status status = levelDB.instance()->Get(leveldb::ReadOptions(), key, &value);
+      if (status.ok()) {
+        m_currentValue = QByteArray(value.data(), value.size());
+        m_currentLen = value.size();
+        m_readCursor = 0;
+      } else if (status.IsCorruption() || status.IsIOError() || status.IsNotSupportedError() || status.IsInvalidArgument()) {
+        ret = false;
+      }
+  }
+  return ret;
+}
+
+bool TopDUContextLevelDB::isValid()
+{
+  return levelDB.instance();
+}
+
+bool TopDUContextLevelDB::currentKeyExists()
+{
+  return exists(m_currentKey);
+}
+
+bool TopDUContextLevelDB::exists(const QByteArray& key)
+{
+  if (levelDB.instance()) {
+    std::string value;
+    leveldb::Slice k(key.constData(), key.size());
+    leveldb::Status status = levelDB.instance()->Get(leveldb::ReadOptions(), k, &value);
+    if (!status.ok() && !status.IsNotFound()) {
+      qCWarning(LANGUAGE) << QStringLiteral("Error checking for index") + key
+        + QStringLiteral(": ") + QString::fromStdString(status.ToString());
+      return false;
+    }
+    return status.ok();
+  }
+  return false;
+}
+
+bool TopDUContextLevelDB::exists(uint topContextIndex)
+{
+  return exists(indexKey(&topContextIndex));
+}
+
+bool TopDUContextLevelDB::remove(uint topContextIndex)
+{
+  if (isValid()) {
+    const auto key = indexKey(&topContextIndex);
+    leveldb::Slice k(key.constData(), key.size());
+    leveldb::Status status = levelDB.instance()->Delete(leveldb::WriteOptions(), k);
+    if (!status.ok()) {
+      qCWarning(LANGUAGE) << QStringLiteral("Error removing index %1").arg(topContextIndex)
+        + QStringLiteral(": ") + QString::fromStdString(status.ToString());
+      return false;
+    }
+    // also remove the file if it (still) exists
+    QFile::remove(TopDUContextDynamicData::pathForTopContext(topContextIndex));
+    return true;
+  }
+  return false;
+}
+
+#endif // KDEV_TOPCONTEXTS_USE_LEVELDB
+
+#ifdef KDEV_TOPCONTEXTS_USE_KYOTO
+using namespace kyotocabinet;
+
+static QString kyotocabinet_exception_handler(const std::exception& e, const QString& operation)
+{
+  const QString msg = QStringLiteral("KyotoCabinet exception in \"%1\": %2").arg(operation).arg(e.what());
+  qCWarning(LANGUAGE) << msg;
+  if (qEnvironmentVariableIsSet("KDEV_TOPCONTEXTS_STORE_FAILURE_ABORT")) {
+    qFatal(msg.toLatin1());
+  }
+  return msg;
+}
+
+// there is exactly 1 topcontexts directory per session, which is fine because we can only use a single
+// global static KyotoCabinet instance anyway. Wrap it in a local class which is not exported at all
+// (= no need to include kcpolydb.h in our own headerfile).
+
+class KyotoCabinetHook {
+public:
+  ~KyotoCabinetHook()
+  {
+    if (s_kyotoCab) {
+      try {
+        if (!s_kyotoCab->close()) {
+          qCWarning(LANGUAGE) << "Error closing KyotoCabinet database:" << errorString();
+        }
+        delete s_kyotoCab;
+      }
+      catch (const std::exception& e) {
+        qCWarning(LANGUAGE) << kyotocabinet_exception_handler(e, QStringLiteral("closing cabinet.kch"));
+        // don't delete s_kyotoCab if something went wrong closing the DB
+      }
+    }
+  }
+
+  static bool init()
+  {
+    s_kyotoCab= new PolyDB;
+    bool ok = false;
+    s_errorString.clear();
+    try {
+      int attempts = 0;
+      uint32_t flags = PolyDB::OWRITER | PolyDB::OCREATE;
+      do {
+        attempts += 1;
+        // #log=+#logkinds=debug
+        ok = s_kyotoCab->open(TopDUContextDynamicData::basePath().toStdString() + "cabinet.kch#opts=sc#zcomp=lzo", flags);
+        if (!ok && s_kyotoCab->error().code() == BasicDB::Error::INVALID) {
+          // try by recreating the database
+          flags = PolyDB::OWRITER | PolyDB::OTRUNCATE;
+        }
+      } while (!ok && attempts < 2);
+    }
+    catch (const std::exception& e) {
+      s_errorString = kyotocabinet_exception_handler(e, QStringLiteral("opening cabinet.kch"));
+      ok = false;
+    }
+    if (!ok) {
+      if (s_errorString.isEmpty()) {
+        s_errorString = QStringLiteral("Error opening KyotoCabinet database:")
+          + errorString();
+      }
+      delete s_kyotoCab;
+      s_kyotoCab = nullptr;
+    }
+    return s_kyotoCab;
+  }
+
+  inline PolyDB* instance()
+  {
+    return s_kyotoCab;
+  }
+
+  static inline QString errorString()
+  {
+    return QString::fromStdString(s_kyotoCab->error().name());
+  }
+
+  static PolyDB* s_kyotoCab;
+  static QString s_errorString;
+};
+static KyotoCabinetHook kyotoCabinet;
+
+PolyDB* KyotoCabinetHook::s_kyotoCab = nullptr;
+QString KyotoCabinetHook::s_errorString;
+
+uint TopDUContextKyotoCabinet::s_DbRefCount = 0;
+
+TopDUContextKyotoCabinet::TopDUContextKyotoCabinet(uint topContextIndex)
+{
+  if (!kyotoCabinet.instance() && Q_LIKELY(QFileInfo(TopDUContextDynamicData::basePath()).isWritable())) {
+    if (!kyotoCabinet.init()) {
+      m_errorString = kyotoCabinet.s_errorString;
+      qCWarning(LANGUAGE) << m_errorString;
+    }
+  }
+  if (kyotoCabinet.instance()) {
+    m_currentIndex = topContextIndex;
+    m_currentKey = indexKey(&m_currentIndex);
+    s_DbRefCount += 1;
+  }
+  m_currentLen = -1;
+  // the remaining member vars are initialised elsewhere intentionally.
+}
+
+TopDUContextKyotoCabinet::~TopDUContextKyotoCabinet()
+{
+  if (kyotoCabinet.instance()) {
+    s_DbRefCount -= 1;
+    if (s_DbRefCount <= 0) {
+      // optimisation: don't delete the global DB handle; too many TopDUContextKyotoCabinet
+      // instances are created too frequently that are deleted immediately after a
+      // single use.
+      s_DbRefCount = 0;
+    }
+    kyotoCabinet.instance()->synchronize(s_DbRefCount == 0);
+  } else {
+    s_DbRefCount = 0;
+  }
+}
+
+QString TopDUContextKyotoCabinet::fileName() const
+{
+  return TopDUContextDynamicData::basePath() + "cabinet.kch:#" + QByteArray::number(m_currentIndex);
+}
+
+bool TopDUContextKyotoCabinet::open(QIODevice::OpenMode mode)
+{
+  return TopDUContextDB::open(mode, QStringLiteral("KyotoCabinet"));
+}
+
+void TopDUContextKyotoCabinet::commit()
+{
+  if (isValid() && m_mode != MDB_RDONLY) {
+    if (m_currentValue.size() != m_currentLen) {
+      // m_currentLen is the true size
+      qCDebug(LANGUAGE) << "TopDUContextKyotoCabinet index" << QByteArray::number(m_currentIndex) << "internal size mismatch:"
+        << m_currentValue.size() << "vs" << m_currentLen;
+    }
+    try {
+      if (!kyotoCabinet.instance()->set(m_currentKey.constData(), m_currentKey.size(),
+          m_currentValue.constData(), m_currentLen)) {
+        m_errorString = QStringLiteral("Error committing index ")
+          + QByteArray::number(m_currentIndex) + " size " + QString::number(m_currentLen)
+          + QStringLiteral(": ") + kyotoCabinet.errorString();
+        qCWarning(LANGUAGE) << m_errorString;
+      }
+    }
+    catch (const std::exception& e) {
+      m_errorString = kyotocabinet_exception_handler(e, QStringLiteral("committing value for ") + QByteArray::number(m_currentIndex));
+      qCWarning(LANGUAGE) << m_errorString;
+    }
+    m_currentKey.clear();
+    m_currentValue.clear();
+    m_currentLen = 0;
+  }
+}
+
+bool TopDUContextKyotoCabinet::getCurrentKeyValue()
+{
+  // we only return false if a read error occurred; if a key doesn't exist
+  // m_currentValue will remain empty.
+  bool ret = true;
+  if (m_currentValue.isEmpty()) {
+    // read the key value from storage into cache
+    size_t size;
+    try {
+      const char* value = kyotoCabinet.instance()->get(m_currentKey.constData(), m_currentKey.size(), &size);
+      if (value) {
+        m_currentValue = QByteArray(value, size);
+        m_currentLen = m_currentValue.size();
+        m_readCursor = 0;
+        delete[] value;
+      } else {
+        qCWarning(LANGUAGE) << "read NULL for index" << m_currentIndex << "; exists=" << currentKeyExists();
+      }
+    }
+    catch (const std::exception& e) {
+      m_errorString = kyotocabinet_exception_handler(e, QStringLiteral("reading value for ") + QByteArray::number(m_currentIndex));
+      qCWarning(LANGUAGE) << m_errorString;
+      ret = false;
+    }
+  }
+  return ret;
+}
+
+bool TopDUContextKyotoCabinet::isValid()
+{
+  return kyotoCabinet.instance();
+}
+
+bool TopDUContextKyotoCabinet::currentKeyExists()
+{
+  return exists(m_currentKey);
+}
+
+bool TopDUContextKyotoCabinet::exists(const QByteArray& key)
+{
+  if (kyotoCabinet.instance()) {
+    try {
+      bool found = kyotoCabinet.instance()->check(key.constData(), key.size()) >= 0;
+      if (!found && kyotoCabinet.instance()->error().code() != BasicDB::Error::NOREC) {
+        qCWarning(LANGUAGE) << QStringLiteral("Error checking for index") + key
+          + QStringLiteral(": ") + kyotoCabinet.errorString();
+      }
+      return found;
+    }
+    catch (const std::exception& e) {
+      qCWarning(LANGUAGE) << kyotocabinet_exception_handler(e, QStringLiteral("checking presence of ") + key);
+    }
+  }
+  return false;
+}
+
+bool TopDUContextKyotoCabinet::exists(uint topContextIndex)
+{
+  return exists(indexKey(&topContextIndex));
+}
+
+bool TopDUContextKyotoCabinet::remove(uint topContextIndex)
+{
+  if (kyotoCabinet.instance()) {
+    const auto key = indexKey(&topContextIndex);
+    try {
+      bool ret = kyotoCabinet.instance()->remove(key.constData(), key.size());
+      if (!ret) {
+        qCWarning(LANGUAGE) << QStringLiteral("Error removing index %1").arg(topContextIndex)
+          + QStringLiteral(": ") + kyotoCabinet.errorString();
+      }
+      // also remove the file if it (still) exists
+      QFile::remove(TopDUContextDynamicData::pathForTopContext(topContextIndex));
+      return ret;
+    }
+    catch (const std::exception& e) {
+      qCWarning(LANGUAGE) << kyotocabinet_exception_handler(e, QStringLiteral("removing ") + QByteArray::number(topContextIndex));
+    }
+  }
+  return false;
+}
+#endif // KDEV_TOPCONTEXTS_USE_KYOTO
+
+#endif // KDEV_TOPCONTEXTS_USE_FILES
+
+// TopDUContextFile : thin wrapper around the QFile API needed for TopDUContexts
+// so TopDUContextLMDB can be used as a drop-in replacement instead of this class.
+TopDUContextFile::TopDUContextFile(uint topContextIndex)
+  : QFile(TopDUContextDynamicData::pathForTopContext(topContextIndex))
+{
+}
+
+bool TopDUContextFile::exists(uint topContextIndex)
+{
+  return QFile::exists(TopDUContextDynamicData::pathForTopContext(topContextIndex));
+}
+
+bool TopDUContextFile::remove(uint topContextIndex)
+{
+  return QFile::remove(TopDUContextDynamicData::pathForTopContext(topContextIndex));
+}
+
+void TopDUContextFile::commit()
+{
+  QFile::close();
+}
+
+// kate: indent-width 2; tab-width 2;
diff --git a/kdevplatform/language/duchain/topducontextdynamicdata_p.h b/kdevplatform/language/duchain/topducontextdynamicdata_p.h
new file mode 100644
index 0000000000000000000000000000000000000000..5fadd5865129341ef390a9e85d3cfcb40fe32916
--- /dev/null
+++ b/kdevplatform/language/duchain/topducontextdynamicdata_p.h
@@ -0,0 +1,154 @@
+/* This is part of KDevelop
+   Copyright 2018 R.J.V. Bertin <rjvbertin@gmail.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License version 2 as published by the Free Software Foundation.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KDEVPLATFORM_TOPDUCONTEXTDYNAMICDATA_P_H
+#define KDEVPLATFORM_TOPDUCONTEXTDYNAMICDATA_P_H
+
+#include <QByteArray>
+#include <QFile>
+
+#include <languageexport.h>
+
+namespace KDevelop {
+
+// #define KDEV_TOPCONTEXTS_DB_TESTING
+// #define KDEV_TOPCONTEXTS_USE_FILES
+// #define KDEV_TOPCONTEXTS_USE_LMDB
+// #define KDEV_TOPCONTEXTS_USE_LEVELDB
+#define KDEV_TOPCONTEXTS_USE_KYOTO
+
+// thin wrapper around QFile, implementing the default TopDUContext
+// storage mechanism but also used for migration purposes in the
+// database stores.
+class KDEVPLATFORMLANGUAGE_EXPORT TopDUContextFile : public QFile
+{
+public:
+    TopDUContextFile(uint topContextIndex);
+    void commit();
+    static bool exists(uint topContextIndex);
+    static bool remove(uint topContextIndex);
+};
+
+#if defined(KDEV_TOPCONTEXTS_USE_LMDB) || defined(KDEV_TOPCONTEXTS_USE_LEVELDB) || defined(KDEV_TOPCONTEXTS_USE_KYOTO)
+class KDEVPLATFORMLANGUAGE_EXPORT TopDUContextDB
+{
+public:
+  virtual ~TopDUContextDB() {};
+  virtual bool open(QIODevice::OpenMode mode) = 0;
+  virtual void commit() = 0;
+  bool resize(qint64);
+  qint64 write(const char* data, qint64 len);
+  qint64 read(char* data, qint64 maxSize);
+  QByteArray read(qint64 maxSize);
+  QByteArray readAll();
+  qint64 pos() const;
+  bool seek(qint64 pos);
+  qint64 size();
+  QString errorString() const;
+  QString fileName() const;
+  static bool exists(uint) { return false; };
+  static bool remove(uint) { return false; };
+
+protected:
+  bool open(QIODevice::OpenMode mode, const QString &backendName);
+  virtual bool getCurrentKeyValue() = 0;
+  virtual bool isValid() = 0;
+  virtual bool currentKeyExists() = 0;
+  static bool exists(const QByteArray&) { return false; };
+  static QByteArray indexKey(uint idx);
+  static QByteArray indexKey(uint* idx);
+  bool migrateFromFile();
+  QByteArray m_currentKey;
+  uint m_currentIndex;
+  QByteArray m_currentValue;
+  qint64 m_currentLen, m_readCursor;
+  int m_mode;
+  QString m_errorString;
+#ifdef KDEV_TOPCONTEXTS_DB_TESTING
+public:
+  void* lvldbStore = nullptr;
+  void* kyodbStore = nullptr;
+#endif
+};
+#endif
+
+#ifdef KDEV_TOPCONTEXTS_USE_LMDB
+class KDEVPLATFORMLANGUAGE_EXPORT TopDUContextLMDB : public TopDUContextDB
+{
+public:
+  TopDUContextLMDB(uint topContextIndex);
+  virtual ~TopDUContextLMDB();
+  bool open(QIODevice::OpenMode mode) override;
+  void commit() override;
+  QString fileName() const;
+  static bool exists(uint topContextIndex);
+  static bool remove(uint topContextIndex);
+
+protected:
+  virtual bool getCurrentKeyValue() override;
+  virtual bool isValid() override;
+  virtual bool currentKeyExists() override;
+  static bool exists(const QByteArray& key);
+  static bool s_envExists;
+  static size_t s_mapSize;
+};
+#endif
+
+#ifdef KDEV_TOPCONTEXTS_USE_LEVELDB
+class KDEVPLATFORMLANGUAGE_EXPORT TopDUContextLevelDB : public TopDUContextDB
+{
+public:
+  TopDUContextLevelDB(uint topContextIndex);
+  virtual ~TopDUContextLevelDB();
+  bool open(QIODevice::OpenMode mode) override;
+  void commit() override;
+  static bool exists(uint topContextIndex);
+  static bool remove(uint topContextIndex);
+
+protected:
+  virtual bool getCurrentKeyValue() override;
+  virtual bool isValid() override;
+  virtual bool currentKeyExists() override;
+  static bool exists(const QByteArray& key);
+  static uint s_DbRefCount;
+};
+#endif
+
+#ifdef KDEV_TOPCONTEXTS_USE_KYOTO
+class KDEVPLATFORMLANGUAGE_EXPORT TopDUContextKyotoCabinet : public TopDUContextDB
+{
+public:
+  TopDUContextKyotoCabinet(uint topContextIndex);
+  virtual ~TopDUContextKyotoCabinet();
+  bool open(QIODevice::OpenMode mode) override;
+  void commit() override;
+  QString fileName() const;
+  static bool exists(uint topContextIndex);
+  static bool remove(uint topContextIndex);
+
+protected:
+  virtual bool getCurrentKeyValue() override;
+  virtual bool isValid() override;
+  virtual bool currentKeyExists() override;
+  static bool exists(const QByteArray& key);
+  static uint s_DbRefCount;
+};
+#endif
+
+}
+#endif
