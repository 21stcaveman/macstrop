diff --git a/processcore/processes_darwin_p.cpp b/processcore/processes_darwin_p.cpp
new file mode 100644
index 0000000..752f5ae
--- /dev/null
+++ b/processcore/processes_darwin_p.cpp
@@ -0,0 +1,271 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2007 Manolo Valdes <nolis71cu@gmail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "processes_local_p.h"
+#include "process.h"
+#include "processcore_debug.h"
+
+#include <KLocalizedString>
+
+#include <QSet>
+
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <sys/types.h>
+#include <sys/user.h>
+#include <sys/resource.h>
+#include <sys/vm.h>
+#include <signal.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <sched.h>
+
+#include <QDebug>
+
+
+namespace KSysGuard
+{
+
+class ProcessesLocal::Private
+{
+public:
+    Private() {;}
+    ~Private() {;}
+    inline int argMax();
+    inline bool readProc(long pid, struct kinfo_proc *p);
+    inline void readProcStatus(struct kinfo_proc *p, Process *process);
+    inline void readProcStat(struct kinfo_proc *p, Process *process);
+    inline void readProcStatm(struct kinfo_proc *p, Process *process);
+    inline bool readProcCmdline(long pid, Process *process);
+};
+
+int ProcessesLocal::Private::argMax()
+{
+    int mib[2] = {CTL_KERN, KERN_ARGMAX};
+    int argmax = 0;
+    size_t bufsz = sizeof(argmax);
+    if (sysctl(mib, 2, &argmax, &bufsz, 0, 0)) {
+        qCritical() << "Cannot determine kern.argmax";
+    }
+    return argmax;
+}
+
+bool ProcessesLocal::Private::readProc(long pid, struct kinfo_proc *p)
+{
+    int mib[4];
+    size_t len;
+
+    mib[0] = CTL_KERN;
+    mib[1] = KERN_PROC;
+    mib[2] = KERN_PROC_PID;
+    mib[3] = pid;
+
+    len = sizeof (struct kinfo_proc);
+    return !(sysctl(mib, 4, p, &len, NULL, 0) == -1 || !len);
+}
+
+void ProcessesLocal::Private::readProcStatus(struct kinfo_proc *p, Process *process)
+{
+    process->setUid(0);
+    process->setGid(0);
+    process->setTracerpid(-1);
+
+    process->setEuid(p->kp_eproc.e_ucred.cr_uid);
+    process->setUid(p->kp_eproc.e_pcred.p_ruid);
+    // no idea if this is appropriate:
+    process->setEgid(p->kp_eproc.e_pcred.p_svgid);
+    process->setGid(p->kp_eproc.e_pgid);
+    process->setName(QString(p->kp_proc.p_comm[0] ? p->kp_proc.p_comm : "????"));
+}
+
+void ProcessesLocal::Private::readProcStat(struct kinfo_proc *p, Process *ps)
+{
+    int status;
+    struct rusage *pru = p->kp_proc.p_ru;
+
+    if (pru) {
+        ps->setUserTime(pru->ru_utime.tv_sec * 100 + pru->ru_utime.tv_usec / 10000);
+        ps->setSysTime(pru->ru_stime.tv_sec * 100 + pru->ru_stime.tv_usec / 10000);
+    }
+    ps->setNiceLevel(p->kp_proc.p_nice);
+    ps->setVmSize(p->kp_eproc.e_xsize / 1024);
+    ps->setVmRSS(p->kp_eproc.e_xrssize * getpagesize() / 1024);
+    status = p->kp_proc.p_stat;
+
+// "idle","run","sleep","stop","zombie"
+    switch( status ) {
+      case SRUN:
+         ps->setStatus(Process::Running);
+	 break;
+      case SSLEEP:
+         ps->setStatus(Process::Sleeping);
+	 break;
+      case SSTOP:
+         ps->setStatus(Process::Stopped);
+         break;
+      case SZOMB:
+         ps->setStatus(Process::Zombie);
+         break;
+      default:
+         ps->setStatus(Process::OtherStatus);
+         break;
+    }
+}
+
+void ProcessesLocal::Private::readProcStatm(struct kinfo_proc *p, Process *process)
+{
+    process->setVmURSS(-1);
+}
+
+bool ProcessesLocal::Private::readProcCmdline(long pid, Process *process)
+{
+    int mib[3];
+    size_t buflen = argMax();
+    QScopedPointer<char, QScopedPointerArrayDeleter<char> > buf(new char[buflen]);
+
+    mib[0] = CTL_KERN;
+    mib[1] = KERN_PROCARGS2;
+    mib[2] = pid;
+
+    if (sysctl(mib, 3, buf.data(), &buflen, NULL, 0) == -1 || !buflen) {
+        return false;
+    }
+    QString command = QString(buf.data());
+
+    //cmdline seperates parameters with the NULL character
+    command = command.replace('\0', ' ');
+    process->setCommand(command.trimmed());
+
+    return true;
+}
+
+ProcessesLocal::ProcessesLocal()
+    : d(new Private())
+{
+}
+
+long ProcessesLocal::getParentPid(long pid) {
+    long long ppid = 0;
+    struct kinfo_proc p;
+    if (d->readProc(pid, &p)) {
+        ppid = p.kp_eproc.e_ppid;
+    }
+    return ppid;
+}
+
+bool ProcessesLocal::updateProcessInfo( long pid, Process *process)
+{
+    struct kinfo_proc p;
+    if (!d->readProc(pid, &p)) {
+        return false;
+    }
+    d->readProcStat(&p, process);
+    d->readProcStatus(&p, process);
+    d->readProcStatm(&p, process);
+    if (!d->readProcCmdline(pid, process)) {
+        return false;
+    }
+
+    return true;
+}
+
+QSet<long> ProcessesLocal::getAllPids( )
+{
+    QSet<long> pids;
+    int mib[4];
+    size_t len;
+    size_t num;
+    struct kinfo_proc *p;
+
+    mib[0] = CTL_KERN;
+    mib[1] = KERN_PROC;
+    mib[2] = KERN_PROC_ALL;
+    mib[3] = 0;
+    if (sysctl(mib, 4, NULL, &len, NULL, 0) == -1) {
+        return pids;
+    }
+    QScopedPointer<kinfo_proc, QScopedPointerArrayDeleter<kinfo_proc> > pInfos(new kinfo_proc[len]);
+    if ((p = pInfos.data()) == NULL) {
+        qCritical() << "Failure allocating kinfo_proc table of length" << len;
+        return pids;
+    }
+    if (sysctl(mib, 4, p, &len, NULL, 0) == -1) {
+        return pids;
+    }
+
+    for (num = 0; num < len / sizeof(struct kinfo_proc); num++) {
+        long pid = p[num].kp_proc.p_pid;
+        long long ppid = p[num].kp_eproc.e_ppid;
+
+        //skip all process with parent id = 0 but init
+        if(ppid <= 0 && pid != 1) {
+            continue;
+        }
+        pids.insert(pid);
+    }
+    return pids;
+}
+
+bool ProcessesLocal::sendSignal(long pid, int sig) {
+    if (kill((pid_t)pid, sig)) {
+        //Kill failed
+        return false;
+    }
+    return true;
+}
+
+bool ProcessesLocal::setNiceness(long pid, int priority) {
+    if (setpriority(PRIO_PROCESS, pid, priority)) {
+        //set niceness failed
+        return false;
+    }
+    return true;
+}
+
+bool ProcessesLocal::setScheduler(long, int, int)
+{
+    return false;
+}
+
+bool ProcessesLocal::setIoNiceness(long, int, int) {
+    return false; //Not yet supported
+}
+
+bool ProcessesLocal::supportsIoNiceness() {
+    return false;
+}
+
+long long ProcessesLocal::totalPhysicalMemory() {
+
+    size_t Total;
+    size_t len;
+
+    len = sizeof (Total);
+    if (sysctlbyname("hw.physmem", &Total, &len, NULL, 0) == -1)
+        return 0;
+
+    return Total /= 1024;
+}
+
+ProcessesLocal::~ProcessesLocal()
+{
+   delete d;
+}
+
+}
diff --git a/processcore/processes_local_p.cpp b/processcore/processes_local_p.cpp
index 2bc123f..5ff858e 100644
--- a/processcore/processes_local_p.cpp
+++ b/processcore/processes_local_p.cpp
@@ -23,13 +23,15 @@
 #include "processes_linux_p.cpp"
 #elif defined __FreeBSD__ || defined __FreeBSD_kernel__
 #include "processes_freebsd_p.cpp"
+#elif defined __APPLE__
+#include "processes_darwin_p.cpp"
 #elif defined __DragonFly__
 #include "processes_dragonfly_p.cpp"
 #elif defined __OpenBSD__
 #include "processes_openbsd_p.cpp"
 #elif defined __NetBSD__
 #include "processes_netbsd_p.cpp"
-#elif defined __GNU__ || defined __APPLE__
+#elif defined __GNU__ 
 #include "processes_gnu_p.cpp"
 #else
 // Use Qt's OS detection
