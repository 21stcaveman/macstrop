diff --git configure.ac configure.ac
index a38b24147..e507d3169 100644
--- configure.ac
+++ configure.ac
@@ -2349,10 +2349,13 @@ AC_MSG_RESULT([${avfork}])
 AC_ARG_ENABLE(avcodec,
 [  --enable-avcodec        libavcodec codec (default enabled)])
 AS_IF([test "${enable_avcodec}" != "no"], [
-  PKG_CHECK_MODULES(AVCODEC,[libavcodec >= 53.34.0 libavutil >= 51.22.0], [
-    PKG_CHECK_EXISTS([libavutil < 55],, [
-      AC_MSG_ERROR([libavutil versions 55 and later are not supported.])
-    ])
+  dnl We need >=57.16.0 from libav or >=57.37.100 from ffmpeg
+  case "${avfork}" in
+    libav) av_codec_ver="57.16.0" ;;
+    ffmpeg) av_codec_ver="57.37.100" ;;
+    *) AC_MSG_ERROR([Missing libav or FFmpeg. Pass --disable-avcodec to ignore this error.])
+  esac
+  PKG_CHECK_MODULES(AVCODEC,[libavcodec >= ${av_codec_ver} libavutil >= 52.0.0], [
     VLC_SAVE_FLAGS
     CPPFLAGS="${CPPFLAGS} ${AVCODEC_CFLAGS}"
     CFLAGS="${CFLAGS} ${AVCODEC_CFLAGS}"
@@ -3122,21 +3125,17 @@ AM_CONDITIONAL([HAVE_VDPAU], [test "${have_vdpau}" = "yes"])
 have_avcodec_vdpau="no"
 AS_IF([test "${have_vdpau}" = "yes" -a "${have_avcodec}" = "yes"], [
   case "${avfork}" in
-    libav) av_vdpau_ver="55.26.0" ;;
-    ffmpeg) av_vdpau_ver="55.42.100"
-      PKG_CHECK_EXISTS([libavcodec >= 57.10.100], [
-        AC_MSG_ERROR([VDPAU requires FFmpeg libavcodec < 57.10 or libav.])
-      ])
-      ;;
+    libav) av_vdpau_ver="56.10.0" ;;
+    ffmpeg) av_vdpau_ver="56.19.100" ;;
   esac
-  PKG_CHECK_EXISTS([libavutil >= 52.4.0 libavcodec >= ${av_vdpau_ver}], [
+  PKG_CHECK_EXISTS([libavcodec >= ${av_vdpau_ver}], [
     have_avcodec_vdpau="yes"
     AC_MSG_NOTICE([VDPAU decoding acceleration activated])
   ], [
     AS_IF([test -n "${enable_vdpau}"], [
-      AC_MSG_ERROR([libavutil >= 52.4.0 and libavcodec >= 55.26.0 are required for VDPAU decoding.])
+      AC_MSG_ERROR([libavcodec >= 56.10.0 is required for VDPAU decoding.])
     ], [
-      AC_MSG_WARN([libavutil >= 52.4.0 and libavcodec >= 55.26.0 are required for VDPAU decoding.])
+      AC_MSG_WARN([libavcodec >= 56.10.0 are required for VDPAU decoding.])
     ])
   ])
 ])
diff --git modules/codec/avcodec/audio.c modules/codec/avcodec/audio.c
index 7068499d8..84514cb59 100644
--- modules/codec/avcodec/audio.c
+++ modules/codec/avcodec/audio.c
@@ -36,19 +36,21 @@
 #include <vlc_codec.h>
 #include <vlc_avcodec.h>
 
+#include "avcodec.h"
+
 #include <libavcodec/avcodec.h>
 #include <libavutil/mem.h>
 
-#include <libavutil/audioconvert.h>
+#include <libavutil/channel_layout.h>
 
-#include "avcodec.h"
 
 /*****************************************************************************
  * decoder_sys_t : decoder descriptor
  *****************************************************************************/
-struct decoder_sys_t
+typedef struct
 {
-    AVCODEC_COMMON_MEMBERS
+    AVCodecContext *p_context;
+    const AVCodec  *p_codec;
 
     /*
      * Output properties
@@ -64,11 +66,14 @@ struct decoder_sys_t
     int     pi_extraction[AOUT_CHAN_MAX];
     int     i_previous_channels;
     uint64_t i_previous_layout;
-};
+} decoder_sys_t;
 
 #define BLOCK_FLAG_PRIVATE_REALLOCATED (1 << BLOCK_FLAG_PRIVATE_SHIFT)
 
 static void SetupOutputFormat( decoder_t *p_dec, bool b_trust );
+static block_t * ConvertAVFrame( decoder_t *p_dec, AVFrame *frame );
+static int  DecodeAudio( decoder_t *, block_t * );
+static void Flush( decoder_t * );
 
 static void InitDecoderConfig( decoder_t *p_dec, AVCodecContext *p_context )
 {
@@ -115,10 +120,41 @@ static void InitDecoderConfig( decoder_t *p_dec, AVCodecContext *p_context )
     }
 }
 
+static int OpenAudioCodec( decoder_t *p_dec )
+{
+    decoder_sys_t *p_sys = p_dec->p_sys;
+    AVCodecContext *ctx = p_sys->p_context;
+    const AVCodec *codec = p_sys->p_codec;
+
+    if( ctx->extradata_size <= 0 )
+    {
+        if( codec->id == AV_CODEC_ID_VORBIS ||
+            ( codec->id == AV_CODEC_ID_AAC &&
+              !p_dec->fmt_in.b_packetized ) )
+        {
+            msg_Warn( p_dec, "waiting for extra data for codec %s",
+                      codec->name );
+            return 1;
+        }
+    }
+
+    ctx->sample_rate = p_dec->fmt_in.audio.i_rate;
+    ctx->channels = p_dec->fmt_in.audio.i_channels;
+    ctx->block_align = p_dec->fmt_in.audio.i_blockalign;
+    ctx->bit_rate = p_dec->fmt_in.i_bitrate;
+    ctx->bits_per_coded_sample = p_dec->fmt_in.audio.i_bitspersample;
+
+    if( codec->id == AV_CODEC_ID_ADPCM_G726 &&
+        ctx->bit_rate > 0 &&
+        ctx->sample_rate >  0)
+        ctx->bits_per_coded_sample = ctx->bit_rate / ctx->sample_rate;
+
+    return ffmpeg_OpenCodec( p_dec, ctx, codec );
+}
+
 /**
  * Allocates decoded audio buffer for libavcodec to use.
  */
-#if (LIBAVCODEC_VERSION_MAJOR >= 55)
 typedef struct
 {
     block_t self;
@@ -153,89 +189,56 @@ static block_t *vlc_av_frame_Wrap(AVFrame *frame)
     b->frame = frame;
     return block;
 }
-#else
-static int GetAudioBuf( AVCodecContext *ctx, AVFrame *buf )
-{
-    block_t *block;
-    bool planar = av_sample_fmt_is_planar( ctx->sample_fmt );
-    unsigned channels = planar ? 1 : ctx->channels;
-    unsigned planes = planar ? ctx->channels : 1;
-
-    int bytes = av_samples_get_buffer_size( &buf->linesize[0], channels,
-                                            buf->nb_samples, ctx->sample_fmt,
-                                            16 );
-    assert( bytes >= 0 );
-    block = block_Alloc( bytes * planes );
-    if( unlikely(block == NULL) )
-        return AVERROR(ENOMEM);
-
-    block->i_nb_samples = buf->nb_samples;
-    buf->opaque = block;
-
-    if( planes > AV_NUM_DATA_POINTERS )
-    {
-        uint8_t **ext = malloc( sizeof( *ext ) * planes );
-        if( unlikely(ext == NULL) )
-        {
-            block_Release( block );
-            return AVERROR(ENOMEM);
-        }
-        buf->extended_data = ext;
-    }
-    else
-        buf->extended_data = buf->data;
 
-    uint8_t *buffer = block->p_buffer;
-    for( unsigned i = 0; i < planes; i++ )
-    {
-        buf->linesize[i] = buf->linesize[0];
-        buf->extended_data[i] = buffer;
-        buffer += bytes;
-    }
+/*****************************************************************************
+ * EndAudio: decoder destruction
+ *****************************************************************************
+ * This function is called when the thread ends after a successful
+ * initialization.
+ *****************************************************************************/
+void EndAudioDec( vlc_object_t *obj )
+{
+    decoder_t *p_dec = (decoder_t *)obj;
+    decoder_sys_t *sys = p_dec->p_sys;
+    AVCodecContext *ctx = sys->p_context;
 
-    return 0;
+    avcodec_free_context( &ctx );
+    free( sys );
 }
-#endif
 
 /*****************************************************************************
  * InitAudioDec: initialize audio decoder
  *****************************************************************************
  * The avcodec codec will be opened, some memory allocated.
  *****************************************************************************/
-int InitAudioDec( decoder_t *p_dec, AVCodecContext *p_context,
-                      AVCodec *p_codec, int i_codec_id, const char *psz_namecodec )
+int InitAudioDec( vlc_object_t *obj )
 {
-    decoder_sys_t *p_sys;
+    decoder_t *p_dec = (decoder_t *)obj;
+    const AVCodec *codec;
+    AVCodecContext *avctx = ffmpeg_AllocContext( p_dec, &codec );
+    if( avctx == NULL )
+        return VLC_EGENERIC;
 
     /* Allocate the memory needed to store the decoder's structure */
-    if( ( p_dec->p_sys = p_sys = malloc(sizeof(*p_sys)) ) == NULL )
+    decoder_sys_t *p_sys = malloc(sizeof(*p_sys));
+    if( unlikely(p_sys == NULL) )
     {
+        avcodec_free_context( &avctx );
         return VLC_ENOMEM;
     }
 
-    p_codec->type = AVMEDIA_TYPE_AUDIO;
-    p_context->codec_type = AVMEDIA_TYPE_AUDIO;
-    p_context->codec_id = i_codec_id;
-#if (LIBAVCODEC_VERSION_MAJOR >= 55)
-    p_context->refcounted_frames = true;
-#else
-    p_context->get_buffer = GetAudioBuf;
-#endif
-    p_sys->p_context = p_context;
-    p_sys->p_codec = p_codec;
-    p_sys->i_codec_id = i_codec_id;
-    p_sys->psz_namecodec = psz_namecodec;
-    p_sys->b_delayed_open = true;
+    p_dec->p_sys = p_sys;
+    p_sys->p_context = avctx;
+    p_sys->p_codec = codec;
 
     // Initialize decoder extradata
-    InitDecoderConfig( p_dec, p_context);
+    InitDecoderConfig( p_dec, avctx );
 
     /* ***** Open the codec ***** */
-    if( ffmpeg_OpenCodec( p_dec ) < 0 )
+    if( OpenAudioCodec( p_dec ) < 0 )
     {
-        msg_Err( p_dec, "cannot open codec (%s)", p_sys->psz_namecodec );
-        av_free( p_sys->p_context->extradata );
         free( p_sys );
+        avcodec_free_context( &avctx );
         return VLC_EGENERIC;
     }
 
@@ -245,218 +248,278 @@ int InitAudioDec( decoder_t *p_dec, AVCodecContext *p_context,
     p_sys->i_previous_layout = 0;
 
     /* */
-    p_dec->fmt_out.i_cat = AUDIO_ES;
     /* Try to set as much information as possible but do not trust it */
     SetupOutputFormat( p_dec, false );
 
-    date_Set( &p_sys->end_date, 0 );
+    date_Set( &p_sys->end_date, VLC_TS_INVALID );
+    if( !p_dec->fmt_out.audio.i_rate )
+        p_dec->fmt_out.audio.i_rate = p_dec->fmt_in.audio.i_rate;
     if( p_dec->fmt_out.audio.i_rate )
         date_Init( &p_sys->end_date, p_dec->fmt_out.audio.i_rate, 1 );
-    else if( p_dec->fmt_in.audio.i_rate )
-        date_Init( &p_sys->end_date, p_dec->fmt_in.audio.i_rate, 1 );
+    p_dec->fmt_out.audio.i_chan_mode = p_dec->fmt_in.audio.i_chan_mode;
+
+    p_dec->pf_decode = DecodeAudio;
+    p_dec->pf_flush  = Flush;
+
+    /* XXX: Writing input format makes little sense. */
+    if( avctx->profile != FF_PROFILE_UNKNOWN )
+        p_dec->fmt_in.i_profile = avctx->profile;
+    if( avctx->level != FF_LEVEL_UNKNOWN )
+        p_dec->fmt_in.i_level = avctx->level;
 
     return VLC_SUCCESS;
 }
 
 /*****************************************************************************
- * DecodeAudio: Called to decode one frame
+ * Flush:
  *****************************************************************************/
-block_t * DecodeAudio ( decoder_t *p_dec, block_t **pp_block )
+static void Flush( decoder_t *p_dec )
 {
     decoder_sys_t *p_sys = p_dec->p_sys;
     AVCodecContext *ctx = p_sys->p_context;
-    AVFrame *frame = NULL;
 
-    if( !pp_block || !*pp_block )
-        return NULL;
+    if( avcodec_is_open( ctx ) )
+        avcodec_flush_buffers( ctx );
+    date_Set( &p_sys->end_date, VLC_TS_INVALID );
+
+    if( ctx->codec_id == AV_CODEC_ID_MP2 ||
+        ctx->codec_id == AV_CODEC_ID_MP3 )
+        p_sys->i_reject_count = 3;
+}
 
-    block_t *p_block = *pp_block;
+/*****************************************************************************
+ * DecodeBlock: Called to decode one frame
+ *****************************************************************************/
+static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
+{
+    decoder_sys_t *p_sys = p_dec->p_sys;
+    AVCodecContext *ctx = p_sys->p_context;
+    AVFrame *frame = NULL;
+    block_t *p_block = NULL;
+    bool b_error = false;
 
-    if( !ctx->extradata_size && p_dec->fmt_in.i_extra && p_sys->b_delayed_open)
+    if( !ctx->extradata_size && p_dec->fmt_in.i_extra
+     && !avcodec_is_open( ctx ) )
     {
         InitDecoderConfig( p_dec, ctx );
-        if( ffmpeg_OpenCodec( p_dec ) )
-            msg_Err( p_dec, "Cannot open decoder %s", p_sys->psz_namecodec );
+        OpenAudioCodec( p_dec );
     }
 
-    if( p_sys->b_delayed_open )
-        goto end;
+    if( !avcodec_is_open( ctx ) )
+    {
+        if( pp_block )
+            p_block = *pp_block;
+        goto drop;
+    }
 
-    if( p_block->i_flags & (BLOCK_FLAG_DISCONTINUITY|BLOCK_FLAG_CORRUPTED) )
+    if( pp_block == NULL ) /* Drain request */
     {
-        avcodec_flush_buffers( ctx );
-        date_Set( &p_sys->end_date, 0 );
+        /* we don't need to care about return val */
+        (void) avcodec_send_packet( ctx, NULL );
+    }
+    else
+    {
+        p_block = *pp_block;
+    }
 
-        if( p_sys->i_codec_id == AV_CODEC_ID_MP2 || p_sys->i_codec_id == AV_CODEC_ID_MP3 )
-            p_sys->i_reject_count = 3;
+    if( p_block )
+    {
+        if( p_block->i_flags & BLOCK_FLAG_CORRUPTED )
+        {
+            Flush( p_dec );
+            goto drop;
+        }
 
-        goto end;
-    }
+        if( p_block->i_flags & BLOCK_FLAG_DISCONTINUITY )
+        {
+            date_Set( &p_sys->end_date, VLC_TS_INVALID );
+        }
 
-    /* We've just started the stream, wait for the first PTS. */
-    if( !date_Get( &p_sys->end_date ) && p_block->i_pts <= VLC_TS_INVALID )
-        goto end;
+        /* We've just started the stream, wait for the first PTS. */
+        if( p_block->i_pts == VLC_TS_INVALID &&
+            date_Get( &p_sys->end_date ) == VLC_TS_INVALID )
+            goto drop;
 
-    if( p_block->i_buffer <= 0 )
-        goto end;
+        if( p_block->i_buffer <= 0 )
+            goto drop;
 
-    if( (p_block->i_flags & BLOCK_FLAG_PRIVATE_REALLOCATED) == 0 )
-    {
-        p_block = block_Realloc( p_block, 0, p_block->i_buffer + FF_INPUT_BUFFER_PADDING_SIZE );
-        if( !p_block )
-            return NULL;
-        *pp_block = p_block;
-        p_block->i_buffer -= FF_INPUT_BUFFER_PADDING_SIZE;
-        memset( &p_block->p_buffer[p_block->i_buffer], 0, FF_INPUT_BUFFER_PADDING_SIZE );
-
-        p_block->i_flags |= BLOCK_FLAG_PRIVATE_REALLOCATED;
+        if( (p_block->i_flags & BLOCK_FLAG_PRIVATE_REALLOCATED) == 0 )
+        {
+            *pp_block = p_block = block_Realloc( p_block, 0, p_block->i_buffer + FF_INPUT_BUFFER_PADDING_SIZE );
+            if( !p_block )
+                goto end;
+            p_block->i_buffer -= FF_INPUT_BUFFER_PADDING_SIZE;
+            memset( &p_block->p_buffer[p_block->i_buffer], 0, FF_INPUT_BUFFER_PADDING_SIZE );
+
+            p_block->i_flags |= BLOCK_FLAG_PRIVATE_REALLOCATED;
+        }
     }
 
-#if (LIBAVCODEC_VERSION_MAJOR >= 55)
     frame = av_frame_alloc();
     if (unlikely(frame == NULL))
         goto end;
-#else
-    frame = &(AVFrame) { };
-#endif
 
-    for( int got_frame = 0; !got_frame; )
+    for( int ret = 0; ret == 0; )
     {
-        if( p_block->i_buffer == 0 )
-            goto end;
+        /* Feed in the loop as buffer could have been full on first iterations */
+        if( p_block )
+        {
+            AVPacket pkt;
+            av_init_packet( &pkt );
+            pkt.data = p_block->p_buffer;
+            pkt.size = p_block->i_buffer;
+            ret = avcodec_send_packet( ctx, &pkt );
+            if( ret == 0 ) /* Block has been consumed */
+            {
+                /* Only set new pts from input block if it has been used,
+                 * otherwise let it be through interpolation */
+                if( p_block->i_pts > date_Get( &p_sys->end_date ) )
+                {
+                    date_Set( &p_sys->end_date, p_block->i_pts );
+                }
+
+                block_Release( p_block );
+                *pp_block = p_block = NULL;
+            }
+            else if ( ret != AVERROR(EAGAIN) ) /* Errors other than buffer full */
+            {
+                if( ret == AVERROR(ENOMEM) || ret == AVERROR(EINVAL) )
+                    goto end;
+                else
+                    goto drop;
+            }
+        }
 
-        AVPacket pkt;
-        av_init_packet( &pkt );
-        pkt.data = p_block->p_buffer;
-        pkt.size = p_block->i_buffer;
+        /* Try to read one or multiple frames */
+        ret = avcodec_receive_frame( ctx, frame );
+        if( ret == 0 )
+        {
+            /* checks and init from first decoded frame */
+            if( ctx->channels <= 0 || ctx->channels > INPUT_CHAN_MAX
+             || ctx->sample_rate <= 0 )
+            {
+                msg_Warn( p_dec, "invalid audio properties channels count %d, sample rate %d",
+                          ctx->channels, ctx->sample_rate );
+                goto drop;
+            }
+            else if( p_dec->fmt_out.audio.i_rate != (unsigned int)ctx->sample_rate )
+            {
+                date_Init( &p_sys->end_date, ctx->sample_rate, 1 );
+            }
 
-        int used = avcodec_decode_audio4( ctx, frame, &got_frame, &pkt );
-        if( used < 0 )
+            SetupOutputFormat( p_dec, true );
+            if( decoder_UpdateAudioFormat( p_dec ) )
+                goto drop;
+
+            block_t *p_converted = ConvertAVFrame( p_dec, frame ); /* Consumes frame */
+            if( p_converted )
+            {
+                /* Silent unwanted samples */
+                if( p_sys->i_reject_count > 0 )
+                {
+                    memset( p_converted->p_buffer, 0, p_converted->i_buffer );
+                    p_sys->i_reject_count--;
+                }
+                p_converted->i_buffer = p_converted->i_nb_samples
+                                      * p_dec->fmt_out.audio.i_bytes_per_frame;
+                p_converted->i_pts = date_Get( &p_sys->end_date );
+                p_converted->i_length = date_Increment( &p_sys->end_date,
+                                                      p_converted->i_nb_samples ) - p_converted->i_pts;
+
+                decoder_QueueAudio( p_dec, p_converted );
+            }
+
+            /* Prepare new frame */
+            frame = av_frame_alloc();
+            if (unlikely(frame == NULL))
+                break;
+        }
+        else
         {
-            msg_Warn( p_dec, "cannot decode one frame (%zu bytes)",
-                      p_block->i_buffer );
-            goto end;
+            /* After draining, we need to reset decoder with a flush */
+            if( ret == AVERROR_EOF )
+                avcodec_flush_buffers( p_sys->p_context );
+            av_frame_free( &frame );
         }
+    };
 
-        assert( p_block->i_buffer >= (unsigned)used );
-        p_block->p_buffer += used;
-        p_block->i_buffer -= used;
-    }
+    return VLCDEC_SUCCESS;
 
-    if( ctx->channels <= 0 || ctx->channels > 8 || ctx->sample_rate <= 0 )
+end:
+    b_error = true;
+drop:
+    if( pp_block )
     {
-        msg_Warn( p_dec, "invalid audio properties channels count %d, sample rate %d",
-                  ctx->channels, ctx->sample_rate );
-        goto end;
+        assert( *pp_block == p_block );
+        *pp_block = NULL;
     }
+    if( p_block != NULL )
+        block_Release(p_block);
+    if( frame != NULL )
+        av_frame_free( &frame );
 
-    if( p_dec->fmt_out.audio.i_rate != (unsigned int)ctx->sample_rate )
-        date_Init( &p_sys->end_date, ctx->sample_rate, 1 );
+    return (b_error) ? VLCDEC_ECRITICAL : VLCDEC_SUCCESS;
+}
 
-    if( p_block->i_pts > VLC_TS_INVALID &&
-        p_block->i_pts > date_Get( &p_sys->end_date ) )
+static int DecodeAudio( decoder_t *p_dec, block_t *p_block )
+{
+    block_t **pp_block = p_block ? &p_block : NULL;
+    int i_ret;
+    do
     {
-        date_Set( &p_sys->end_date, p_block->i_pts );
+        i_ret = DecodeBlock( p_dec, pp_block );
     }
+    while( i_ret == VLCDEC_SUCCESS && pp_block && *pp_block );
 
-    if( p_block->i_buffer == 0 )
-    {   /* Done with this buffer */
-        block_Release( p_block );
-        p_block = NULL;
-        *pp_block = NULL;
-    }
+    return i_ret;
+}
 
-#if (LIBAVCODEC_VERSION_MAJOR < 55)
-    /* NOTE WELL: Beyond this point, p_block refers to the DECODED block! */
-    p_block = frame->opaque;
-#endif
-    SetupOutputFormat( p_dec, true );
-    if( decoder_UpdateAudioFormat( p_dec ) )
-        goto drop;
+static block_t * ConvertAVFrame( decoder_t *p_dec, AVFrame *frame )
+{
+    decoder_sys_t *p_sys = p_dec->p_sys;
+    AVCodecContext *ctx = p_sys->p_context;
+    block_t *p_block;
 
     /* Interleave audio if required */
     if( av_sample_fmt_is_planar( ctx->sample_fmt ) )
-#if (LIBAVCODEC_VERSION_MAJOR >= 55)
     {
         p_block = block_Alloc(frame->linesize[0] * ctx->channels);
-        if (unlikely(p_block == NULL))
-            goto drop;
-
-        const void *planes[ctx->channels];
-        for (int i = 0; i < ctx->channels; i++)
-            planes[i] = frame->extended_data[i];
+        if ( likely(p_block) )
+        {
+            const void *planes[ctx->channels];
+            for (int i = 0; i < ctx->channels; i++)
+                planes[i] = frame->extended_data[i];
 
-        aout_Interleave(p_block->p_buffer, planes, frame->nb_samples,
-                        ctx->channels, p_dec->fmt_out.audio.i_format);
-        p_block->i_nb_samples = frame->nb_samples;
+            aout_Interleave(p_block->p_buffer, planes, frame->nb_samples,
+                            ctx->channels, p_dec->fmt_out.audio.i_format);
+            p_block->i_nb_samples = frame->nb_samples;
+        }
         av_frame_free(&frame);
     }
     else
     {
         p_block = vlc_av_frame_Wrap(frame);
-        if (unlikely(p_block == NULL))
-            goto drop;
         frame = NULL;
     }
-#else
-    {
-        block_t *p_buffer = block_Alloc( p_block->i_buffer );
-        if( unlikely(p_buffer == NULL) )
-            goto drop;
-
-        const void *planes[ctx->channels];
-        for( int i = 0; i < ctx->channels; i++)
-            planes[i] = frame->extended_data[i];
-
-        aout_Interleave( p_buffer->p_buffer, planes, frame->nb_samples,
-                         ctx->channels, p_dec->fmt_out.audio.i_format );
-        if( ctx->channels > AV_NUM_DATA_POINTERS )
-            free( frame->extended_data );
-        block_Release( p_block );
-        p_block = p_buffer;
-    }
-    p_block->i_nb_samples = frame->nb_samples;
-#endif
 
-    if (p_sys->b_extract)
+    if (p_sys->b_extract && p_block)
     {   /* TODO: do not drop channels... at least not here */
         block_t *p_buffer = block_Alloc( p_dec->fmt_out.audio.i_bytes_per_frame
                                          * p_block->i_nb_samples );
-        if( unlikely(p_buffer == NULL) )
-            goto drop;
-        aout_ChannelExtract( p_buffer->p_buffer,
-                             p_dec->fmt_out.audio.i_channels,
-                             p_block->p_buffer, ctx->channels,
-                             p_block->i_nb_samples, p_sys->pi_extraction,
-                             p_dec->fmt_out.audio.i_bitspersample );
-        p_buffer->i_nb_samples = p_block->i_nb_samples;
+        if( likely(p_buffer) )
+        {
+            aout_ChannelExtract( p_buffer->p_buffer,
+                                 p_dec->fmt_out.audio.i_channels,
+                                 p_block->p_buffer, ctx->channels,
+                                 p_block->i_nb_samples, p_sys->pi_extraction,
+                                 p_dec->fmt_out.audio.i_bitspersample );
+            p_buffer->i_nb_samples = p_block->i_nb_samples;
+        }
         block_Release( p_block );
         p_block = p_buffer;
     }
 
-    /* Silent unwanted samples */
-    if( p_sys->i_reject_count > 0 )
-    {
-        memset( p_block->p_buffer, 0, p_block->i_buffer );
-        p_sys->i_reject_count--;
-    }
-
-    p_block->i_buffer = p_block->i_nb_samples
-                        * p_dec->fmt_out.audio.i_bytes_per_frame;
-    p_block->i_pts = date_Get( &p_sys->end_date );
-    p_block->i_length = date_Increment( &p_sys->end_date,
-                                      p_block->i_nb_samples ) - p_block->i_pts;
     return p_block;
-
-end:
-    *pp_block = NULL;
-drop:
-#if (LIBAVCODEC_VERSION_MAJOR >= 55)
-    av_frame_free(&frame);
-#endif
-    if( p_block != NULL )
-        block_Release(p_block);
-    return NULL;
 }
 
 /*****************************************************************************
@@ -511,6 +574,7 @@ static void SetupOutputFormat( decoder_t *p_dec, bool b_trust )
     decoder_sys_t *p_sys = p_dec->p_sys;
 
     p_dec->fmt_out.i_codec = GetVlcAudioFormat( p_sys->p_context->sample_fmt );
+    p_dec->fmt_out.audio.channel_type = p_dec->fmt_in.audio.channel_type;
     p_dec->fmt_out.audio.i_format = p_dec->fmt_out.i_codec;
     p_dec->fmt_out.audio.i_rate = p_sys->p_context->sample_rate;
 
@@ -524,45 +588,66 @@ static void SetupOutputFormat( decoder_t *p_dec, bool b_trust )
         p_sys->i_previous_layout = p_sys->p_context->channel_layout;
     }
 
-    /* Specified order
-     * FIXME should we use fmt_in.audio.i_physical_channels or not ?
-     */
-    const unsigned i_order_max = 8 * sizeof(p_sys->p_context->channel_layout);
+    const unsigned i_order_max = sizeof(pi_channels_map)/sizeof(*pi_channels_map);
     uint32_t pi_order_src[i_order_max];
+
     int i_channels_src = 0;
+    uint64_t channel_layout =
+        p_sys->p_context->channel_layout ? p_sys->p_context->channel_layout :
+        (uint64_t)av_get_default_channel_layout( p_sys->p_context->channels );
 
-    if( p_sys->p_context->channel_layout )
+    if( channel_layout )
     {
-        for( unsigned i = 0; i < sizeof(pi_channels_map)/sizeof(*pi_channels_map); i++ )
+        for( unsigned i = 0; i < i_order_max
+         && i_channels_src < p_sys->p_context->channels; i++ )
         {
-            if( p_sys->p_context->channel_layout & pi_channels_map[i][0] )
+            if( channel_layout & pi_channels_map[i][0] )
                 pi_order_src[i_channels_src++] = pi_channels_map[i][1];
         }
+
+        if( i_channels_src != p_sys->p_context->channels && b_trust )
+            msg_Err( p_dec, "Channel layout not understood" );
+
+        /* Detect special dual mono case */
+        if( i_channels_src == 2 && pi_order_src[0] == AOUT_CHAN_CENTER
+         && pi_order_src[1] == AOUT_CHAN_CENTER )
+        {
+            p_dec->fmt_out.audio.i_chan_mode |= AOUT_CHANMODE_DUALMONO;
+            pi_order_src[0] = AOUT_CHAN_LEFT;
+            pi_order_src[1] = AOUT_CHAN_RIGHT;
+        }
+
+        uint32_t i_layout_dst;
+        int      i_channels_dst;
+        p_sys->b_extract = aout_CheckChannelExtraction( p_sys->pi_extraction,
+                                                        &i_layout_dst, &i_channels_dst,
+                                                        NULL, pi_order_src, i_channels_src );
+        if( i_channels_dst != i_channels_src && b_trust )
+            msg_Warn( p_dec, "%d channels are dropped", i_channels_src - i_channels_dst );
+
+        /* Restore the right order of Ambisonic order 1 channels encoded in AAC... */
+        if (p_dec->fmt_out.audio.channel_type == AUDIO_CHANNEL_TYPE_AMBISONICS
+            && p_dec->fmt_in.i_codec == VLC_CODEC_MP4A
+            && i_channels_src == 4)
+        {
+            p_sys->pi_extraction[0] = 2;
+            p_sys->pi_extraction[1] = 0;
+            p_sys->pi_extraction[2] = 1;
+            p_sys->pi_extraction[3] = 3;
+            i_layout_dst = AOUT_CHAN_CENTER | AOUT_CHAN_LEFT
+                    | AOUT_CHAN_RIGHT | AOUT_CHAN_REARCENTER;
+            p_sys->b_extract = true;
+        }
+
+        p_dec->fmt_out.audio.i_physical_channels = i_layout_dst;
     }
     else
     {
-        /* Create default order  */
-        if( b_trust )
-            msg_Warn( p_dec, "Physical channel configuration not set : guessing" );
-        for( unsigned int i = 0; i < __MIN( i_order_max, (unsigned)p_sys->p_context->channels ); i++ )
-        {
-            if( i < sizeof(pi_channels_map)/sizeof(*pi_channels_map) )
-                pi_order_src[i_channels_src++] = pi_channels_map[i][1];
-        }
+        msg_Warn( p_dec, "no channel layout found");
+        p_dec->fmt_out.audio.i_physical_channels = 0;
+        p_dec->fmt_out.audio.i_channels = p_sys->p_context->channels;
     }
-    if( i_channels_src != p_sys->p_context->channels && b_trust )
-        msg_Err( p_dec, "Channel layout not understood" );
-
-    uint32_t i_layout_dst;
-    int      i_channels_dst;
-    p_sys->b_extract = aout_CheckChannelExtraction( p_sys->pi_extraction,
-                                                    &i_layout_dst, &i_channels_dst,
-                                                    NULL, pi_order_src, i_channels_src );
-    if( i_channels_dst != i_channels_src && b_trust )
-        msg_Warn( p_dec, "%d channels are dropped", i_channels_src - i_channels_dst );
-
-    p_dec->fmt_out.audio.i_physical_channels =
-    p_dec->fmt_out.audio.i_original_channels = i_layout_dst;
+
     aout_FormatPrepare( &p_dec->fmt_out.audio );
 }
 
diff --git modules/codec/avcodec/avcodec.c modules/codec/avcodec/avcodec.c
index bea537412..0e08c11fc 100644
--- modules/codec/avcodec/avcodec.c
+++ modules/codec/avcodec/avcodec.c
@@ -42,26 +42,12 @@
 #include "chroma.h"
 #include "avcommon.h"
 
-#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT( 53, 34, 0 )
-#   error You must update libavcodec to a version >= 53.34.0
-#elif LIBAVCODEC_VERSION_INT < AV_VERSION_INT( 54, 25, 0 )
-#   warning You should update libavcodec to a version >= 54.25.0
-#endif
-
-/*****************************************************************************
- * decoder_sys_t: decoder descriptor
- *****************************************************************************/
-struct decoder_sys_t
-{
-    /* Common part between video and audio decoder */
-    AVCODEC_COMMON_MEMBERS
-};
-
 /****************************************************************************
  * Local prototypes
  ****************************************************************************/
-static int OpenDecoder( vlc_object_t * );
-static void CloseDecoder( vlc_object_t * );
+static const int  frame_skip_list[] = { -1, 0, 1, 2, 3, 4 };
+static const char *const frame_skip_list_text[] =
+  { N_("None"), N_("Default"), N_("Non-ref"), N_("Bidir"), N_("Non-key"), N_("All") };
 
 static const int  nloopf_list[] = { 0, 1, 2, 3, 4 };
 static const char *const nloopf_list_text[] =
@@ -88,19 +74,30 @@ static const char *const enc_hq_list_text[] = {
 
 vlc_module_begin ()
     set_shortname( "FFmpeg")
-    add_shortcut( "ffmpeg" )
     set_category( CAT_INPUT )
     set_subcategory( SUBCAT_INPUT_VCODEC )
     /* decoder main module */
     set_description( N_("FFmpeg audio/video decoder") )
     set_help( MODULE_DESCRIPTION )
-    set_capability( "decoder", 70 )
     set_section( N_("Decoding") , NULL )
-    set_callbacks( OpenDecoder, CloseDecoder )
 
+    add_shortcut("ffmpeg")
+    set_capability("video decoder", 70)
+    set_callbacks(InitVideoDec, EndVideoDec)
+
+    add_submodule()
+    add_shortcut("ffmpeg")
+    set_capability("audio decoder", 70)
+    set_callbacks(InitAudioDec, EndAudioDec)
+
+    add_submodule()
+    add_shortcut("ffmpeg")
+    set_capability("spu decoder", 70)
+    set_callbacks(InitSubtitleDec, EndSubtitleDec)
 
     add_obsolete_bool( "ffmpeg-dr" ) /* removed since 2.1.0 */
     add_bool( "avcodec-dr", true, DR_TEXT, DR_TEXT, true )
+    add_bool( "avcodec-corrupted", true, CORRUPTED_TEXT, CORRUPTED_LONGTEXT, false )
     add_obsolete_integer ( "ffmpeg-error-resilience" ) /* removed since 2.1.0 */
     add_integer ( "avcodec-error-resilience", 1, ERROR_TEXT,
         ERROR_LONGTEXT, true )
@@ -113,14 +110,13 @@ vlc_module_begin ()
     add_obsolete_integer( "ffmpeg-skip-frame") /* removed since 2.1.0 */
     add_integer( "avcodec-skip-frame", 0, SKIP_FRAME_TEXT,
         SKIP_FRAME_LONGTEXT, true )
-        change_integer_range( -1, 4 )
+        change_integer_list( frame_skip_list, frame_skip_list_text )
     add_obsolete_integer( "ffmpeg-skip-idct" ) /* removed since 2.1.0 */
     add_integer( "avcodec-skip-idct", 0, SKIP_IDCT_TEXT,
         SKIP_IDCT_LONGTEXT, true )
         change_integer_range( -1, 4 )
-    add_obsolete_integer ( "ffmpeg-vismv" ) /* removed since 2.1.0 */
-    add_integer ( "avcodec-vismv", 0, VISMV_TEXT, VISMV_LONGTEXT,
-        true )
+    add_obsolete_integer( "ffmpeg-vismv" ) /* removed since 2.1.0 */
+    add_obsolete_integer( "avcodec-vismv" ) /* removed since 3.0.0 */
     add_obsolete_integer ( "ffmpeg-lowres" ) /* removed since 2.1.0 */
     add_obsolete_bool( "ffmpeg-fast" ) /* removed since 2.1.0 */
     add_bool( "avcodec-fast", false, FAST_TEXT, FAST_LONGTEXT, false )
@@ -136,13 +132,7 @@ vlc_module_begin ()
     add_obsolete_string( "ffmpeg-codec" ) /* removed since 2.1.0 */
     add_string( "avcodec-codec", NULL, CODEC_TEXT, CODEC_LONGTEXT, true )
     add_obsolete_bool( "ffmpeg-hw" ) /* removed since 2.1.0 */
-    add_module( "avcodec-hw", "hw decoder",
-#ifdef _WIN32
-            "none"
-#else
-            "any"
-#endif
-            , HW_TEXT, HW_LONGTEXT, false )
+    add_module("avcodec-hw", "hw decoder", "any", HW_TEXT, HW_LONGTEXT)
 #if defined(FF_THREAD_FRAME)
     add_obsolete_integer( "ffmpeg-threads" ) /* removed since 2.1.0 */
     add_integer( "avcodec-threads", 0, THREADS_TEXT, THREADS_LONGTEXT, true );
@@ -157,7 +147,7 @@ vlc_module_begin ()
     set_section( N_("Encoding") , NULL )
     set_description( N_("FFmpeg audio/video encoder") )
     set_capability( "encoder", 100 )
-    set_callbacks( OpenEncoder, CloseEncoder )
+    set_callbacks( InitVideoEnc, EndVideoEnc )
 
     /* removed in 2.1.0 */
     add_obsolete_string( "sout-ffmpeg-codec" )
@@ -257,184 +247,75 @@ vlc_module_begin ()
 #endif
 vlc_module_end ()
 
-/*****************************************************************************
- * OpenDecoder: probe the decoder and return score
- *****************************************************************************/
-static int OpenDecoder( vlc_object_t *p_this )
+AVCodecContext *ffmpeg_AllocContext( decoder_t *p_dec,
+                                     const AVCodec **restrict codecp )
 {
-    decoder_t *p_dec = (decoder_t*) p_this;
     unsigned i_codec_id;
-    int i_cat, i_result;
     const char *psz_namecodec;
-
-    AVCodecContext *p_context = NULL;
-    AVCodec        *p_codec = NULL;
+    const AVCodec *p_codec = NULL;
 
     /* *** determine codec type *** */
-    if( !GetFfmpegCodec( p_dec->fmt_in.i_codec, &i_cat, &i_codec_id,
-                             &psz_namecodec )
-     || i_cat == UNKNOWN_ES )
-    {
-        return VLC_EGENERIC;
-    }
+    if( !GetFfmpegCodec( p_dec->fmt_in.i_cat, p_dec->fmt_in.i_codec,
+                         &i_codec_id, &psz_namecodec ) )
+         return NULL;
+
+    msg_Dbg( p_dec, "using %s %s", AVPROVIDER(LIBAVCODEC), LIBAVCODEC_IDENT );
 
     /* Initialization must be done before avcodec_find_decoder() */
-    vlc_init_avcodec(p_this);
+    vlc_init_avcodec(VLC_OBJECT(p_dec));
 
     /* *** ask ffmpeg for a decoder *** */
-    char *psz_decoder = var_CreateGetString( p_this, "avcodec-codec" );
-    if( psz_decoder && *psz_decoder )
+    char *psz_decoder = var_InheritString( p_dec, "avcodec-codec" );
+    if( psz_decoder != NULL )
     {
         p_codec = avcodec_find_decoder_by_name( psz_decoder );
         if( !p_codec )
-            msg_Err( p_this, "Decoder `%s' not found", psz_decoder );
+            msg_Err( p_dec, "Decoder `%s' not found", psz_decoder );
         else if( p_codec->id != i_codec_id )
         {
-            msg_Err( p_this, "Decoder `%s' can't handle %4.4s",
+            msg_Err( p_dec, "Decoder `%s' can't handle %4.4s",
                     psz_decoder, (char*)&p_dec->fmt_in.i_codec );
             p_codec = NULL;
         }
+        free( psz_decoder );
     }
-    free( psz_decoder );
     if( !p_codec )
         p_codec = avcodec_find_decoder( i_codec_id );
     if( !p_codec )
     {
         msg_Dbg( p_dec, "codec not found (%s)", psz_namecodec );
-        return VLC_EGENERIC;
-    }
-
-    /* *** get a p_context *** */
-    p_context = avcodec_alloc_context3(p_codec);
-    if( !p_context )
-        return VLC_ENOMEM;
-    p_context->debug = var_InheritInteger( p_dec, "avcodec-debug" );
-    p_context->opaque = (void *)p_this;
-
-    p_dec->b_need_packetized = true;
-    switch( i_cat )
-    {
-    case VIDEO_ES:
-        p_dec->pf_decode_video = DecodeVideo;
-        i_result =  InitVideoDec ( p_dec, p_context, p_codec,
-                                       i_codec_id, psz_namecodec );
-        break;
-    case AUDIO_ES:
-        p_dec->pf_decode_audio = DecodeAudio;
-        i_result =  InitAudioDec ( p_dec, p_context, p_codec,
-                                       i_codec_id, psz_namecodec );
-        break;
-    case SPU_ES:
-        p_dec->pf_decode_sub = DecodeSubtitle;
-        i_result =  InitSubtitleDec( p_dec, p_context, p_codec,
-                                     i_codec_id, psz_namecodec );
-        break;
-    default:
-        i_result = VLC_EGENERIC;
-    }
-
-    if( i_result == VLC_SUCCESS )
-    {
-        p_dec->p_sys->i_cat = i_cat;
-        if( p_context->profile != FF_PROFILE_UNKNOWN)
-            p_dec->fmt_in.i_profile = p_context->profile;
-        if( p_context->level != FF_LEVEL_UNKNOWN)
-            p_dec->fmt_in.i_level = p_context->level;
-    }
-
-    return i_result;
-}
-
-/*****************************************************************************
- * CloseDecoder: decoder destruction
- *****************************************************************************/
-static void CloseDecoder( vlc_object_t *p_this )
-{
-    decoder_t *p_dec = (decoder_t *)p_this;
-    decoder_sys_t *p_sys = p_dec->p_sys;
-
-    switch( p_sys->i_cat )
-    {
-    case VIDEO_ES:
-         EndVideoDec ( p_dec );
-        break;
+        return NULL;
     }
 
-    if( p_sys->p_context )
-    {
-        av_free( p_sys->p_context->extradata );
-        p_sys->p_context->extradata = NULL;
+    *codecp = p_codec;
 
-        if( !p_sys->b_delayed_open )
-        {
-            vlc_avcodec_lock();
-            avcodec_close( p_sys->p_context );
-            vlc_avcodec_unlock();
-        }
-        msg_Dbg( p_dec, "ffmpeg codec (%s) stopped", p_sys->psz_namecodec );
-        av_free( p_sys->p_context );
-    }
+    /* *** get a p_context *** */
+    AVCodecContext *avctx = avcodec_alloc_context3(p_codec);
+    if( unlikely(avctx == NULL) )
+        return NULL;
 
-    free( p_sys );
+    avctx->debug = var_InheritInteger( p_dec, "avcodec-debug" );
+    avctx->opaque = p_dec;
+    return avctx;
 }
 
 /*****************************************************************************
  * ffmpeg_OpenCodec:
  *****************************************************************************/
-int ffmpeg_OpenCodec( decoder_t *p_dec )
+int ffmpeg_OpenCodec( decoder_t *p_dec, AVCodecContext *ctx,
+                      const AVCodec *codec )
 {
-    decoder_sys_t *p_sys = p_dec->p_sys;
-
-    if( p_sys->p_context->extradata_size <= 0 )
-    {
-        if( p_sys->i_codec_id == AV_CODEC_ID_VC1 ||
-            p_sys->i_codec_id == AV_CODEC_ID_VORBIS ||
-            p_sys->i_codec_id == AV_CODEC_ID_THEORA ||
-            ( p_sys->i_codec_id == AV_CODEC_ID_AAC &&
-              !p_dec->fmt_in.b_packetized ) )
-        {
-            msg_Warn( p_dec, "waiting for extra data for codec %s",
-                      p_sys->psz_namecodec );
-            return 1;
-        }
-    }
-    if( p_dec->fmt_in.i_cat == VIDEO_ES )
-    {
-        p_sys->p_context->width  = p_dec->fmt_in.video.i_visible_width;
-        p_sys->p_context->height = p_dec->fmt_in.video.i_visible_height;
-        if (p_sys->p_context->width  == 0)
-            p_sys->p_context->width  = p_dec->fmt_in.video.i_width;
-        else if (p_sys->p_context->width != p_dec->fmt_in.video.i_width)
-            p_sys->p_context->coded_width = p_dec->fmt_in.video.i_width;
-        if (p_sys->p_context->height == 0)
-            p_sys->p_context->height = p_dec->fmt_in.video.i_height;
-        else if (p_sys->p_context->height != p_dec->fmt_in.video.i_height)
-            p_sys->p_context->coded_height = p_dec->fmt_in.video.i_height;
-        p_sys->p_context->bits_per_coded_sample = p_dec->fmt_in.video.i_bits_per_pixel;
-    }
-    else if( p_dec->fmt_in.i_cat == AUDIO_ES )
-    {
-        p_sys->p_context->sample_rate = p_dec->fmt_in.audio.i_rate;
-        p_sys->p_context->channels = p_dec->fmt_in.audio.i_channels;
-
-        p_sys->p_context->block_align = p_dec->fmt_in.audio.i_blockalign;
-        p_sys->p_context->bit_rate = p_dec->fmt_in.i_bitrate;
-        p_sys->p_context->bits_per_coded_sample = p_dec->fmt_in.audio.i_bitspersample;
-        if( p_sys->i_codec_id == AV_CODEC_ID_ADPCM_G726 &&
-            p_sys->p_context->bit_rate > 0 &&
-            p_sys->p_context->sample_rate >  0)
-            p_sys->p_context->bits_per_coded_sample = p_sys->p_context->bit_rate /
-                                                      p_sys->p_context->sample_rate;
-    }
-    int ret;
     char *psz_opts = var_InheritString( p_dec, "avcodec-options" );
     AVDictionary *options = NULL;
-    if (psz_opts && *psz_opts)
-        options = vlc_av_get_options(psz_opts);
-    free(psz_opts);
+    int ret;
+
+    if (psz_opts) {
+        vlc_av_get_options(psz_opts, &options);
+        free(psz_opts);
+    }
 
     vlc_avcodec_lock();
-    ret = avcodec_open2( p_sys->p_context, p_sys->p_codec, options ? &options : NULL );
+    ret = avcodec_open2( ctx, codec, options ? &options : NULL );
     vlc_avcodec_unlock();
 
     AVDictionaryEntry *t = NULL;
@@ -444,35 +325,11 @@ int ffmpeg_OpenCodec( decoder_t *p_dec )
     av_dict_free(&options);
 
     if( ret < 0 )
-        return VLC_EGENERIC;
-    msg_Dbg( p_dec, "avcodec codec (%s) started", p_sys->psz_namecodec );
-
-#ifdef HAVE_AVCODEC_MT
-    if( p_dec->fmt_in.i_cat == VIDEO_ES )
     {
-        switch( p_sys->p_context->active_thread_type )
-        {
-            case FF_THREAD_FRAME:
-                msg_Dbg( p_dec, "using frame thread mode with %d threads",
-                         p_sys->p_context->thread_count );
-                break;
-            case FF_THREAD_SLICE:
-                msg_Dbg( p_dec, "using slice thread mode with %d threads",
-                         p_sys->p_context->thread_count );
-                break;
-            case 0:
-                if( p_sys->p_context->thread_count > 1 )
-                    msg_Warn( p_dec, "failed to enable threaded decoding" );
-                break;
-            default:
-                msg_Warn( p_dec, "using unknown thread mode with %d threads",
-                          p_sys->p_context->thread_count );
-                break;
-        }
+        msg_Err( p_dec, "cannot start codec (%s)", codec->name );
+        return VLC_EGENERIC;
     }
-#endif
-
-    p_sys->b_delayed_open = false;
 
+    msg_Dbg( p_dec, "codec (%s) started", codec->name );
     return VLC_SUCCESS;
 }
diff --git modules/codec/avcodec/avcodec.h modules/codec/avcodec/avcodec.h
index 7551ab55b..52e522dc3 100644
--- modules/codec/avcodec/avcodec.h
+++ modules/codec/avcodec/avcodec.h
@@ -25,43 +25,30 @@
 #include "avcommon.h"
 
 /* VLC <-> avcodec tables */
-int GetFfmpegCodec( vlc_fourcc_t i_fourcc, int *pi_cat,
-                    unsigned *pi_ffmpeg_codec, const char **ppsz_name );
-int GetVlcFourcc( unsigned i_ffmpeg_codec, int *pi_cat,
-                  vlc_fourcc_t *pi_fourcc, const char **ppsz_name );
+bool GetFfmpegCodec( enum es_format_category_e cat, vlc_fourcc_t i_fourcc,
+                     unsigned *pi_ffmpeg_codec, const char **ppsz_name );
+vlc_fourcc_t GetVlcFourcc( unsigned i_ffmpeg_codec );
 vlc_fourcc_t GetVlcAudioFormat( int i_sample_fmt );
 
-picture_t * DecodeVideo( decoder_t *, block_t ** );
-block_t * DecodeAudio( decoder_t *, block_t ** );
-subpicture_t *DecodeSubtitle( decoder_t *p_dec, block_t ** );
-
 /* Video encoder module */
-int  OpenEncoder ( vlc_object_t * );
-void CloseEncoder( vlc_object_t * );
-
-/* Audio encoder module */
-int  OpenAudioEncoder ( vlc_object_t * );
-void CloseAudioEncoder( vlc_object_t * );
-
-/* Deinterlace video filter module */
-int  OpenDeinterlace( vlc_object_t * );
-void CloseDeinterlace( vlc_object_t * );
+int  InitVideoEnc ( vlc_object_t * );
+void EndVideoEnc( vlc_object_t * );
 
 /* Video Decoder */
-int InitVideoDec( decoder_t *p_dec, AVCodecContext *p_context,
-                  AVCodec *p_codec, int i_codec_id, const char *psz_namecodec );
-void EndVideoDec( decoder_t *p_dec );
+int InitVideoDec( vlc_object_t * );
+void EndVideoDec( vlc_object_t * );
 
 /* Audio Decoder */
-int InitAudioDec( decoder_t *p_dec, AVCodecContext *p_context,
-                  AVCodec *p_codec, int i_codec_id, const char *psz_namecodec );
+int InitAudioDec( vlc_object_t * );
+void EndAudioDec( vlc_object_t * );
 
 /* Subtitle Decoder */
-int InitSubtitleDec( decoder_t *p_dec, AVCodecContext *p_context,
-                     AVCodec *p_codec, int i_codec_id, const char *psz_namecodec );
+int InitSubtitleDec( vlc_object_t * );
+void EndSubtitleDec( vlc_object_t * );
 
 /* Initialize decoder */
-int ffmpeg_OpenCodec( decoder_t *p_dec );
+AVCodecContext *ffmpeg_AllocContext( decoder_t *, const AVCodec ** );
+int ffmpeg_OpenCodec( decoder_t *p_dec, AVCodecContext *, const AVCodec * );
 
 /*****************************************************************************
  * Module descriptor help strings
@@ -69,6 +56,9 @@ int ffmpeg_OpenCodec( decoder_t *p_dec );
 #define DR_TEXT N_("Direct rendering")
 /* FIXME Does somebody who knows what it does, explain */
 
+#define CORRUPTED_TEXT N_("Show corrupted frames")
+#define CORRUPTED_LONGTEXT N_("Prefer visual artifacts instead of missing frames")
+
 #define ERROR_TEXT N_("Error resilience")
 #define ERROR_LONGTEXT N_( \
     "libavcodec can do error resilience.\n" \
@@ -115,16 +105,6 @@ int ffmpeg_OpenCodec( decoder_t *p_dec );
 #define CODEC_TEXT N_( "Codec name" )
 #define CODEC_LONGTEXT N_( "Internal libavcodec codec name" )
 
-/* TODO: Use a predefined list, with 0,1,2,4,7 */
-#define VISMV_TEXT N_( "Visualize motion vectors" )
-#define VISMV_LONGTEXT N_( \
-    "You can overlay the motion vectors (arrows showing how the images move) "\
-    "on the image. This value is a mask, based on these values:\n"\
-    "1 - visualize forward predicted MVs of P frames\n" \
-    "2 - visualize forward predicted MVs of B frames\n" \
-    "4 - visualize backward predicted MVs of B frames\n" \
-    "To visualize all vectors, the value should be 7." )
-
 #define SKIPLOOPF_TEXT N_( "Skip the loop filter for H.264 decoding" )
 #define SKIPLOOPF_LONGTEXT N_( "Skipping the loop filter (aka deblocking) " \
     "usually has a detrimental effect on quality. However it provides a big " \
@@ -133,9 +113,6 @@ int ffmpeg_OpenCodec( decoder_t *p_dec );
 #define HW_TEXT N_("Hardware decoding")
 #define HW_LONGTEXT N_("This allows hardware decoding when available.")
 
-#define VDA_PIX_FMT_TEXT N_("VDA output pixel format")
-#define VDA_PIX_FMT_LONGTEXT N_("The pixel format for output image buffers.")
-
 #define THREADS_TEXT N_( "Threads" )
 #define THREADS_LONGTEXT N_( "Number of threads used for decoding, 0 meaning auto" )
 
@@ -256,19 +233,7 @@ int ffmpeg_OpenCodec( decoder_t *p_dec );
    "main, low, ssr (not supported),ltp, hev1, hev2 (default: low). " \
    "hev1 and hev2 are currently supported only with libfdk-aac enabled libavcodec" )
 
-#define AVCODEC_COMMON_MEMBERS   \
-    int i_cat;                  \
-    int i_codec_id;             \
-    const char *psz_namecodec;  \
-    AVCodecContext *p_context;  \
-    AVCodec        *p_codec;    \
-    bool b_delayed_open;
-
 #ifndef AV_VERSION_INT
 #   define AV_VERSION_INT(a, b, c) ((a)<<16 | (b)<<8 | (c))
 #endif
 
-#if defined(FF_THREAD_FRAME)
-#   define HAVE_AVCODEC_MT
-#endif
-
diff --git modules/codec/avcodec/avcommon.h modules/codec/avcodec/avcommon.h
index 411ddaceb..65ad35f4a 100644
--- modules/codec/avcodec/avcommon.h
+++ modules/codec/avcodec/avcommon.h
@@ -31,6 +31,7 @@
 #include <vlc_avcodec.h>
 #include <vlc_configuration.h>
 #include <vlc_variables.h>
+#include <vlc_es.h>
 
 #include <limits.h>
 
@@ -42,22 +43,21 @@
 # include <libavutil/cpu.h>
 # include <libavutil/log.h>
 
-#define AV_OPTIONS_TEXT     "Advanced options"
-#define AV_OPTIONS_LONGTEXT "Advanced options, in the form {opt=val,opt2=val2}."
+#define AV_OPTIONS_TEXT     N_("Advanced options")
+#define AV_OPTIONS_LONGTEXT N_("Advanced options, in the form {opt=val,opt2=val2}.")
 
-static inline AVDictionary *vlc_av_get_options(const char *psz_opts)
+static inline void vlc_av_get_options(const char *psz_opts, AVDictionary** pp_dict)
 {
-    AVDictionary *options = NULL;
     config_chain_t *cfg = NULL;
     config_ChainParseOptions(&cfg, psz_opts);
     while (cfg) {
         config_chain_t *next = cfg->p_next;
-        av_dict_set(&options, cfg->psz_name, cfg->psz_value,
-            AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL);
+        av_dict_set(pp_dict, cfg->psz_name, cfg->psz_value, 0);
+        free(cfg->psz_name);
+        free(cfg->psz_value);
         free(cfg);
         cfg = next;
     }
-    return options;
 }
 
 static inline void vlc_init_avutil(vlc_object_t *obj)
@@ -73,7 +73,13 @@ static inline void vlc_init_avutil(vlc_object_t *obj)
         case VLC_MSG_WARN:
             level = AV_LOG_WARNING;
             break;
+        case VLC_MSG_INFO:
+            level = AV_LOG_INFO;
+            break;
         case VLC_MSG_DBG:
+            level = AV_LOG_VERBOSE;
+            break;
+        case VLC_MSG_DBG+1:
             level = AV_LOG_DEBUG;
         default:
             break;
@@ -110,13 +116,86 @@ static inline void vlc_init_avcodec(vlc_object_t *obj)
 
     vlc_init_avutil(obj);
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-    avcodec_init();
-#endif
     avcodec_register_all();
 
     vlc_avcodec_unlock();
 }
 #endif
 
+static inline vlc_rational_t FromAVRational(const AVRational rat)
+{
+    return (vlc_rational_t){.num = rat.num, .den = rat.den};
+}
+
+static inline void set_video_color_settings( const video_format_t *p_fmt, AVCodecContext *p_context )
+{
+    if( p_fmt->b_color_range_full )
+        p_context->color_range = AVCOL_RANGE_JPEG;
+
+    switch( p_fmt->space )
+    {
+        case COLOR_SPACE_BT709:
+            p_context->colorspace = AVCOL_SPC_BT709;
+            break;
+        case COLOR_SPACE_BT601:
+            p_context->colorspace = AVCOL_SPC_BT470BG;
+            break;
+        case COLOR_SPACE_BT2020:
+            p_context->colorspace = AVCOL_SPC_BT2020_CL;
+            break;
+        default:
+            p_context->colorspace = AVCOL_SPC_UNSPECIFIED;
+            break;
+    }
+
+    switch( p_fmt->transfer )
+    {
+        case TRANSFER_FUNC_LINEAR:
+            p_context->color_trc = AVCOL_TRC_LINEAR;
+            break;
+        case TRANSFER_FUNC_SRGB:
+            p_context->color_trc = AVCOL_TRC_GAMMA22;
+            break;
+        case TRANSFER_FUNC_BT470_BG:
+            p_context->color_trc = AVCOL_TRC_GAMMA28;
+            break;
+        case TRANSFER_FUNC_BT470_M:
+            p_context->color_trc = AVCOL_TRC_GAMMA22;
+            break;
+        case TRANSFER_FUNC_BT709:
+            p_context->color_trc = AVCOL_TRC_BT709;
+            break;
+        case TRANSFER_FUNC_SMPTE_ST2084:
+            p_context->color_trc = AVCOL_TRC_SMPTEST2084;
+            break;
+        case TRANSFER_FUNC_SMPTE_240:
+            p_context->color_trc = AVCOL_TRC_SMPTE240M;
+            break;
+        default:
+            p_context->color_trc = AVCOL_TRC_UNSPECIFIED;
+            break;
+    }
+    switch( p_fmt->primaries )
+    {
+        case COLOR_PRIMARIES_BT601_525:
+            p_context->color_primaries = AVCOL_PRI_SMPTE170M;
+            break;
+        case COLOR_PRIMARIES_BT601_625:
+            p_context->color_primaries = AVCOL_PRI_BT470BG;
+            break;
+        case COLOR_PRIMARIES_BT709:
+            p_context->color_primaries = AVCOL_PRI_BT709;
+            break;
+        case COLOR_PRIMARIES_BT2020:
+            p_context->color_primaries = AVCOL_PRI_BT2020;
+            break;
+        case COLOR_PRIMARIES_FCC1953:
+            p_context->color_primaries = AVCOL_PRI_BT470M;
+            break;
+        default:
+            p_context->color_primaries = AVCOL_PRI_UNSPECIFIED;
+            break;
+    }
+}
+
 #endif
diff --git modules/codec/avcodec/avcommon_compat.h modules/codec/avcodec/avcommon_compat.h
index 3fc14dc16..8f9c12081 100644
--- modules/codec/avcodec/avcommon_compat.h
+++ modules/codec/avcodec/avcommon_compat.h
@@ -25,6 +25,8 @@
 #ifndef AVCOMMON_COMPAT_H
 #define AVCOMMON_COMPAT_H 1
 
+#define AVPROVIDER(lib) ((lib##_VERSION_MICRO < 100) ? "libav" : "ffmpeg")
+
 #ifdef HAVE_LIBAVCODEC_AVCODEC_H
 #include <libavcodec/avcodec.h>
 
@@ -36,447 +38,44 @@
     ( (LIBAVCODEC_VERSION_MICRO <  100 && LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( a, b, c ) ) || \
       (LIBAVCODEC_VERSION_MICRO >= 100 && LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( a, d, e ) ) )
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-#   define AV_PICTURE_TYPE_B        FF_B_TYPE
-#   define AV_PICTURE_TYPE_I        FF_I_TYPE
-#   define AV_PICTURE_TYPE_P        FF_P_TYPE
-
-#   define AV_SAMPLE_FMT_NONE       SAMPLE_FMT_NONE
-#   define AV_SAMPLE_FMT_U8         SAMPLE_FMT_U8
-#   define AV_SAMPLE_FMT_S16        SAMPLE_FMT_S16
-#   define AV_SAMPLE_FMT_S32        SAMPLE_FMT_S32
-#   define AV_SAMPLE_FMT_FLT        SAMPLE_FMT_FLT
-#   define AV_SAMPLE_FMT_DBL        SAMPLE_FMT_DBL
-
-#ifndef AV_CH_FRONT_LEFT
-#   define AV_CH_FRONT_LEFT         CH_FRONT_LEFT
-#endif
-#ifndef AV_CH_FRONT_RIGHT
-#   define AV_CH_FRONT_RIGHT        CH_FRONT_RIGHT
-#endif
-#ifndef AV_CH_FRONT_CENTER
-#   define AV_CH_FRONT_CENTER       CH_FRONT_CENTER
-#endif
-#ifndef AV_CH_LOW_FREQUENCY
-#   define AV_CH_LOW_FREQUENCY      CH_LOW_FREQUENCY
-#endif
-#ifndef AV_CH_BACK_LEFT
-#   define AV_CH_BACK_LEFT          CH_BACK_LEFT
-#endif
-#ifndef AV_CH_BACK_RIGHT
-#   define AV_CH_BACK_RIGHT         CH_BACK_RIGHT
-#endif
-#ifndef AV_CH_FRONT_LEFT_OF_CENTER
-#   define AV_CH_FRONT_LEFT_OF_CENTER  CH_FRONT_LEFT_OF_CENTER
-#endif
-#ifndef AV_CH_FRONT_RIGHT_OF_CENTER
-#   define AV_CH_FRONT_RIGHT_OF_CENTER CH_FRONT_RIGHT_OF_CENTER
+#ifndef AV_CODEC_FLAG_OUTPUT_CORRUPT
+# define AV_CODEC_FLAG_OUTPUT_CORRUPT CODEC_FLAG_OUTPUT_CORRUPT
 #endif
-#ifndef AV_CH_BACK_CENTER
-#   define AV_CH_BACK_CENTER        CH_BACK_CENTER
+#ifndef AV_CODEC_FLAG_GRAY
+# define AV_CODEC_FLAG_GRAY CODEC_FLAG_GRAY
 #endif
-#ifndef AV_CH_SIDE_LEFT
-#   define AV_CH_SIDE_LEFT          CH_SIDE_LEFT
+#ifndef AV_CODEC_FLAG_DR1
+# define AV_CODEC_FLAG_DR1 CODEC_FLAG_DR1
 #endif
-#ifndef AV_CH_SIDE_RIGHT
-#   define AV_CH_SIDE_RIGHT         CH_SIDE_RIGHT
+#ifndef AV_CODEC_FLAG_DELAY
+# define AV_CODEC_FLAG_DELAY CODEC_FLAG_DELAY
 #endif
-#ifndef AV_CH_TOP_CENTER
-#   define AV_CH_TOP_CENTER         CH_TOP_CENTER
+#ifndef AV_CODEC_FLAG2_FAST
+# define AV_CODEC_FLAG2_FAST CODEC_FLAG2_FAST
 #endif
-#ifndef AV_CH_TOP_FRONT_LEFT
-#   define AV_CH_TOP_FRONT_LEFT     CH_TOP_FRONT_LEFT
+#ifndef FF_INPUT_BUFFER_PADDING_SIZE
+# define FF_INPUT_BUFFER_PADDING_SIZE AV_INPUT_BUFFER_PADDING_SIZE
 #endif
-#ifndef AV_CH_TOP_FRONT_CENTER
-#   define AV_CH_TOP_FRONT_CENTER   CH_TOP_FRONT_CENTER
+#ifndef AV_CODEC_FLAG_INTERLACED_DCT
+# define AV_CODEC_FLAG_INTERLACED_DCT CODEC_FLAG_INTERLACED_DCT
 #endif
-#ifndef AV_CH_TOP_FRONT_RIGHT
-#   define AV_CH_TOP_FRONT_RIGHT    CH_TOP_FRONT_RIGHT
+#ifndef AV_CODEC_FLAG_INTERLACED_ME
+# define AV_CODEC_FLAG_INTERLACED_ME CODEC_FLAG_INTERLACED_ME
 #endif
-#ifndef AV_CH_TOP_BACK_LEFT
-#   define AV_CH_TOP_BACK_LEFT      CH_TOP_BACK_LEFT
+#ifndef AV_CODEC_FLAG_GLOBAL_HEADER
+# define AV_CODEC_FLAG_GLOBAL_HEADER CODEC_FLAG_GLOBAL_HEADER
 #endif
-#ifndef AV_CH_TOP_BACK_CENTER
-#   define AV_CH_TOP_BACK_CENTER    CH_TOP_BACK_CENTER
+#ifndef AV_CODEC_FLAG_LOW_DELAY
+# define AV_CODEC_FLAG_LOW_DELAY CODEC_FLAG_LOW_DELAY
 #endif
-#ifndef AV_CH_TOP_BACK_RIGHT
-#   define AV_CH_TOP_BACK_RIGHT     CH_TOP_BACK_RIGHT
+#ifndef AV_CODEC_CAP_SMALL_LAST_FRAME
+# define AV_CODEC_CAP_SMALL_LAST_FRAME CODEC_CAP_SMALL_LAST_FRAME
 #endif
-#ifndef AV_CH_STEREO_LEFT
-#   define AV_CH_STEREO_LEFT        CH_STEREO_LEFT
+#ifndef AV_INPUT_BUFFER_MIN_SIZE
+# define AV_INPUT_BUFFER_MIN_SIZE FF_MIN_BUFFER_SIZE
 #endif
-#ifndef AV_CH_STEREO_RIGHT
-#   define AV_CH_STEREO_RIGHT       CH_STEREO_RIGHT
-#endif
-
-#endif /* LIBAVCODEC_VERSION_MAJOR < 54 */
-
-#if !LIBAVCODEC_VERSION_CHECK(54, 25, 0, 51, 100)
-#define AVCodecID CodecID
-
-enum {
-    AV_CODEC_ID_NONE,
-
-    /* video codecs */
-    AV_CODEC_ID_MPEG1VIDEO,
-    AV_CODEC_ID_MPEG2VIDEO, ///< preferred ID for MPEG-1/2 video decoding
-    AV_CODEC_ID_MPEG2VIDEO_XVMC,
-    AV_CODEC_ID_H261,
-    AV_CODEC_ID_H263,
-    AV_CODEC_ID_RV10,
-    AV_CODEC_ID_RV20,
-    AV_CODEC_ID_MJPEG,
-    AV_CODEC_ID_MJPEGB,
-    AV_CODEC_ID_LJPEG,
-    AV_CODEC_ID_SP5X,
-    AV_CODEC_ID_JPEGLS,
-    AV_CODEC_ID_MPEG4,
-    AV_CODEC_ID_RAWVIDEO,
-    AV_CODEC_ID_MSMPEG4V1,
-    AV_CODEC_ID_MSMPEG4V2,
-    AV_CODEC_ID_MSMPEG4V3,
-    AV_CODEC_ID_WMV1,
-    AV_CODEC_ID_WMV2,
-    AV_CODEC_ID_H263P,
-    AV_CODEC_ID_H263I,
-    AV_CODEC_ID_FLV1,
-    AV_CODEC_ID_SVQ1,
-    AV_CODEC_ID_SVQ3,
-    AV_CODEC_ID_DVVIDEO,
-    AV_CODEC_ID_HUFFYUV,
-    AV_CODEC_ID_CYUV,
-    AV_CODEC_ID_H264,
-    AV_CODEC_ID_INDEO3,
-    AV_CODEC_ID_VP3,
-    AV_CODEC_ID_THEORA,
-    AV_CODEC_ID_ASV1,
-    AV_CODEC_ID_ASV2,
-    AV_CODEC_ID_FFV1,
-    AV_CODEC_ID_4XM,
-    AV_CODEC_ID_VCR1,
-    AV_CODEC_ID_CLJR,
-    AV_CODEC_ID_MDEC,
-    AV_CODEC_ID_ROQ,
-    AV_CODEC_ID_INTERPLAY_VIDEO,
-    AV_CODEC_ID_XAN_WC3,
-    AV_CODEC_ID_XAN_WC4,
-    AV_CODEC_ID_RPZA,
-    AV_CODEC_ID_CINEPAK,
-    AV_CODEC_ID_WS_VQA,
-    AV_CODEC_ID_MSRLE,
-    AV_CODEC_ID_MSVIDEO1,
-    AV_CODEC_ID_IDCIN,
-    AV_CODEC_ID_8BPS,
-    AV_CODEC_ID_SMC,
-    AV_CODEC_ID_FLIC,
-    AV_CODEC_ID_TRUEMOTION1,
-    AV_CODEC_ID_VMDVIDEO,
-    AV_CODEC_ID_MSZH,
-    AV_CODEC_ID_ZLIB,
-    AV_CODEC_ID_QTRLE,
-    AV_CODEC_ID_SNOW,
-    AV_CODEC_ID_TSCC,
-    AV_CODEC_ID_ULTI,
-    AV_CODEC_ID_QDRAW,
-    AV_CODEC_ID_VIXL,
-    AV_CODEC_ID_QPEG,
-    AV_CODEC_ID_PNG,
-    AV_CODEC_ID_PPM,
-    AV_CODEC_ID_PBM,
-    AV_CODEC_ID_PGM,
-    AV_CODEC_ID_PGMYUV,
-    AV_CODEC_ID_PAM,
-    AV_CODEC_ID_FFVHUFF,
-    AV_CODEC_ID_RV30,
-    AV_CODEC_ID_RV40,
-    AV_CODEC_ID_VC1,
-    AV_CODEC_ID_WMV3,
-    AV_CODEC_ID_LOCO,
-    AV_CODEC_ID_WNV1,
-    AV_CODEC_ID_AASC,
-    AV_CODEC_ID_INDEO2,
-    AV_CODEC_ID_FRAPS,
-    AV_CODEC_ID_TRUEMOTION2,
-    AV_CODEC_ID_BMP,
-    AV_CODEC_ID_CSCD,
-    AV_CODEC_ID_MMVIDEO,
-    AV_CODEC_ID_ZMBV,
-    AV_CODEC_ID_AVS,
-    AV_CODEC_ID_SMACKVIDEO,
-    AV_CODEC_ID_NUV,
-    AV_CODEC_ID_KMVC,
-    AV_CODEC_ID_FLASHSV,
-    AV_CODEC_ID_CAVS,
-    AV_CODEC_ID_JPEG2000,
-    AV_CODEC_ID_VMNC,
-    AV_CODEC_ID_VP5,
-    AV_CODEC_ID_VP6,
-    AV_CODEC_ID_VP6F,
-    AV_CODEC_ID_TARGA,
-    AV_CODEC_ID_DSICINVIDEO,
-    AV_CODEC_ID_TIERTEXSEQVIDEO,
-    AV_CODEC_ID_TIFF,
-    AV_CODEC_ID_GIF,
-#if LIBAVCODEC_VERSION_MAJOR == 53
-    AV_CODEC_ID_FFH264,
-#endif
-    AV_CODEC_ID_DXA,
-    AV_CODEC_ID_DNXHD,
-    AV_CODEC_ID_THP,
-    AV_CODEC_ID_SGI,
-    AV_CODEC_ID_C93,
-    AV_CODEC_ID_BETHSOFTVID,
-    AV_CODEC_ID_PTX,
-    AV_CODEC_ID_TXD,
-    AV_CODEC_ID_VP6A,
-    AV_CODEC_ID_AMV,
-    AV_CODEC_ID_VB,
-    AV_CODEC_ID_PCX,
-    AV_CODEC_ID_SUNRAST,
-    AV_CODEC_ID_INDEO4,
-    AV_CODEC_ID_INDEO5,
-    AV_CODEC_ID_MIMIC,
-    AV_CODEC_ID_RL2,
-#if LIBAVCODEC_VERSION_MAJOR == 53
-    AV_CODEC_ID_8SVX_EXP,
-    AV_CODEC_ID_8SVX_FIB,
-#endif
-    AV_CODEC_ID_ESCAPE124,
-    AV_CODEC_ID_DIRAC,
-    AV_CODEC_ID_BFI,
-    AV_CODEC_ID_CMV,
-    AV_CODEC_ID_MOTIONPIXELS,
-    AV_CODEC_ID_TGV,
-    AV_CODEC_ID_TGQ,
-    AV_CODEC_ID_TQI,
-    AV_CODEC_ID_AURA,
-    AV_CODEC_ID_AURA2,
-    AV_CODEC_ID_V210X,
-    AV_CODEC_ID_TMV,
-    AV_CODEC_ID_V210,
-    AV_CODEC_ID_DPX,
-    AV_CODEC_ID_MAD,
-    AV_CODEC_ID_FRWU,
-    AV_CODEC_ID_FLASHSV2,
-    AV_CODEC_ID_CDGRAPHICS,
-    AV_CODEC_ID_R210,
-    AV_CODEC_ID_ANM,
-    AV_CODEC_ID_BINKVIDEO,
-    AV_CODEC_ID_IFF_ILBM,
-    AV_CODEC_ID_IFF_BYTERUN1,
-    AV_CODEC_ID_KGV1,
-    AV_CODEC_ID_YOP,
-    AV_CODEC_ID_VP8,
-    AV_CODEC_ID_PICTOR,
-    AV_CODEC_ID_ANSI,
-    AV_CODEC_ID_A64_MULTI,
-    AV_CODEC_ID_A64_MULTI5,
-    AV_CODEC_ID_R10K,
-    AV_CODEC_ID_MXPEG,
-    AV_CODEC_ID_LAGARITH,
-    AV_CODEC_ID_PRORES,
-    AV_CODEC_ID_JV,
-    AV_CODEC_ID_DFA,
-    AV_CODEC_ID_WMV3IMAGE,
-    AV_CODEC_ID_VC1IMAGE,
-#if LIBAVCODEC_VERSION_MAJOR == 53
-    AV_CODEC_ID_G723_1,
-    AV_CODEC_ID_G729,
-#endif
-    AV_CODEC_ID_UTVIDEO,
-    AV_CODEC_ID_BMV_VIDEO,
-    AV_CODEC_ID_VBLE,
-    AV_CODEC_ID_DXTORY,
-    AV_CODEC_ID_V410,
-    AV_CODEC_ID_XWD,
-    AV_CODEC_ID_CDXL,
-    AV_CODEC_ID_XBM,
-    AV_CODEC_ID_ZEROCODEC,
-    AV_CODEC_ID_MSS1,
-    AV_CODEC_ID_MSA1,
-    AV_CODEC_ID_TSCC2,
-    AV_CODEC_ID_MTS2,
-    AV_CODEC_ID_CLLC,
-
-    /* various PAV_CM "codecs" */
-    AV_CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
-    AV_CODEC_ID_PCM_S16LE = 0x10000,
-    AV_CODEC_ID_PCM_S16BE,
-    AV_CODEC_ID_PCM_U16LE,
-    AV_CODEC_ID_PCM_U16BE,
-    AV_CODEC_ID_PCM_S8,
-    AV_CODEC_ID_PCM_U8,
-    AV_CODEC_ID_PCM_MULAW,
-    AV_CODEC_ID_PCM_ALAW,
-    AV_CODEC_ID_PCM_S32LE,
-    AV_CODEC_ID_PCM_S32BE,
-    AV_CODEC_ID_PCM_U32LE,
-    AV_CODEC_ID_PCM_U32BE,
-    AV_CODEC_ID_PCM_S24LE,
-    AV_CODEC_ID_PCM_S24BE,
-    AV_CODEC_ID_PCM_U24LE,
-    AV_CODEC_ID_PCM_U24BE,
-    AV_CODEC_ID_PCM_S24DAUD,
-    AV_CODEC_ID_PCM_ZORK,
-    AV_CODEC_ID_PCM_S16LE_PLANAR,
-    AV_CODEC_ID_PCM_DVD,
-    AV_CODEC_ID_PCM_F32BE,
-    AV_CODEC_ID_PCM_F32LE,
-    AV_CODEC_ID_PCM_F64BE,
-    AV_CODEC_ID_PCM_F64LE,
-    AV_CODEC_ID_PCM_BLURAY,
-    AV_CODEC_ID_PCM_LXF,
-    AV_CODEC_ID_S302M,
-    AV_CODEC_ID_PCM_S8_PLANAR,
-
-    /* various ADPAV_CM codecs */
-    AV_CODEC_ID_ADPCM_IMA_QT = 0x11000,
-    AV_CODEC_ID_ADPCM_IMA_WAV,
-    AV_CODEC_ID_ADPCM_IMA_DK3,
-    AV_CODEC_ID_ADPCM_IMA_DK4,
-    AV_CODEC_ID_ADPCM_IMA_WS,
-    AV_CODEC_ID_ADPCM_IMA_SMJPEG,
-    AV_CODEC_ID_ADPCM_MS,
-    AV_CODEC_ID_ADPCM_4XM,
-    AV_CODEC_ID_ADPCM_XA,
-    AV_CODEC_ID_ADPCM_ADX,
-    AV_CODEC_ID_ADPCM_EA,
-    AV_CODEC_ID_ADPCM_G726,
-    AV_CODEC_ID_ADPCM_CT,
-    AV_CODEC_ID_ADPCM_SWF,
-    AV_CODEC_ID_ADPCM_YAMAHA,
-    AV_CODEC_ID_ADPCM_SBPRO_4,
-    AV_CODEC_ID_ADPCM_SBPRO_3,
-    AV_CODEC_ID_ADPCM_SBPRO_2,
-    AV_CODEC_ID_ADPCM_THP,
-    AV_CODEC_ID_ADPCM_IMA_AMV,
-    AV_CODEC_ID_ADPCM_EA_R1,
-    AV_CODEC_ID_ADPCM_EA_R3,
-    AV_CODEC_ID_ADPCM_EA_R2,
-    AV_CODEC_ID_ADPCM_IMA_EA_SEAD,
-    AV_CODEC_ID_ADPCM_IMA_EA_EACS,
-    AV_CODEC_ID_ADPCM_EA_XAS,
-    AV_CODEC_ID_ADPCM_EA_MAXIS_XA,
-    AV_CODEC_ID_ADPCM_IMA_ISS,
-    AV_CODEC_ID_ADPCM_G722,
-    AV_CODEC_ID_ADPCM_IMA_APC,
-
-    /* AMR */
-    AV_CODEC_ID_AMR_NB = 0x12000,
-    AV_CODEC_ID_AMR_WB,
-
-    /* RealAudio codecs*/
-    AV_CODEC_ID_RA_144 = 0x13000,
-    AV_CODEC_ID_RA_288,
-
-    /* various DPAV_CM codecs */
-    AV_CODEC_ID_ROQ_DPCM = 0x14000,
-    AV_CODEC_ID_INTERPLAY_DPCM,
-    AV_CODEC_ID_XAN_DPCM,
-    AV_CODEC_ID_SOL_DPCM,
-
-    /* audio codecs */
-    AV_CODEC_ID_MP2 = 0x15000,
-    AV_CODEC_ID_MP3, ///< preferred ID for decoding MPEG audio layer 1, 2 or 3
-    AV_CODEC_ID_AAC,
-    AV_CODEC_ID_AC3,
-    AV_CODEC_ID_DTS,
-    AV_CODEC_ID_VORBIS,
-    AV_CODEC_ID_DVAUDIO,
-    AV_CODEC_ID_WMAV1,
-    AV_CODEC_ID_WMAV2,
-    AV_CODEC_ID_MACE3,
-    AV_CODEC_ID_MACE6,
-    AV_CODEC_ID_VMDAUDIO,
-#if LIBAVCODEC_VERSION_MAJOR == 53
-    AV_CODEC_ID_SONIC,
-    AV_CODEC_ID_SONIC_LS,
-#endif
-    AV_CODEC_ID_FLAC,
-    AV_CODEC_ID_MP3ADU,
-    AV_CODEC_ID_MP3ON4,
-    AV_CODEC_ID_SHORTEN,
-    AV_CODEC_ID_ALAC,
-    AV_CODEC_ID_WESTWOOD_SND1,
-    AV_CODEC_ID_GSM, ///< as in Berlin toast format
-    AV_CODEC_ID_QDM2,
-    AV_CODEC_ID_COOK,
-    AV_CODEC_ID_TRUESPEECH,
-    AV_CODEC_ID_TTA,
-    AV_CODEC_ID_SMACKAUDIO,
-    AV_CODEC_ID_QCELP,
-    AV_CODEC_ID_WAVPACK,
-    AV_CODEC_ID_DSICINAUDIO,
-    AV_CODEC_ID_IMC,
-    AV_CODEC_ID_MUSEPACK7,
-    AV_CODEC_ID_MLP,
-    AV_CODEC_ID_GSM_MS, /* as found in WAV */
-    AV_CODEC_ID_ATRAC3,
-#if LIBAVCODEC_VERSION_MAJOR < 56
-    AV_CODEC_ID_VOXWARE,
-#endif
-    AV_CODEC_ID_APE,
-    AV_CODEC_ID_NELLYMOSER,
-    AV_CODEC_ID_MUSEPACK8,
-    AV_CODEC_ID_SPEEX,
-    AV_CODEC_ID_WMAVOICE,
-    AV_CODEC_ID_WMAPRO,
-    AV_CODEC_ID_WMALOSSLESS,
-    AV_CODEC_ID_ATRAC3P,
-    AV_CODEC_ID_EAC3,
-    AV_CODEC_ID_SIPR,
-    AV_CODEC_ID_MP1,
-    AV_CODEC_ID_TWINVQ,
-    AV_CODEC_ID_TRUEHD,
-    AV_CODEC_ID_MP4ALS,
-    AV_CODEC_ID_ATRAC1,
-    AV_CODEC_ID_BINKAUDIO_RDFT,
-    AV_CODEC_ID_BINKAUDIO_DCT,
-    AV_CODEC_ID_AAC_LATM,
-    AV_CODEC_ID_QDMC,
-    AV_CODEC_ID_CELT,
-#if LIBAVCODEC_VERSION_MAJOR > 53
-    AV_CODEC_ID_G723_1,
-    AV_CODEC_ID_G729,
-    AV_CODEC_ID_8SVX_EXP,
-    AV_CODEC_ID_8SVX_FIB,
-#endif
-    AV_CODEC_ID_BMV_AUDIO,
-    AV_CODEC_ID_RALF,
-    AV_CODEC_ID_IAC,
-    AV_CODEC_ID_ILBC,
-
-    /* subtitle codecs */
-    AV_CODEC_ID_FIRST_SUBTITLE = 0x17000,          ///< A dummy ID pointing at the start of subtitle codecs.
-    AV_CODEC_ID_DVD_SUBTITLE = 0x17000,
-    AV_CODEC_ID_DVB_SUBTITLE,
-    AV_CODEC_ID_TEXT,  ///< raw UTF-8 text
-    AV_CODEC_ID_XSUB,
-    AV_CODEC_ID_SSA,
-    AV_CODEC_ID_MOV_TEXT,
-    AV_CODEC_ID_HDMV_PGS_SUBTITLE,
-    AV_CODEC_ID_DVB_TELETEXT,
-    AV_CODEC_ID_SRT,
-
-    /* other specific kind of codecs (generally used for attachments) */
-    AV_CODEC_ID_FIRST_UNKNOWN = 0x18000,           ///< A dummy ID pointing at the start of various fake codecs.
-    AV_CODEC_ID_TTF = 0x18000,
-
-    AV_CODEC_ID_PROBE = 0x19000, ///< codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it
-
-    AV_CODEC_ID_MPEG2TS = 0x20000, /**< _FAKE_ codec to indicate a raw MPEG-2 TS
-                                * stream (only used by libavformat) */
-    AV_CODEC_ID_MPEG4SYSTEMS = 0x20001, /**< _FAKE_ codec to indicate a MPEG-4 Systems
-                                * stream (only used by libavformat) */
-    AV_CODEC_ID_FFMETADATA = 0x21000,   ///< Dummy codec for streams containing only metadata information.
-};
-
-#endif /* LIBAVCODEC_VERSION < 54.25 */
-
-#if LIBAVCODEC_VERSION_MAJOR < 54
-# define avcodec_alloc_context3(a) avcodec_alloc_context()
-# define avcodec_open2(a, b, c) avcodec_open(a, b)
-# define err_recognition error_recognition
+#ifndef  FF_MAX_B_FRAMES
+# define  FF_MAX_B_FRAMES 16 // FIXME: remove this
 #endif
 
 #endif /* HAVE_LIBAVCODEC_AVCODEC_H */
@@ -492,19 +91,20 @@ enum {
     ( (LIBAVUTIL_VERSION_MICRO <  100 && LIBAVUTIL_VERSION_INT >= AV_VERSION_INT( a, b, c ) ) || \
       (LIBAVUTIL_VERSION_MICRO >= 100 && LIBAVUTIL_VERSION_INT >= AV_VERSION_INT( a, d, e ) ) )
 
-#if LIBAVUTIL_VERSION_MAJOR < 52 && !defined(AV_CPU_FLAG_MMXEXT)
-#   define AV_CPU_FLAG_MMXEXT       AV_CPU_FLAG_MMX2
-#endif
-
 #if !LIBAVUTIL_VERSION_CHECK( 52, 11, 0, 32, 100 )
 #   define AV_PIX_FMT_FLAG_HWACCEL  PIX_FMT_HWACCEL
 #endif
 
-#if !LIBAVUTIL_VERSION_CHECK( 51, 44, 0, 76, 100 )
-#   define av_pix_fmt_desc_get(a) &av_pix_fmt_descriptors[a]
+#endif /* HAVE_LIBAVUTIL_AVUTIL_H */
+
+#if LIBAVUTIL_VERSION_MAJOR >= 55
+# define FF_API_AUDIOCONVERT 1
 #endif
 
-#endif /* HAVE_LIBAVUTIL_AVUTIL_H */
+/* libavutil/pixfmt.h */
+#ifndef PixelFormat
+# define PixelFormat AVPixelFormat
+#endif
 
 #ifdef HAVE_LIBAVFORMAT_AVFORMAT_H
 # include <libavformat/avformat.h>
diff --git modules/codec/avcodec/chroma.c modules/codec/avcodec/chroma.c
index c31f93d74..d9b29b87b 100644
--- modules/codec/avcodec/chroma.c
+++ modules/codec/avcodec/chroma.c
@@ -79,29 +79,49 @@ static const struct
     {VLC_CODEC_I410, AV_PIX_FMT_YUV410P, 0, 0, 0 },
     {VLC_FOURCC('Y','V','U','9'), AV_PIX_FMT_YUV410P, 0, 0, 0 },
 
-    {VLC_FOURCC('N','V','1','2'), AV_PIX_FMT_NV12, 0, 0, 0 },
-    {VLC_FOURCC('N','V','2','1'), AV_PIX_FMT_NV21, 0, 0, 0 },
+    {VLC_CODEC_NV12, AV_PIX_FMT_NV12, 0, 0, 0 },
+    {VLC_CODEC_NV21, AV_PIX_FMT_NV21, 0, 0, 0 },
 
     {VLC_CODEC_I420_9L, AV_PIX_FMT_YUV420P9LE, 0, 0, 0 },
     {VLC_CODEC_I420_9B, AV_PIX_FMT_YUV420P9BE, 0, 0, 0 },
     {VLC_CODEC_I420_10L, AV_PIX_FMT_YUV420P10LE, 0, 0, 0 },
     {VLC_CODEC_I420_10B, AV_PIX_FMT_YUV420P10BE, 0, 0, 0 },
-#if LIBAVUTIL_VERSION_INT >= AV_VERSION_INT(51,13,0)
+#if (LIBAVUTIL_VERSION_MICRO >= 100 && LIBAVUTIL_VERSION_INT >= AV_VERSION_INT( 54, 17, 100 ) )
+    {VLC_CODEC_I420_12L, AV_PIX_FMT_YUV420P12LE, 0, 0, 0 },
+    {VLC_CODEC_I420_12B, AV_PIX_FMT_YUV420P12BE, 0, 0, 0 },
+#endif
+    {VLC_CODEC_I420_16L, AV_PIX_FMT_YUV420P16LE, 0, 0, 0 },
+    {VLC_CODEC_I420_16B, AV_PIX_FMT_YUV420P16BE, 0, 0, 0 },
+#ifdef AV_PIX_FMT_P010
+    {VLC_CODEC_P010, AV_PIX_FMT_P010, 0, 0, 0 },
+#endif
+
     {VLC_CODEC_I422_9L, AV_PIX_FMT_YUV422P9LE, 0, 0, 0 },
     {VLC_CODEC_I422_9B, AV_PIX_FMT_YUV422P9BE, 0, 0, 0 },
-#endif
     {VLC_CODEC_I422_10L, AV_PIX_FMT_YUV422P10LE, 0, 0, 0 },
     {VLC_CODEC_I422_10B, AV_PIX_FMT_YUV422P10BE, 0, 0, 0 },
+    {VLC_CODEC_I422_16L, AV_PIX_FMT_YUV422P16LE, 0, 0, 0 },
+    {VLC_CODEC_I422_16B, AV_PIX_FMT_YUV422P16BE, 0, 0, 0 },
+#if (LIBAVUTIL_VERSION_MICRO >= 100 && LIBAVUTIL_VERSION_INT >= AV_VERSION_INT( 54, 17, 100 ) )
+    {VLC_CODEC_I422_12L, AV_PIX_FMT_YUV422P12LE, 0, 0, 0 },
+    {VLC_CODEC_I422_12B, AV_PIX_FMT_YUV422P12BE, 0, 0, 0 },
+#endif
 
     {VLC_CODEC_YUV420A, AV_PIX_FMT_YUVA420P, 0, 0, 0 },
-#if LIBAVUTIL_VERSION_CHECK( 51, 45, 0, 74, 100 )
     {VLC_CODEC_YUV422A, AV_PIX_FMT_YUVA422P, 0, 0, 0 },
-#endif
+    {VLC_CODEC_YUVA,    AV_PIX_FMT_YUVA444P, 0, 0, 0 },
+
+    {VLC_CODEC_YUVA_444_10L, AV_PIX_FMT_YUVA444P10LE, 0, 0, 0 },
+    {VLC_CODEC_YUVA_444_10B, AV_PIX_FMT_YUVA444P10BE, 0, 0, 0 },
 
     {VLC_CODEC_I444_9L, AV_PIX_FMT_YUV444P9LE, 0, 0, 0 },
     {VLC_CODEC_I444_9B, AV_PIX_FMT_YUV444P9BE, 0, 0, 0 },
     {VLC_CODEC_I444_10L, AV_PIX_FMT_YUV444P10LE, 0, 0, 0 },
     {VLC_CODEC_I444_10B, AV_PIX_FMT_YUV444P10BE, 0, 0, 0 },
+#if (LIBAVUTIL_VERSION_MICRO >= 100 && LIBAVUTIL_VERSION_INT >= AV_VERSION_INT( 54, 17, 100 ) )
+    {VLC_CODEC_I444_12L, AV_PIX_FMT_YUV444P12LE, 0, 0, 0 },
+    {VLC_CODEC_I444_12B, AV_PIX_FMT_YUV444P12BE, 0, 0, 0 },
+#endif
     {VLC_CODEC_I444_16L, AV_PIX_FMT_YUV444P16LE, 0, 0, 0 },
     {VLC_CODEC_I444_16B, AV_PIX_FMT_YUV444P16BE, 0, 0, 0 },
 
@@ -109,15 +129,16 @@ static const struct
     {VLC_CODEC_YUYV, AV_PIX_FMT_YUYV422, 0, 0, 0 },
     {VLC_FOURCC('Y','U','Y','V'), AV_PIX_FMT_YUYV422, 0, 0, 0 },
     {VLC_CODEC_UYVY, AV_PIX_FMT_UYVY422, 0, 0, 0 },
+    {VLC_CODEC_YVYU, AV_PIX_FMT_YVYU422, 0, 0, 0 },
     {VLC_FOURCC('Y','4','1','1'), AV_PIX_FMT_UYYVYY411, 0, 0, 0 },
 
     /* Packed RGB formats */
     VLC_RGB( VLC_FOURCC('R','G','B','4'), AV_PIX_FMT_RGB4, AV_PIX_FMT_BGR4, 0x10, 0x06, 0x01 )
-    VLC_RGB( VLC_FOURCC('R','G','B','8'), AV_PIX_FMT_RGB8, AV_PIX_FMT_BGR8, 0xC0, 0x38, 0x07 )
+    VLC_RGB( VLC_CODEC_RGB8, AV_PIX_FMT_RGB8, AV_PIX_FMT_BGR8, 0xC0, 0x38, 0x07 )
 
     VLC_RGB( VLC_CODEC_RGB15, AV_PIX_FMT_RGB555, AV_PIX_FMT_BGR555, 0x7c00, 0x03e0, 0x001f )
     VLC_RGB( VLC_CODEC_RGB16, AV_PIX_FMT_RGB565, AV_PIX_FMT_BGR565, 0xf800, 0x07e0, 0x001f )
-    VLC_RGB( VLC_CODEC_RGB24, AV_PIX_FMT_BGR24, AV_PIX_FMT_RGB24, 0xff0000, 0x00ff00, 0x0000ff )
+    VLC_RGB( VLC_CODEC_RGB24, AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24, 0xff0000, 0x00ff00, 0x0000ff )
 
     VLC_RGB( VLC_CODEC_RGB32, AV_PIX_FMT_RGB32, AV_PIX_FMT_BGR32, 0x00ff0000, 0x0000ff00, 0x000000ff )
     VLC_RGB( VLC_CODEC_RGB32, AV_PIX_FMT_RGB32_1, AV_PIX_FMT_BGR32_1, 0xff000000, 0x00ff0000, 0x0000ff00 )
@@ -134,13 +155,11 @@ static const struct
      /* Paletized RGB */
     {VLC_CODEC_RGBP, AV_PIX_FMT_PAL8, 0, 0, 0},
 
-#if LIBAVUTIL_VERSION_CHECK(51, 42, 0, 74,100)
     {VLC_CODEC_GBR_PLANAR, AV_PIX_FMT_GBRP, 0, 0, 0 },
     {VLC_CODEC_GBR_PLANAR_9L, AV_PIX_FMT_GBRP9LE, 0, 0, 0 },
     {VLC_CODEC_GBR_PLANAR_9B, AV_PIX_FMT_GBRP9BE, 0, 0, 0 },
     {VLC_CODEC_GBR_PLANAR_10L, AV_PIX_FMT_GBRP10LE, 0, 0, 0 },
     {VLC_CODEC_GBR_PLANAR_10B, AV_PIX_FMT_GBRP10BE, 0, 0, 0 },
-#endif
 
     /* XYZ */
 #if LIBAVUTIL_VERSION_CHECK(52, 10, 0, 25, 100)
diff --git modules/codec/avcodec/chroma.h modules/codec/avcodec/chroma.h
index d7ef4eff6..99dc1d634 100644
--- modules/codec/avcodec/chroma.h
+++ modules/codec/avcodec/chroma.h
@@ -23,8 +23,8 @@
 
 /* VLC <-> avutil tables */
 
-#ifndef _VLC_AVUTIL_CHROMA_H
-#define _VLC_AVUTIL_CHROMA_H 1
+#ifndef VLC_AVUTIL_CHROMA_H_
+#define VLC_AVUTIL_CHROMA_H_
 
 int FindFfmpegChroma( vlc_fourcc_t );
 int GetFfmpegChroma( int *i_ffmpeg_chroma, const video_format_t *fmt );
diff --git modules/codec/avcodec/d3d11va.c modules/codec/avcodec/d3d11va.c
new file mode 100644
index 000000000..7201b599b
--- /dev/null
+++ modules/codec/avcodec/d3d11va.c
@@ -0,0 +1,972 @@
+/*****************************************************************************
+ * d3d11va.c: Direct3D11 Video Acceleration decoder
+ *****************************************************************************
+ * Copyright © 2009 Geoffroy Couprie
+ * Copyright © 2009 Laurent Aimar
+ * Copyright © 2015 Steve Lhomme
+ * Copyright © 2015 VideoLabs
+ *
+ * Authors: Geoffroy Couprie <geal@videolan.org>
+ *          Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *          Steve Lhomme <robux4@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+/**
+  * See https://msdn.microsoft.com/en-us/library/windows/desktop/hh162912%28v=vs.85%29.aspx
+  **/
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+# undef WINAPI_FAMILY
+# define WINAPI_FAMILY WINAPI_FAMILY_DESKTOP_APP
+
+#include <assert.h>
+
+#include <vlc_common.h>
+#include <vlc_picture.h>
+#include <vlc_plugin.h>
+#include <vlc_charset.h>
+#include <vlc_codec.h>
+
+#define COBJMACROS
+#include <initguid.h>
+#include <d3d11.h>
+#include <libavcodec/d3d11va.h>
+
+#include "../../video_chroma/d3d11_fmt.h"
+
+#define D3D_DecoderType     ID3D11VideoDecoder
+#define D3D_DecoderDevice   ID3D11VideoDevice
+#define D3D_DecoderSurface  ID3D11VideoDecoderOutputView
+#include "directx_va.h"
+
+static int Open(vlc_va_t *, AVCodecContext *, enum PixelFormat,
+                const es_format_t *, picture_sys_t *p_sys);
+static void Close(vlc_va_t *, void **);
+
+vlc_module_begin()
+    set_description(N_("Direct3D11 Video Acceleration"))
+    set_capability("hw decoder", 110)
+    set_category(CAT_INPUT)
+    set_subcategory(SUBCAT_INPUT_VCODEC)
+    set_callbacks(Open, Close)
+vlc_module_end()
+
+/*
+ * In this mode libavcodec doesn't need the whole array on texture on startup
+ * So we get the surfaces from the decoder pool when needed. We don't need to
+ * extract the decoded surface into the decoder picture anymore.
+ */
+#define D3D11_DIRECT_DECODE  LIBAVCODEC_VERSION_CHECK( 57, 30, 3, 72, 101 )
+
+#include <initguid.h> /* must be last included to not redefine existing GUIDs */
+
+/* dxva2api.h GUIDs: http://msdn.microsoft.com/en-us/library/windows/desktop/ms697067(v=vs100).aspx
+ * assume that they are declared in dxva2api.h */
+#define MS_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)
+
+#ifdef __MINGW32__
+# include <_mingw.h>
+
+# if !defined(__MINGW64_VERSION_MAJOR)
+#  undef MS_GUID
+#  define MS_GUID DEFINE_GUID /* dxva2api.h fails to declare those, redefine as static */
+#  define DXVA2_E_NEW_VIDEO_DEVICE MAKE_HRESULT(1, 4, 4097)
+# else
+#  include <dxva.h>
+# endif
+
+#endif /* __MINGW32__ */
+
+DEFINE_GUID(DXVA_Intel_H264_NoFGT_ClearVideo,       0x604F8E68, 0x4951, 0x4c54, 0x88, 0xFE, 0xAB, 0xD2, 0x5C, 0x15, 0xB3, 0xD6);
+
+DEFINE_GUID(DXVA2_NoEncrypt,                        0x1b81bed0, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+
+struct vlc_va_sys_t
+{
+    directx_sys_t                dx_sys;
+    UINT                         totalTextureSlices;
+    unsigned                     textureWidth;
+    unsigned                     textureHeight;
+
+    d3d11_handle_t               hd3d;
+    d3d11_device_t               d3d_dev;
+
+    /* Video service */
+    ID3D11VideoContext           *d3dvidctx;
+    DXGI_FORMAT                  render;
+
+    HANDLE                       context_mutex;
+
+    /* pool */
+    picture_t                    *extern_pics[MAX_SURFACE_COUNT];
+
+    /* Video decoder */
+    D3D11_VIDEO_DECODER_CONFIG   cfg;
+
+    /* avcodec internals */
+    struct AVD3D11VAContext      hw;
+
+    ID3D11ShaderResourceView     *resourceView[MAX_SURFACE_COUNT * D3D11_MAX_SHADER_VIEW];
+};
+
+/* */
+static int D3dCreateDevice(vlc_va_t *);
+static void D3dDestroyDevice(vlc_va_t *);
+static char *DxDescribe(vlc_va_sys_t *);
+
+static int DxCreateVideoService(vlc_va_t *);
+static void DxDestroyVideoService(vlc_va_t *);
+static int DxGetInputList(vlc_va_t *, input_list_t *);
+static int DxSetupOutput(vlc_va_t *, const GUID *, const video_format_t *);
+
+static int DxCreateDecoderSurfaces(vlc_va_t *, int codec_id,
+                                   const video_format_t *fmt, unsigned surface_count);
+static void DxDestroySurfaces(vlc_va_t *);
+static void SetupAVCodecContext(vlc_va_t *);
+
+void SetupAVCodecContext(vlc_va_t *va)
+{
+    vlc_va_sys_t *sys = va->sys;
+    directx_sys_t *dx_sys = &sys->dx_sys;
+
+    sys->hw.video_context = sys->d3dvidctx;
+    sys->hw.decoder = dx_sys->decoder;
+    sys->hw.cfg = &sys->cfg;
+    sys->hw.surface_count = dx_sys->va_pool.surface_count;
+    sys->hw.surface = dx_sys->hw_surface;
+    sys->hw.context_mutex = sys->context_mutex;
+
+    if (IsEqualGUID(&dx_sys->input, &DXVA_Intel_H264_NoFGT_ClearVideo))
+        sys->hw.workaround |= FF_DXVA2_WORKAROUND_INTEL_CLEARVIDEO;
+}
+
+static void d3d11_pic_context_destroy(struct picture_context_t *opaque)
+{
+    struct va_pic_context *pic_ctx = (struct va_pic_context*)opaque;
+    if (pic_ctx->va_surface)
+        va_surface_Release(pic_ctx->va_surface);
+    ReleasePictureSys(&pic_ctx->picsys);
+    free(pic_ctx);
+}
+
+static struct va_pic_context *CreatePicContext(ID3D11VideoDecoderOutputView *,
+                                               ID3D11Resource *,
+                                               ID3D11DeviceContext *,
+                                               UINT slice,
+                                               ID3D11ShaderResourceView *resourceView[D3D11_MAX_SHADER_VIEW]);
+
+static struct picture_context_t *d3d11_pic_context_copy(struct picture_context_t *ctx)
+{
+    struct va_pic_context *src_ctx = (struct va_pic_context*)ctx;
+    struct va_pic_context *pic_ctx = CreatePicContext(src_ctx->picsys.decoder,
+                                                      src_ctx->picsys.resource[0], src_ctx->picsys.context,
+                                                      src_ctx->picsys.slice_index, src_ctx->picsys.resourceView);
+    if (unlikely(pic_ctx==NULL))
+        return NULL;
+    if (src_ctx->va_surface) {
+        pic_ctx->va_surface = src_ctx->va_surface;
+        va_surface_AddRef(pic_ctx->va_surface);
+    }
+    return &pic_ctx->s;
+}
+
+static struct va_pic_context *CreatePicContext(
+                                                  ID3D11VideoDecoderOutputView *decoderSurface,
+                                                  ID3D11Resource *p_resource,
+                                                  ID3D11DeviceContext *context,
+                                                  UINT slice,
+                                                  ID3D11ShaderResourceView *resourceView[D3D11_MAX_SHADER_VIEW])
+{
+    struct va_pic_context *pic_ctx = calloc(1, sizeof(*pic_ctx));
+    if (unlikely(pic_ctx==NULL))
+        goto done;
+    pic_ctx->s.destroy = d3d11_pic_context_destroy;
+    pic_ctx->s.copy    = d3d11_pic_context_copy;
+
+    D3D11_TEXTURE2D_DESC txDesc;
+    ID3D11Texture2D_GetDesc((ID3D11Texture2D*)p_resource, &txDesc);
+
+    pic_ctx->picsys.formatTexture = txDesc.Format;
+    pic_ctx->picsys.context = context;
+    pic_ctx->picsys.slice_index = slice;
+    pic_ctx->picsys.decoder = decoderSurface;
+    for (int i=0;i<D3D11_MAX_SHADER_VIEW; i++)
+    {
+        pic_ctx->picsys.resource[i] = p_resource;
+        pic_ctx->picsys.resourceView[i] = resourceView[i];
+    }
+    AcquirePictureSys(&pic_ctx->picsys);
+    pic_ctx->picsys.context = context;
+done:
+    return pic_ctx;
+}
+
+static struct va_pic_context* NewSurfacePicContext(vlc_va_t *va, int surface_index)
+{
+    vlc_va_sys_t *sys = va->sys;
+    directx_sys_t *dx_sys = &sys->dx_sys;
+    ID3D11VideoDecoderOutputView *surface = dx_sys->hw_surface[surface_index];
+    ID3D11ShaderResourceView *resourceView[D3D11_MAX_SHADER_VIEW];
+    ID3D11Resource *p_resource;
+    ID3D11VideoDecoderOutputView_GetResource(surface, &p_resource);
+
+    D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC viewDesc;
+    ID3D11VideoDecoderOutputView_GetDesc(surface, &viewDesc);
+
+    for (int i=0; i<D3D11_MAX_SHADER_VIEW; i++)
+        resourceView[i] = sys->resourceView[viewDesc.Texture2D.ArraySlice*D3D11_MAX_SHADER_VIEW + i];
+
+    struct va_pic_context *pic_ctx = CreatePicContext(
+                                                  surface,
+                                                  p_resource,
+                                                  sys->d3d_dev.d3dcontext,
+                                                  viewDesc.Texture2D.ArraySlice,
+                                                  resourceView);
+    ID3D11Resource_Release(p_resource);
+    if (unlikely(pic_ctx==NULL))
+        return NULL;
+    /* all the resources are acquired during surfaces init, and a second time in
+     * CreatePicContext(), undo one of them otherwise we need an extra release
+     * when the pool is emptied */
+    ReleasePictureSys(&pic_ctx->picsys);
+    return pic_ctx;
+}
+
+static int Get(vlc_va_t *va, picture_t *pic, uint8_t **data)
+{
+    picture_sys_t *p_sys = pic->p_sys;
+#if D3D11_DIRECT_DECODE
+    if (va->sys->dx_sys.can_extern_pool)
+    {
+        /* copy the original picture_sys_t in the va_pic_context */
+        if (!pic->context)
+        {
+            assert(p_sys!=NULL);
+            if (!p_sys->decoder)
+            {
+                HRESULT hr;
+                D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC viewDesc;
+                ZeroMemory(&viewDesc, sizeof(viewDesc));
+                viewDesc.DecodeProfile = va->sys->dx_sys.input;
+                viewDesc.ViewDimension = D3D11_VDOV_DIMENSION_TEXTURE2D;
+                viewDesc.Texture2D.ArraySlice = p_sys->slice_index;
+
+                hr = ID3D11VideoDevice_CreateVideoDecoderOutputView( va->sys->dx_sys.d3ddec,
+                                                                     p_sys->resource[KNOWN_DXGI_INDEX],
+                                                                     &viewDesc,
+                                                                     &p_sys->decoder );
+                if (FAILED(hr))
+                    return VLC_EGENERIC;
+            }
+
+            pic->context = (picture_context_t*)CreatePicContext(
+                                             p_sys->decoder,
+                                             p_sys->resource[KNOWN_DXGI_INDEX],
+                                             va->sys->d3d_dev.d3dcontext,
+                                             p_sys->slice_index,
+                                             p_sys->resourceView );
+            if (pic->context == NULL)
+                return VLC_EGENERIC;
+        }
+    }
+    else
+#endif
+    {
+        int res = va_pool_Get(&va->sys->dx_sys.va_pool, pic);
+        if (unlikely(res != VLC_SUCCESS))
+            return res;
+    }
+    *data = (uint8_t*)((struct va_pic_context *)pic->context)->picsys.decoder;
+    return VLC_SUCCESS;
+}
+
+static void Close(vlc_va_t *va, void **ctx)
+{
+    vlc_va_sys_t *sys = va->sys;
+
+    (void) ctx;
+
+    directx_va_Close(va, &sys->dx_sys);
+
+    D3D11_Destroy( &sys->hd3d );
+
+    free((char *)va->description);
+    free(sys);
+}
+
+static int Open(vlc_va_t *va, AVCodecContext *ctx, enum PixelFormat pix_fmt,
+                const es_format_t *fmt, picture_sys_t *p_sys)
+{
+    int err = VLC_EGENERIC;
+    directx_sys_t *dx_sys;
+
+    ctx->hwaccel_context = NULL;
+
+    if (pix_fmt != AV_PIX_FMT_D3D11VA_VLD)
+        return VLC_EGENERIC;
+
+    vlc_va_sys_t *sys = calloc(1, sizeof (*sys));
+    if (unlikely(sys == NULL))
+        return VLC_ENOMEM;
+
+    dx_sys = &sys->dx_sys;
+
+    dx_sys->va_pool.pf_create_device           = D3dCreateDevice;
+    dx_sys->va_pool.pf_destroy_device          = D3dDestroyDevice;
+    dx_sys->va_pool.pf_create_video_service    = DxCreateVideoService;
+    dx_sys->va_pool.pf_destroy_video_service   = DxDestroyVideoService;
+    dx_sys->va_pool.pf_create_decoder_surfaces = DxCreateDecoderSurfaces;
+    dx_sys->va_pool.pf_destroy_surfaces        = DxDestroySurfaces;
+    dx_sys->va_pool.pf_setup_avcodec_ctx       = SetupAVCodecContext;
+    dx_sys->va_pool.pf_new_surface_context     = NewSurfacePicContext;
+    dx_sys->pf_get_input_list          = DxGetInputList;
+    dx_sys->pf_setup_output            = DxSetupOutput;
+
+    va->sys = sys;
+
+    sys->d3d_dev.d3ddevice = NULL;
+    va->sys->render = DXGI_FORMAT_UNKNOWN;
+    if ( p_sys != NULL && p_sys->context != NULL ) {
+        void *d3dvidctx = NULL;
+        HRESULT hr = ID3D11DeviceContext_QueryInterface(p_sys->context, &IID_ID3D11VideoContext, &d3dvidctx);
+        if (FAILED(hr)) {
+           msg_Err(va, "Could not Query ID3D11VideoContext Interface from the picture. (hr=0x%lX)", hr);
+        } else {
+            ID3D11DeviceContext_GetDevice( p_sys->context, &sys->d3d_dev.d3ddevice );
+            HANDLE context_lock = INVALID_HANDLE_VALUE;
+            UINT dataSize = sizeof(context_lock);
+            hr = ID3D11Device_GetPrivateData(sys->d3d_dev.d3ddevice, &GUID_CONTEXT_MUTEX, &dataSize, &context_lock);
+            if (FAILED(hr))
+                msg_Warn(va, "No mutex found to lock the decoder");
+            sys->context_mutex = context_lock;
+
+            sys->d3d_dev.d3dcontext = p_sys->context;
+            sys->d3d_dev.owner = false;
+            D3D11_GetDriverVersion(va, &sys->d3d_dev);
+            sys->d3dvidctx = d3dvidctx;
+
+            assert(p_sys->texture[KNOWN_DXGI_INDEX] != NULL);
+            D3D11_TEXTURE2D_DESC dstDesc;
+            ID3D11Texture2D_GetDesc( p_sys->texture[KNOWN_DXGI_INDEX], &dstDesc);
+            sys->render = dstDesc.Format;
+            va->sys->textureWidth = dstDesc.Width;
+            va->sys->textureHeight = dstDesc.Height;
+            va->sys->totalTextureSlices = dstDesc.ArraySize;
+        }
+    }
+
+    err = D3D11_Create( va, &sys->hd3d );
+    if (err != VLC_SUCCESS)
+        goto error;
+
+    err = directx_va_Open(va, &sys->dx_sys);
+    if (err!=VLC_SUCCESS)
+        goto error;
+
+    err = directx_va_Setup(va, &sys->dx_sys, ctx, fmt, isXboxHardware(sys->d3d_dev.d3ddevice));
+    if (err != VLC_SUCCESS)
+        goto error;
+
+    ctx->hwaccel_context = &sys->hw;
+
+    /* TODO print the hardware name/vendor for debugging purposes */
+    va->description = DxDescribe(sys);
+    va->get     = Get;
+
+    return VLC_SUCCESS;
+
+error:
+    Close(va, NULL);
+    return err;
+}
+
+/**
+ * It creates a Direct3D device usable for decoding
+ */
+static int D3dCreateDevice(vlc_va_t *va)
+{
+    vlc_va_sys_t *sys = va->sys;
+    HRESULT hr;
+
+    if (sys->d3d_dev.d3ddevice && sys->d3d_dev.d3dcontext) {
+        msg_Dbg(va, "Reusing Direct3D11 device");
+        ID3D11DeviceContext_AddRef(sys->d3d_dev.d3dcontext);
+        return VLC_SUCCESS;
+    }
+
+#if VLC_WINSTORE_APP
+    sys->d3d_dev.d3dcontext = var_InheritInteger(va, "winrt-d3dcontext");
+    if (likely(sys->d3d_dev.d3dcontext))
+    {
+        ID3D11Device* d3ddevice = NULL;
+        ID3D11DeviceContext_GetDevice(sys->d3d_dev.d3dcontext, &sys->d3d_dev.d3ddevice);
+        ID3D11DeviceContext_AddRef(sys->d3d_dev.d3dcontext);
+        ID3D11Device_Release(sys->d3d_dev.d3ddevice);
+    }
+#endif
+
+    /* */
+    if (!sys->d3d_dev.d3ddevice)
+    {
+        hr = D3D11_CreateDevice(va, &sys->hd3d, true, &sys->d3d_dev);
+        if (FAILED(hr)) {
+            msg_Err(va, "D3D11CreateDevice failed. (hr=0x%lX)", hr);
+            return VLC_EGENERIC;
+        }
+	}
+
+    void *d3dvidctx = NULL;
+    hr = ID3D11DeviceContext_QueryInterface(sys->d3d_dev.d3dcontext, &IID_ID3D11VideoContext, &d3dvidctx);
+    if (FAILED(hr)) {
+       msg_Err(va, "Could not Query ID3D11VideoContext Interface. (hr=0x%lX)", hr);
+       ID3D11DeviceContext_Release(sys->d3d_dev.d3dcontext);
+       ID3D11Device_Release(sys->d3d_dev.d3ddevice);
+       return VLC_EGENERIC;
+    }
+    sys->d3dvidctx = d3dvidctx;
+
+    return VLC_SUCCESS;
+}
+
+/**
+ * It releases a Direct3D device and its resources.
+ */
+static void D3dDestroyDevice(vlc_va_t *va)
+{
+    vlc_va_sys_t *sys = va->sys;
+    if (sys->d3dvidctx)
+        ID3D11VideoContext_Release(sys->d3dvidctx);
+    D3D11_ReleaseDevice( &sys->d3d_dev );
+}
+
+/**
+ * It describes our Direct3D object
+ */
+static char *DxDescribe(vlc_va_sys_t *sys)
+{
+
+    IDXGIAdapter *p_adapter = D3D11DeviceAdapter(sys->d3d_dev.d3ddevice);
+    if (!p_adapter) {
+       return NULL;
+    }
+
+    char *description = NULL;
+    DXGI_ADAPTER_DESC adapterDesc;
+    if (SUCCEEDED(IDXGIAdapter_GetDesc(p_adapter, &adapterDesc))) {
+        char *utfdesc = FromWide(adapterDesc.Description);
+        if (likely(utfdesc!=NULL))
+        {
+            if (asprintf(&description, "D3D11VA (%s, vendor %x(%s), device %x, revision %x)",
+                         utfdesc,
+                         adapterDesc.VendorId, DxgiVendorStr(adapterDesc.VendorId), adapterDesc.DeviceId, adapterDesc.Revision) < 0)
+                description = NULL;
+            free(utfdesc);
+        }
+    }
+
+    IDXGIAdapter_Release(p_adapter);
+    return description;
+}
+
+/**
+ * It creates a DirectX video service
+ */
+static int DxCreateVideoService(vlc_va_t *va)
+{
+    directx_sys_t *dx_sys = &va->sys->dx_sys;
+
+    void *d3dviddev = NULL;
+    HRESULT hr = ID3D11Device_QueryInterface(va->sys->d3d_dev.d3ddevice, &IID_ID3D11VideoDevice, &d3dviddev);
+    if (FAILED(hr)) {
+       msg_Err(va, "Could not Query ID3D11VideoDevice Interface. (hr=0x%lX)", hr);
+       return VLC_EGENERIC;
+    }
+    dx_sys->d3ddec = d3dviddev;
+
+    return VLC_SUCCESS;
+}
+
+/**
+ * It destroys a DirectX video service
+ */
+static void DxDestroyVideoService(vlc_va_t *va)
+{
+    directx_sys_t *dx_sys = &va->sys->dx_sys;
+    if (dx_sys->d3ddec)
+        ID3D11VideoDevice_Release(dx_sys->d3ddec);
+}
+
+static void ReleaseInputList(input_list_t *p_list)
+{
+    free(p_list->list);
+}
+
+static int DxGetInputList(vlc_va_t *va, input_list_t *p_list)
+{
+    directx_sys_t *dx_sys = &va->sys->dx_sys;
+    HRESULT hr;
+
+    UINT input_count = ID3D11VideoDevice_GetVideoDecoderProfileCount(dx_sys->d3ddec);
+
+    p_list->count = input_count;
+    p_list->list = calloc(input_count, sizeof(*p_list->list));
+    if (unlikely(p_list->list == NULL)) {
+        return VLC_ENOMEM;
+    }
+    p_list->pf_release = ReleaseInputList;
+
+    for (unsigned i = 0; i < input_count; i++) {
+        hr = ID3D11VideoDevice_GetVideoDecoderProfile(dx_sys->d3ddec, i, &p_list->list[i]);
+        if (FAILED(hr))
+        {
+            msg_Err(va, "GetVideoDecoderProfile %d failed. (hr=0x%lX)", i, hr);
+            ReleaseInputList(p_list);
+            return VLC_EGENERIC;
+        }
+    }
+
+    return VLC_SUCCESS;
+}
+
+extern const GUID DXVA_ModeHEVC_VLD_Main;
+extern const GUID DXVA_ModeHEVC_VLD_Main10;
+extern const GUID DXVA_ModeVP9_VLD_10bit_Profile2;
+static bool CanUseIntelHEVC(vlc_va_t *va)
+{
+    vlc_va_sys_t *sys = va->sys;
+    IDXGIAdapter *pAdapter = D3D11DeviceAdapter(sys->d3d_dev.d3ddevice);
+    if (!pAdapter)
+        return false;
+
+    DXGI_ADAPTER_DESC adapterDesc;
+    HRESULT hr = IDXGIAdapter_GetDesc(pAdapter, &adapterDesc);
+    IDXGIAdapter_Release(pAdapter);
+    if (FAILED(hr))
+        return false;
+
+    if (adapterDesc.VendorId != GPU_MANUFACTURER_INTEL)
+        return true;
+
+    return directx_va_canUseHevc( va, adapterDesc.DeviceId );
+}
+
+static int DxSetupOutput(vlc_va_t *va, const GUID *input, const video_format_t *fmt)
+{
+    vlc_va_sys_t *sys = va->sys;
+    directx_sys_t *dx_sys = &sys->dx_sys;
+    HRESULT hr;
+
+#ifndef NDEBUG
+    BOOL bSupported = false;
+    for (int format = 0; format < 188; format++) {
+        hr = ID3D11VideoDevice_CheckVideoDecoderFormat(dx_sys->d3ddec, input, format, &bSupported);
+        if (SUCCEEDED(hr) && bSupported)
+            msg_Dbg(va, "format %s is supported for output", DxgiFormatToStr(format));
+    }
+#endif
+
+    if ((IsEqualGUID(input,&DXVA_ModeHEVC_VLD_Main) ||
+         IsEqualGUID(input,&DXVA_ModeHEVC_VLD_Main10)) && !CanUseIntelHEVC(va))
+        return VLC_EGENERIC;
+
+    DXGI_FORMAT processorInput[5];
+    int idx = 0;
+    if ( sys->render != DXGI_FORMAT_UNKNOWN )
+        processorInput[idx++] = sys->render;
+    if (IsEqualGUID(input, &DXVA_ModeHEVC_VLD_Main10) || IsEqualGUID(input, &DXVA_ModeVP9_VLD_10bit_Profile2))
+        processorInput[idx++] = DXGI_FORMAT_P010;
+    processorInput[idx++] = DXGI_FORMAT_NV12;
+    processorInput[idx++] = DXGI_FORMAT_420_OPAQUE;
+    processorInput[idx++] = DXGI_FORMAT_UNKNOWN;
+
+    char *psz_decoder_name = directx_va_GetDecoderName(input);
+
+    /* */
+    for (idx = 0; processorInput[idx] != DXGI_FORMAT_UNKNOWN; ++idx)
+    {
+        BOOL is_supported = false;
+        hr = ID3D11VideoDevice_CheckVideoDecoderFormat(dx_sys->d3ddec, input, processorInput[idx], &is_supported);
+        if (SUCCEEDED(hr) && is_supported)
+            msg_Dbg(va, "%s output is supported for decoder %s.", DxgiFormatToStr(processorInput[idx]), psz_decoder_name);
+        else
+        {
+            msg_Dbg(va, "Can't get a decoder output format %s for decoder %s.", DxgiFormatToStr(processorInput[idx]), psz_decoder_name);
+            continue;
+        }
+
+       // check if we can create render texture of that format
+       // check the decoder can output to that format
+       if ( !DeviceSupportsFormat(sys->d3d_dev.d3ddevice, processorInput[idx],
+                                  D3D11_FORMAT_SUPPORT_SHADER_LOAD) )
+       {
+#ifndef ID3D11VideoContext_VideoProcessorBlt
+           msg_Dbg(va, "Format %s needs a processor but is not supported",
+                   DxgiFormatToStr(processorInput[idx]));
+#else
+           if ( !DeviceSupportsFormat(sys->d3d_dev.d3ddevice, processorInput[idx],
+                                      D3D11_FORMAT_SUPPORT_VIDEO_PROCESSOR_INPUT) )
+           {
+               msg_Dbg(va, "Format %s needs a processor but is not available",
+                       DxgiFormatToStr(processorInput[idx]));
+               continue;
+           }
+#endif
+        }
+
+        D3D11_VIDEO_DECODER_DESC decoderDesc;
+        ZeroMemory(&decoderDesc, sizeof(decoderDesc));
+        decoderDesc.Guid = *input;
+        decoderDesc.SampleWidth = fmt->i_width;
+        decoderDesc.SampleHeight = fmt->i_height;
+        decoderDesc.OutputFormat = processorInput[idx];
+
+        UINT cfg_count = 0;
+        hr = ID3D11VideoDevice_GetVideoDecoderConfigCount( dx_sys->d3ddec, &decoderDesc, &cfg_count );
+        if (FAILED(hr))
+        {
+            msg_Err( va, "Failed to get configuration for decoder %s. (hr=0x%lX)", psz_decoder_name, hr );
+            continue;
+        }
+        if (cfg_count == 0) {
+            msg_Err( va, "No decoder configuration possible for %s %dx%d",
+                     DxgiFormatToStr(decoderDesc.OutputFormat),
+                     decoderDesc.SampleWidth, decoderDesc.SampleHeight );
+            continue;
+        }
+
+        msg_Dbg(va, "Using output format %s for decoder %s", DxgiFormatToStr(processorInput[idx]), psz_decoder_name);
+        if ( sys->render == processorInput[idx] )
+        {
+            if (CanUseVoutPool(&sys->d3d_dev, sys->totalTextureSlices))
+                dx_sys->can_extern_pool = true;
+            else
+                msg_Warn( va, "use internal pool" );
+        }
+        sys->render = processorInput[idx];
+        free(psz_decoder_name);
+        return VLC_SUCCESS;
+    }
+    free(psz_decoder_name);
+
+    msg_Dbg(va, "Output format from picture source not supported.");
+    return VLC_EGENERIC;
+}
+
+static bool CanUseDecoderPadding(vlc_va_sys_t *sys)
+{
+    IDXGIAdapter *pAdapter = D3D11DeviceAdapter(sys->d3d_dev.d3ddevice);
+    if (!pAdapter)
+        return false;
+
+    DXGI_ADAPTER_DESC adapterDesc;
+    HRESULT hr = IDXGIAdapter_GetDesc(pAdapter, &adapterDesc);
+    IDXGIAdapter_Release(pAdapter);
+    if (FAILED(hr))
+        return false;
+
+    /* Qualcomm hardware has issues with textures and pixels that should not be
+    * part of the decoded area */
+    return adapterDesc.VendorId != GPU_MANUFACTURER_QUALCOMM;
+}
+
+/**
+ * It creates a Direct3D11 decoder using the given video format
+ */
+static int DxCreateDecoderSurfaces(vlc_va_t *va, int codec_id,
+                                   const video_format_t *fmt, unsigned surface_count)
+{
+    vlc_va_sys_t *sys = va->sys;
+    directx_sys_t *dx_sys = &va->sys->dx_sys;
+    HRESULT hr;
+
+    ID3D10Multithread *pMultithread;
+    hr = ID3D11Device_QueryInterface( sys->d3d_dev.d3ddevice, &IID_ID3D10Multithread, (void **)&pMultithread);
+    if (SUCCEEDED(hr)) {
+        ID3D10Multithread_SetMultithreadProtected(pMultithread, TRUE);
+        ID3D10Multithread_Release(pMultithread);
+    }
+
+    if (!sys->textureWidth || !sys->textureHeight)
+    {
+        sys->textureWidth  = fmt->i_width;
+        sys->textureHeight = fmt->i_height;
+    }
+
+    if ((sys->textureWidth != fmt->i_width || sys->textureHeight != fmt->i_height) &&
+        !CanUseDecoderPadding(sys))
+    {
+        msg_Dbg(va, "mismatching external pool sizes use the internal one %dx%d vs %dx%d",
+                sys->textureWidth, sys->textureHeight, fmt->i_width, fmt->i_height);
+        dx_sys->can_extern_pool = false;
+        sys->textureWidth  = fmt->i_width;
+        sys->textureHeight = fmt->i_height;
+    }
+    if (sys->totalTextureSlices && sys->totalTextureSlices < surface_count)
+    {
+        msg_Warn(va, "not enough decoding slices in the texture (%d/%d)",
+                 sys->totalTextureSlices, surface_count);
+        dx_sys->can_extern_pool = false;
+    }
+#if VLC_WINSTORE_APP
+    /* On the Xbox 1/S, any decoding of H264 with one dimension over 2304
+     * crashes totally the device */
+    if (codec_id == AV_CODEC_ID_H264 &&
+        (sys->textureWidth > 2304 || sys->textureHeight > 2304) &&
+        isXboxHardware(sys->d3d_dev.d3ddevice))
+    {
+        msg_Warn(va, "%dx%d resolution not supported by your hardware", fmt->i_width, fmt->i_height);
+        return VLC_EGENERIC;
+    }
+#endif
+
+    D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC viewDesc;
+    ZeroMemory(&viewDesc, sizeof(viewDesc));
+    viewDesc.DecodeProfile = dx_sys->input;
+    viewDesc.ViewDimension = D3D11_VDOV_DIMENSION_TEXTURE2D;
+
+    const d3d_format_t *textureFmt = NULL;
+    for (const d3d_format_t *output_format = GetRenderFormatList();
+         output_format->name != NULL; ++output_format)
+    {
+        if (output_format->formatTexture == sys->render &&
+                is_d3d11_opaque(output_format->fourcc))
+        {
+            textureFmt = output_format;
+            break;
+        }
+    }
+    if (unlikely(textureFmt==NULL))
+    {
+        msg_Dbg(va, "no hardware decoder matching %s", DxgiFormatToStr(sys->render));
+        return VLC_EGENERIC;
+    }
+
+    if (dx_sys->can_extern_pool)
+    {
+#if !D3D11_DIRECT_DECODE
+        size_t surface_idx;
+        for (surface_idx = 0; surface_idx < surface_count; surface_idx++) {
+            picture_t *pic = decoder_NewPicture( (decoder_t*) va->obj.parent );
+            sys->extern_pics[surface_idx] = pic;
+            dx_sys->hw_surface[surface_idx] = NULL;
+            if (pic==NULL)
+            {
+                msg_Warn(va, "not enough decoder pictures %d out of %d", surface_idx, surface_count);
+                dx_sys->can_extern_pool = false;
+                break;
+            }
+
+            D3D11_TEXTURE2D_DESC texDesc;
+            ID3D11Texture2D_GetDesc(pic->p_sys->texture[KNOWN_DXGI_INDEX], &texDesc);
+            assert(texDesc.Format == sys->render);
+            assert(texDesc.BindFlags & D3D11_BIND_DECODER);
+
+#if !LIBAVCODEC_VERSION_CHECK( 57, 27, 2, 61, 102 )
+            if (pic->p_sys->slice_index != surface_idx)
+            {
+                msg_Warn(va, "d3d11va requires decoding slices to be the first in the texture (%d/%d)",
+                         pic->p_sys->slice_index, surface_idx);
+                dx_sys->can_extern_pool = false;
+                break;
+            }
+#endif
+
+            viewDesc.Texture2D.ArraySlice = pic->p_sys->slice_index;
+            hr = ID3D11VideoDevice_CreateVideoDecoderOutputView( dx_sys->d3ddec,
+                                                                 pic->p_sys->resource[KNOWN_DXGI_INDEX],
+                                                                 &viewDesc,
+                                                                 &pic->p_sys->decoder );
+            if (FAILED(hr)) {
+                msg_Warn(va, "CreateVideoDecoderOutputView %d failed. (hr=0x%0lx)", surface_idx, hr);
+                dx_sys->can_extern_pool = false;
+                break;
+            }
+
+            AllocateShaderView(VLC_OBJECT(va), sys->d3d_dev.d3ddevice, textureFmt, pic->p_sys->texture, pic->p_sys->slice_index, pic->p_sys->resourceView);
+
+            dx_sys->hw_surface[surface_idx] = pic->p_sys->decoder;
+        }
+
+        if (!dx_sys->can_extern_pool)
+        {
+            for (size_t i = 0; i < surface_idx; ++i)
+            {
+                if (dx_sys->hw_surface[i])
+                {
+                    ID3D11VideoDecoderOutputView_Release(dx_sys->hw_surface[i]);
+                    dx_sys->hw_surface[i] = NULL;
+                }
+                if (sys->extern_pics[i])
+                {
+                    sys->extern_pics[i]->p_sys->decoder = NULL;
+                    picture_Release(sys->extern_pics[i]);
+                    sys->extern_pics[i] = NULL;
+                }
+            }
+        }
+        else
+#endif
+            msg_Dbg(va, "using external surface pool");
+    }
+
+    if (!dx_sys->can_extern_pool)
+    {
+        D3D11_TEXTURE2D_DESC texDesc;
+        ZeroMemory(&texDesc, sizeof(texDesc));
+        texDesc.Width = sys->textureWidth;
+        texDesc.Height = sys->textureHeight;
+        texDesc.MipLevels = 1;
+        texDesc.Format = sys->render;
+        texDesc.SampleDesc.Count = 1;
+        texDesc.MiscFlags = 0;
+        texDesc.ArraySize = surface_count;
+        texDesc.Usage = D3D11_USAGE_DEFAULT;
+        texDesc.BindFlags = D3D11_BIND_DECODER;
+        texDesc.CPUAccessFlags = 0;
+
+        if (DeviceSupportsFormat(sys->d3d_dev.d3ddevice, texDesc.Format, D3D11_FORMAT_SUPPORT_SHADER_LOAD))
+            texDesc.BindFlags |= D3D11_BIND_SHADER_RESOURCE;
+
+        ID3D11Texture2D *p_texture;
+        hr = ID3D11Device_CreateTexture2D( sys->d3d_dev.d3ddevice, &texDesc, NULL, &p_texture );
+        if (FAILED(hr)) {
+            msg_Err(va, "CreateTexture2D %d failed. (hr=0x%0lx)", surface_count, hr);
+            return VLC_EGENERIC;
+        }
+
+        unsigned surface_idx;
+        for (surface_idx = 0; surface_idx < surface_count; surface_idx++) {
+            sys->extern_pics[surface_idx] = NULL;
+            viewDesc.Texture2D.ArraySlice = surface_idx;
+
+            hr = ID3D11VideoDevice_CreateVideoDecoderOutputView( dx_sys->d3ddec,
+                                                                 (ID3D11Resource*) p_texture,
+                                                                 &viewDesc,
+                                                                 &dx_sys->hw_surface[surface_idx] );
+            if (FAILED(hr)) {
+                msg_Err(va, "CreateVideoDecoderOutputView %d failed. (hr=0x%0lx)", surface_idx, hr);
+                ID3D11Texture2D_Release(p_texture);
+                return VLC_EGENERIC;
+            }
+
+            if (texDesc.BindFlags & D3D11_BIND_SHADER_RESOURCE)
+            {
+                ID3D11Texture2D *textures[D3D11_MAX_SHADER_VIEW] = {p_texture, p_texture, p_texture};
+                AllocateShaderView(VLC_OBJECT(va), sys->d3d_dev.d3ddevice, textureFmt, textures, surface_idx,
+                                   &sys->resourceView[surface_idx * D3D11_MAX_SHADER_VIEW]);
+            }
+        }
+    }
+    msg_Dbg(va, "ID3D11VideoDecoderOutputView succeed with %d surfaces (%dx%d)",
+            surface_count, fmt->i_width, fmt->i_height);
+
+    D3D11_VIDEO_DECODER_DESC decoderDesc;
+    ZeroMemory(&decoderDesc, sizeof(decoderDesc));
+    decoderDesc.Guid = dx_sys->input;
+    decoderDesc.SampleWidth = fmt->i_width;
+    decoderDesc.SampleHeight = fmt->i_height;
+    decoderDesc.OutputFormat = sys->render;
+
+    UINT cfg_count;
+    hr = ID3D11VideoDevice_GetVideoDecoderConfigCount( dx_sys->d3ddec, &decoderDesc, &cfg_count );
+    if (FAILED(hr)) {
+        msg_Err(va, "GetVideoDecoderConfigCount failed. (hr=0x%lX)", hr);
+        return VLC_EGENERIC;
+    }
+
+    /* List all configurations available for the decoder */
+    D3D11_VIDEO_DECODER_CONFIG cfg_list[cfg_count];
+    for (unsigned i = 0; i < cfg_count; i++) {
+        hr = ID3D11VideoDevice_GetVideoDecoderConfig( dx_sys->d3ddec, &decoderDesc, i, &cfg_list[i] );
+        if (FAILED(hr)) {
+            msg_Err(va, "GetVideoDecoderConfig failed. (hr=0x%lX)", hr);
+            return VLC_EGENERIC;
+        }
+    }
+
+    msg_Dbg(va, "we got %d decoder configurations", cfg_count);
+
+    /* Select the best decoder configuration */
+    int cfg_score = 0;
+    for (unsigned i = 0; i < cfg_count; i++) {
+        const D3D11_VIDEO_DECODER_CONFIG *cfg = &cfg_list[i];
+
+        /* */
+        msg_Dbg(va, "configuration[%d] ConfigBitstreamRaw %d",
+                i, cfg->ConfigBitstreamRaw);
+
+        /* */
+        int score;
+        if (cfg->ConfigBitstreamRaw == 1)
+            score = 1;
+        else if (codec_id == AV_CODEC_ID_H264 && cfg->ConfigBitstreamRaw == 2)
+            score = 2;
+        else
+            continue;
+        if (IsEqualGUID(&cfg->guidConfigBitstreamEncryption, &DXVA2_NoEncrypt))
+            score += 16;
+
+        if (cfg_score < score) {
+            sys->cfg = *cfg;
+            cfg_score = score;
+        }
+    }
+    if (cfg_score <= 0) {
+        msg_Err(va, "Failed to find a supported decoder configuration");
+        return VLC_EGENERIC;
+    }
+
+    /* Create the decoder */
+    ID3D11VideoDecoder *decoder;
+    hr = ID3D11VideoDevice_CreateVideoDecoder( dx_sys->d3ddec, &decoderDesc, &sys->cfg, &decoder );
+    if (FAILED(hr)) {
+        msg_Err(va, "ID3D11VideoDevice_CreateVideoDecoder failed. (hr=0x%lX)", hr);
+        dx_sys->decoder = NULL;
+        return VLC_EGENERIC;
+    }
+    dx_sys->decoder = decoder;
+
+    msg_Dbg(va, "DxCreateDecoderSurfaces succeed");
+    return VLC_SUCCESS;
+}
+
+static void DxDestroySurfaces(vlc_va_t *va)
+{
+    directx_sys_t *dx_sys = &va->sys->dx_sys;
+    if (dx_sys->va_pool.surface_count && !dx_sys->can_extern_pool) {
+        ID3D11Resource *p_texture;
+        ID3D11VideoDecoderOutputView_GetResource( dx_sys->hw_surface[0], &p_texture );
+        ID3D11Resource_Release(p_texture);
+        ID3D11Resource_Release(p_texture);
+    }
+    for (unsigned i = 0; i < dx_sys->va_pool.surface_count; i++)
+    {
+        ID3D11VideoDecoderOutputView_Release( dx_sys->hw_surface[i] );
+        for (int j = 0; j < D3D11_MAX_SHADER_VIEW; j++)
+        {
+            if (va->sys->resourceView[i*D3D11_MAX_SHADER_VIEW + j])
+                ID3D11ShaderResourceView_Release(va->sys->resourceView[i*D3D11_MAX_SHADER_VIEW + j]);
+        }
+    }
+    if (dx_sys->decoder)
+    {
+        ID3D11VideoDecoder_Release(dx_sys->decoder);
+        dx_sys->decoder = NULL;
+    }
+}
diff --git modules/codec/avcodec/directx_va.c modules/codec/avcodec/directx_va.c
new file mode 100644
index 000000000..91f44e0a9
--- /dev/null
+++ modules/codec/avcodec/directx_va.c
@@ -0,0 +1,485 @@
+/*****************************************************************************
+ * directx_va.c: DirectX Generic Video Acceleration helpers
+ *****************************************************************************
+ * Copyright (C) 2009 Geoffroy Couprie
+ * Copyright (C) 2009 Laurent Aimar
+ * Copyright (C) 2015 Steve Lhomme
+ * $Id$
+ *
+ * Authors: Geoffroy Couprie <geal@videolan.org>
+ *          Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *          Steve Lhomme <robux4@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <assert.h>
+
+#include <vlc_common.h>
+#include <vlc_codecs.h>
+#include <vlc_codec.h>
+
+#define COBJMACROS
+
+#define D3D_DecoderType     IUnknown
+#define D3D_DecoderDevice   IUnknown
+#define D3D_DecoderSurface  IUnknown
+typedef struct
+{
+    void *dummy;
+} picture_sys_t;
+#include "directx_va.h"
+
+#include "avcodec.h"
+#include "../../packetizer/h264_nal.h"
+#include "../../packetizer/hevc_nal.h"
+
+static const int PROF_MPEG2_SIMPLE[] = { FF_PROFILE_MPEG2_SIMPLE, 0 };
+static const int PROF_MPEG2_MAIN[]   = { FF_PROFILE_MPEG2_SIMPLE,
+                                         FF_PROFILE_MPEG2_MAIN, 0 };
+static const int PROF_H264_HIGH[]    = { FF_PROFILE_H264_BASELINE,
+                                         FF_PROFILE_H264_CONSTRAINED_BASELINE,
+                                         FF_PROFILE_H264_MAIN,
+                                         FF_PROFILE_H264_HIGH, 0 };
+static const int PROF_HEVC_MAIN[]    = { FF_PROFILE_HEVC_MAIN, 0 };
+static const int PROF_HEVC_MAIN10[]  = { FF_PROFILE_HEVC_MAIN,
+                                         FF_PROFILE_HEVC_MAIN_10, 0 };
+
+static const int PROF_VP9_MAIN[]    = { FF_PROFILE_VP9_0, 0 };
+static const int PROF_VP9_10[]      = { FF_PROFILE_VP9_2, 0 };
+
+#include <winapifamily.h>
+#if defined(WINAPI_FAMILY)
+# undef WINAPI_FAMILY
+#endif
+#define WINAPI_FAMILY WINAPI_PARTITION_DESKTOP
+
+#include <d3d9.h>
+#include <dxva2api.h>
+
+#include <initguid.h> /* must be last included to not redefine existing GUIDs */
+
+/* dxva2api.h GUIDs: http://msdn.microsoft.com/en-us/library/windows/desktop/ms697067(v=vs100).aspx
+ * assume that they are declared in dxva2api.h */
+#define MS_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)
+
+#ifdef __MINGW32__
+# include <_mingw.h>
+
+# if !defined(__MINGW64_VERSION_MAJOR)
+#  undef MS_GUID
+#  define MS_GUID DEFINE_GUID /* dxva2api.h fails to declare those, redefine as static */
+#  define DXVA2_E_NEW_VIDEO_DEVICE MAKE_HRESULT(1, 4, 4097)
+# else
+#  include <dxva.h>
+# endif
+
+#endif /* __MINGW32__ */
+
+/* Codec capabilities GUID, sorted by codec */
+MS_GUID    (DXVA2_ModeMPEG2_MoComp,                 0xe6a9f44b, 0x61b0, 0x4563, 0x9e, 0xa4, 0x63, 0xd2, 0xa3, 0xc6, 0xfe, 0x66);
+MS_GUID    (DXVA2_ModeMPEG2_IDCT,                   0xbf22ad00, 0x03ea, 0x4690, 0x80, 0x77, 0x47, 0x33, 0x46, 0x20, 0x9b, 0x7e);
+MS_GUID    (DXVA2_ModeMPEG2_VLD,                    0xee27417f, 0x5e28, 0x4e65, 0xbe, 0xea, 0x1d, 0x26, 0xb5, 0x08, 0xad, 0xc9);
+DEFINE_GUID(DXVA_ModeMPEG1_A,                       0x1b81be09, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA_ModeMPEG2_A,                       0x1b81be0A, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA_ModeMPEG2_B,                       0x1b81be0B, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA_ModeMPEG2_C,                       0x1b81be0C, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA_ModeMPEG2_D,                       0x1b81be0D, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA2_ModeMPEG2and1_VLD,                0x86695f12, 0x340e, 0x4f04, 0x9f, 0xd3, 0x92, 0x53, 0xdd, 0x32, 0x74, 0x60);
+DEFINE_GUID(DXVA2_ModeMPEG1_VLD,                    0x6f3ec719, 0x3735, 0x42cc, 0x80, 0x63, 0x65, 0xcc, 0x3c, 0xb3, 0x66, 0x16);
+
+MS_GUID    (DXVA2_ModeH264_A,                       0x1b81be64, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+MS_GUID    (DXVA2_ModeH264_B,                       0x1b81be65, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+MS_GUID    (DXVA2_ModeH264_C,                       0x1b81be66, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+MS_GUID    (DXVA2_ModeH264_D,                       0x1b81be67, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+MS_GUID    (DXVA2_ModeH264_E,                       0x1b81be68, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+MS_GUID    (DXVA2_ModeH264_F,                       0x1b81be69, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA_ModeH264_VLD_Multiview,            0x9901CCD3, 0xca12, 0x4b7e, 0x86, 0x7a, 0xe2, 0x22, 0x3d, 0x92, 0x55, 0xc3); // MVC
+DEFINE_GUID(DXVA_ModeH264_VLD_WithFMOASO_NoFGT,     0xd5f04ff9, 0x3418, 0x45d8, 0x95, 0x61, 0x32, 0xa7, 0x6a, 0xae, 0x2d, 0xdd);
+DEFINE_GUID(DXVADDI_Intel_ModeH264_A,               0x604F8E64, 0x4951, 0x4c54, 0x88, 0xFE, 0xAB, 0xD2, 0x5C, 0x15, 0xB3, 0xD6);
+DEFINE_GUID(DXVADDI_Intel_ModeH264_C,               0x604F8E66, 0x4951, 0x4c54, 0x88, 0xFE, 0xAB, 0xD2, 0x5C, 0x15, 0xB3, 0xD6);
+DEFINE_GUID(DXVA_Intel_H264_NoFGT_ClearVideo,       0x604F8E68, 0x4951, 0x4c54, 0x88, 0xFE, 0xAB, 0xD2, 0x5C, 0x15, 0xB3, 0xD6);
+DEFINE_GUID(DXVA_ModeH264_VLD_NoFGT_Flash,          0x4245F676, 0x2BBC, 0x4166, 0xa0, 0xBB, 0x54, 0xE7, 0xB8, 0x49, 0xC3, 0x80);
+
+MS_GUID    (DXVA2_ModeWMV8_A,                       0x1b81be80, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+MS_GUID    (DXVA2_ModeWMV8_B,                       0x1b81be81, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+
+MS_GUID    (DXVA2_ModeWMV9_A,                       0x1b81be90, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+MS_GUID    (DXVA2_ModeWMV9_B,                       0x1b81be91, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+MS_GUID    (DXVA2_ModeWMV9_C,                       0x1b81be94, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+
+MS_GUID    (DXVA2_ModeVC1_A,                        0x1b81beA0, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+MS_GUID    (DXVA2_ModeVC1_B,                        0x1b81beA1, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+MS_GUID    (DXVA2_ModeVC1_C,                        0x1b81beA2, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+MS_GUID    (DXVA2_ModeVC1_D,                        0x1b81beA3, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA2_ModeVC1_D2010,                    0x1b81beA4, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5); // August 2010 update
+DEFINE_GUID(DXVA_Intel_VC1_ClearVideo,              0xBCC5DB6D, 0xA2B6, 0x4AF0, 0xAC, 0xE4, 0xAD, 0xB1, 0xF7, 0x87, 0xBC, 0x89);
+DEFINE_GUID(DXVA_Intel_VC1_ClearVideo_2,            0xE07EC519, 0xE651, 0x4CD6, 0xAC, 0x84, 0x13, 0x70, 0xCC, 0xEE, 0xC8, 0x51);
+
+DEFINE_GUID(DXVA_nVidia_MPEG4_ASP,                  0x9947EC6F, 0x689B, 0x11DC, 0xA3, 0x20, 0x00, 0x19, 0xDB, 0xBC, 0x41, 0x84);
+DEFINE_GUID(DXVA_ModeMPEG4pt2_VLD_Simple,           0xefd64d74, 0xc9e8, 0x41d7, 0xa5, 0xe9, 0xe9, 0xb0, 0xe3, 0x9f, 0xa3, 0x19);
+DEFINE_GUID(DXVA_ModeMPEG4pt2_VLD_AdvSimple_NoGMC,  0xed418a9f, 0x010d, 0x4eda, 0x9a, 0xe3, 0x9a, 0x65, 0x35, 0x8d, 0x8d, 0x2e);
+DEFINE_GUID(DXVA_ModeMPEG4pt2_VLD_AdvSimple_GMC,    0xab998b5b, 0x4258, 0x44a9, 0x9f, 0xeb, 0x94, 0xe5, 0x97, 0xa6, 0xba, 0xae);
+DEFINE_GUID(DXVA_ModeMPEG4pt2_VLD_AdvSimple_Avivo,  0x7C74ADC6, 0xe2ba, 0x4ade, 0x86, 0xde, 0x30, 0xbe, 0xab, 0xb4, 0x0c, 0xc1);
+
+DEFINE_GUID(DXVA_ModeHEVC_VLD_Main,                 0x5b11d51b, 0x2f4c, 0x4452,0xbc,0xc3,0x09,0xf2,0xa1,0x16,0x0c,0xc0);
+DEFINE_GUID(DXVA_ModeHEVC_VLD_Main10,               0x107af0e0, 0xef1a, 0x4d19,0xab,0xa8,0x67,0xa1,0x63,0x07,0x3d,0x13);
+
+DEFINE_GUID(DXVA_ModeH264_VLD_Stereo_Progressive_NoFGT,     0xd79be8da, 0x0cf1, 0x4c81,0xb8,0x2a,0x69,0xa4,0xe2,0x36,0xf4,0x3d);
+DEFINE_GUID(DXVA_ModeH264_VLD_Stereo_NoFGT,                 0xf9aaccbb, 0xc2b6, 0x4cfc,0x87,0x79,0x57,0x07,0xb1,0x76,0x05,0x52);
+DEFINE_GUID(DXVA_ModeH264_VLD_Multiview_NoFGT,              0x705b9d82, 0x76cf, 0x49d6,0xb7,0xe6,0xac,0x88,0x72,0xdb,0x01,0x3c);
+
+DEFINE_GUID(DXVA_ModeH264_VLD_SVC_Scalable_Baseline,                    0xc30700c4, 0xe384, 0x43e0, 0xb9, 0x82, 0x2d, 0x89, 0xee, 0x7f, 0x77, 0xc4);
+DEFINE_GUID(DXVA_ModeH264_VLD_SVC_Restricted_Scalable_Baseline,         0x9b8175d4, 0xd670, 0x4cf2, 0xa9, 0xf0, 0xfa, 0x56, 0xdf, 0x71, 0xa1, 0xae);
+DEFINE_GUID(DXVA_ModeH264_VLD_SVC_Scalable_High,                        0x728012c9, 0x66a8, 0x422f, 0x97, 0xe9, 0xb5, 0xe3, 0x9b, 0x51, 0xc0, 0x53);
+DEFINE_GUID(DXVA_ModeH264_VLD_SVC_Restricted_Scalable_High_Progressive, 0x8efa5926, 0xbd9e, 0x4b04, 0x8b, 0x72, 0x8f, 0x97, 0x7d, 0xc4, 0x4c, 0x36);
+
+DEFINE_GUID(DXVA_ModeH261_A,                        0x1b81be01, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA_ModeH261_B,                        0x1b81be02, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+
+DEFINE_GUID(DXVA_ModeH263_A,                        0x1b81be03, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA_ModeH263_B,                        0x1b81be04, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA_ModeH263_C,                        0x1b81be05, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA_ModeH263_D,                        0x1b81be06, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA_ModeH263_E,                        0x1b81be07, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+DEFINE_GUID(DXVA_ModeH263_F,                        0x1b81be08, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
+
+DEFINE_GUID(DXVA_ModeVP8_VLD,                       0x90b899ea, 0x3a62, 0x4705, 0x88, 0xb3, 0x8d, 0xf0, 0x4b, 0x27, 0x44, 0xe7);
+DEFINE_GUID(DXVA_ModeVP9_VLD_Profile0,              0x463707f8, 0xa1d0, 0x4585, 0x87, 0x6d, 0x83, 0xaa, 0x6d, 0x60, 0xb8, 0x9e);
+DEFINE_GUID(DXVA_ModeVP9_VLD_10bit_Profile2,        0xa4c749ef, 0x6ecf, 0x48aa, 0x84, 0x48, 0x50, 0xa7, 0xa1, 0x16, 0x5f, 0xf7);
+DEFINE_GUID(DXVA_ModeVP9_VLD_Intel,                 0x76988a52, 0xdf13, 0x419a, 0x8e, 0x64, 0xff, 0xcf, 0x4a, 0x33, 0x6c, 0xf5);
+
+typedef struct {
+    const char   *name;
+    const GUID   *guid;
+    enum AVCodecID codec;
+    const int    *p_profiles; // NULL or ends with 0
+} directx_va_mode_t;
+
+/* XXX Prefered modes must come first */
+static const directx_va_mode_t DXVA_MODES[] = {
+    /* MPEG-1/2 */
+    { "MPEG-1 decoder, restricted profile A",                                         &DXVA_ModeMPEG1_A,                      0, NULL },
+    { "MPEG-2 decoder, restricted profile A",                                         &DXVA_ModeMPEG2_A,                      0, NULL },
+    { "MPEG-2 decoder, restricted profile B",                                         &DXVA_ModeMPEG2_B,                      0, NULL },
+    { "MPEG-2 decoder, restricted profile C",                                         &DXVA_ModeMPEG2_C,                      0, NULL },
+    { "MPEG-2 decoder, restricted profile D",                                         &DXVA_ModeMPEG2_D,                      0, NULL },
+
+    { "MPEG-2 variable-length decoder",                                               &DXVA2_ModeMPEG2_VLD,                   AV_CODEC_ID_MPEG2VIDEO, PROF_MPEG2_SIMPLE },
+    { "MPEG-2 & MPEG-1 variable-length decoder",                                      &DXVA2_ModeMPEG2and1_VLD,               AV_CODEC_ID_MPEG2VIDEO, PROF_MPEG2_MAIN },
+    { "MPEG-2 & MPEG-1 variable-length decoder",                                      &DXVA2_ModeMPEG2and1_VLD,               AV_CODEC_ID_MPEG1VIDEO, NULL },
+    { "MPEG-2 motion compensation",                                                   &DXVA2_ModeMPEG2_MoComp,                0, NULL },
+    { "MPEG-2 inverse discrete cosine transform",                                     &DXVA2_ModeMPEG2_IDCT,                  0, NULL },
+
+    /* MPEG-1 http://download.microsoft.com/download/B/1/7/B172A3C8-56F2-4210-80F1-A97BEA9182ED/DXVA_MPEG1_VLD.pdf */
+    { "MPEG-1 variable-length decoder, no D pictures",                                &DXVA2_ModeMPEG1_VLD,                   0, NULL },
+
+    /* H.264 http://www.microsoft.com/downloads/details.aspx?displaylang=en&FamilyID=3d1c290b-310b-4ea2-bf76-714063a6d7a6 */
+    { "H.264 variable-length decoder, film grain technology",                         &DXVA2_ModeH264_F,                      AV_CODEC_ID_H264, PROF_H264_HIGH },
+    { "H.264 variable-length decoder, no film grain technology",                      &DXVA2_ModeH264_E,                      AV_CODEC_ID_H264, PROF_H264_HIGH },
+    { "H.264 variable-length decoder, no film grain technology (Intel ClearVideo)",   &DXVA_Intel_H264_NoFGT_ClearVideo,      AV_CODEC_ID_H264, PROF_H264_HIGH },
+    { "H.264 variable-length decoder, no film grain technology, FMO/ASO",             &DXVA_ModeH264_VLD_WithFMOASO_NoFGT,    AV_CODEC_ID_H264, PROF_H264_HIGH },
+    { "H.264 variable-length decoder, no film grain technology, Flash",               &DXVA_ModeH264_VLD_NoFGT_Flash,         AV_CODEC_ID_H264, PROF_H264_HIGH },
+
+    { "H.264 inverse discrete cosine transform, film grain technology",               &DXVA2_ModeH264_D,                      0, NULL },
+    { "H.264 inverse discrete cosine transform, no film grain technology",            &DXVA2_ModeH264_C,                      0, NULL },
+    { "H.264 inverse discrete cosine transform, no film grain technology (Intel)",    &DXVADDI_Intel_ModeH264_C,              0, NULL },
+
+    { "H.264 motion compensation, film grain technology",                             &DXVA2_ModeH264_B,                      0, NULL },
+    { "H.264 motion compensation, no film grain technology",                          &DXVA2_ModeH264_A,                      0, NULL },
+    { "H.264 motion compensation, no film grain technology (Intel)",                  &DXVADDI_Intel_ModeH264_A,              0, NULL },
+
+    /* http://download.microsoft.com/download/2/D/0/2D02E72E-7890-430F-BA91-4A363F72F8C8/DXVA_H264_MVC.pdf */
+    { "H.264 stereo high profile, mbs flag set",                                      &DXVA_ModeH264_VLD_Stereo_Progressive_NoFGT, 0, NULL },
+    { "H.264 stereo high profile",                                                    &DXVA_ModeH264_VLD_Stereo_NoFGT,             0, NULL },
+    { "H.264 multiview high profile",                                                 &DXVA_ModeH264_VLD_Multiview_NoFGT,          0, NULL },
+
+    /* SVC http://download.microsoft.com/download/C/8/A/C8AD9F1B-57D1-4C10-85A0-09E3EAC50322/DXVA_SVC_2012_06.pdf */
+    { "H.264 scalable video coding, Scalable Baseline Profile",                       &DXVA_ModeH264_VLD_SVC_Scalable_Baseline,            0, NULL },
+    { "H.264 scalable video coding, Scalable Constrained Baseline Profile",           &DXVA_ModeH264_VLD_SVC_Restricted_Scalable_Baseline, 0, NULL },
+    { "H.264 scalable video coding, Scalable High Profile",                           &DXVA_ModeH264_VLD_SVC_Scalable_High,                0, NULL },
+    { "H.264 scalable video coding, Scalable Constrained High Profile",               &DXVA_ModeH264_VLD_SVC_Restricted_Scalable_High_Progressive, 0, NULL },
+
+    /* WMV */
+    { "Windows Media Video 8 motion compensation",                                    &DXVA2_ModeWMV8_B,                      0, NULL },
+    { "Windows Media Video 8 post processing",                                        &DXVA2_ModeWMV8_A,                      0, NULL },
+
+    { "Windows Media Video 9 IDCT",                                                   &DXVA2_ModeWMV9_C,                      0, NULL },
+    { "Windows Media Video 9 motion compensation",                                    &DXVA2_ModeWMV9_B,                      0, NULL },
+    { "Windows Media Video 9 post processing",                                        &DXVA2_ModeWMV9_A,                      0, NULL },
+
+    /* VC-1 */
+    { "VC-1 variable-length decoder",                                                 &DXVA2_ModeVC1_D,                       AV_CODEC_ID_VC1, NULL },
+    { "VC-1 variable-length decoder",                                                 &DXVA2_ModeVC1_D,                       AV_CODEC_ID_WMV3, NULL },
+    { "VC-1 variable-length decoder",                                                 &DXVA2_ModeVC1_D2010,                   AV_CODEC_ID_VC1, NULL },
+    { "VC-1 variable-length decoder",                                                 &DXVA2_ModeVC1_D2010,                   AV_CODEC_ID_WMV3, NULL },
+    { "VC-1 variable-length decoder 2 (Intel)",                                       &DXVA_Intel_VC1_ClearVideo_2,           0, NULL },
+    { "VC-1 variable-length decoder (Intel)",                                         &DXVA_Intel_VC1_ClearVideo,             0, NULL },
+
+    { "VC-1 inverse discrete cosine transform",                                       &DXVA2_ModeVC1_C,                       0, NULL },
+    { "VC-1 motion compensation",                                                     &DXVA2_ModeVC1_B,                       0, NULL },
+    { "VC-1 post processing",                                                         &DXVA2_ModeVC1_A,                       0, NULL },
+
+    /* Xvid/Divx: TODO */
+    { "MPEG-4 Part 2 nVidia bitstream decoder",                                       &DXVA_nVidia_MPEG4_ASP,                 0, NULL },
+    { "MPEG-4 Part 2 variable-length decoder, Simple Profile",                        &DXVA_ModeMPEG4pt2_VLD_Simple,          0, NULL },
+    { "MPEG-4 Part 2 variable-length decoder, Simple&Advanced Profile, no GMC",       &DXVA_ModeMPEG4pt2_VLD_AdvSimple_NoGMC, 0, NULL },
+    { "MPEG-4 Part 2 variable-length decoder, Simple&Advanced Profile, GMC",          &DXVA_ModeMPEG4pt2_VLD_AdvSimple_GMC,   0, NULL },
+    { "MPEG-4 Part 2 variable-length decoder, Simple&Advanced Profile, Avivo",        &DXVA_ModeMPEG4pt2_VLD_AdvSimple_Avivo, 0, NULL },
+
+    /* HEVC */
+    { "HEVC Main profile",                                                            &DXVA_ModeHEVC_VLD_Main,                AV_CODEC_ID_HEVC, PROF_HEVC_MAIN },
+    { "HEVC Main 10 profile",                                                         &DXVA_ModeHEVC_VLD_Main10,              AV_CODEC_ID_HEVC, PROF_HEVC_MAIN10 },
+
+    /* H.261 */
+    { "H.261 decoder, restricted profile A",                                          &DXVA_ModeH261_A,                       0, NULL },
+    { "H.261 decoder, restricted profile B",                                          &DXVA_ModeH261_B,                       0, NULL },
+
+    /* H.263 */
+    { "H.263 decoder, restricted profile A",                                          &DXVA_ModeH263_A,                       0, NULL },
+    { "H.263 decoder, restricted profile B",                                          &DXVA_ModeH263_B,                       0, NULL },
+    { "H.263 decoder, restricted profile C",                                          &DXVA_ModeH263_C,                       0, NULL },
+    { "H.263 decoder, restricted profile D",                                          &DXVA_ModeH263_D,                       0, NULL },
+    { "H.263 decoder, restricted profile E",                                          &DXVA_ModeH263_E,                       0, NULL },
+    { "H.263 decoder, restricted profile F",                                          &DXVA_ModeH263_F,                       0, NULL },
+
+    /* VPx */
+    { "VP8",                                                                          &DXVA_ModeVP8_VLD,                      0, NULL },
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 57, 17, 100 ) && LIBAVCODEC_VERSION_MICRO >= 100
+    { "VP9 profile 0",                                                                &DXVA_ModeVP9_VLD_Profile0,             AV_CODEC_ID_VP9, PROF_VP9_MAIN },
+    { "VP9 profile 2",                                                                &DXVA_ModeVP9_VLD_10bit_Profile2,       AV_CODEC_ID_VP9, PROF_VP9_10 },
+#else
+    { "VP9 profile 0",                                                                &DXVA_ModeVP9_VLD_Profile0,             0, NULL },
+    { "VP9 profile 2",                                                                &DXVA_ModeVP9_VLD_10bit_Profile2,       0, NULL },
+#endif
+    { "VP9 profile Intel",                                                            &DXVA_ModeVP9_VLD_Intel,                0, NULL },
+
+    { NULL, NULL, 0, NULL }
+};
+
+static int FindVideoServiceConversion(vlc_va_t *, directx_sys_t *, const es_format_t *, const AVCodecContext *);
+
+char *directx_va_GetDecoderName(const GUID *guid)
+{
+    for (unsigned i = 0; DXVA_MODES[i].name; i++) {
+        if (IsEqualGUID(DXVA_MODES[i].guid, guid))
+            return strdup(DXVA_MODES[i].name);
+    }
+
+    char *psz_name;
+    if (asprintf(&psz_name, "Unknown decoder " GUID_FMT, GUID_PRINT(*guid)) < 0)
+        return NULL;
+    return psz_name;
+}
+
+/* */
+int directx_va_Setup(vlc_va_t *va, directx_sys_t *dx_sys, const AVCodecContext *avctx,
+                     const es_format_t *fmt, int flag_xbox)
+{
+    /* */
+    if (FindVideoServiceConversion(va, dx_sys, fmt, avctx)) {
+        msg_Err(va, "FindVideoServiceConversion failed");
+        return VLC_EGENERIC;
+    }
+
+    int surface_alignment = 16;
+    unsigned surface_count = 2;
+
+    switch ( avctx->codec_id )
+    {
+    case AV_CODEC_ID_MPEG2VIDEO:
+        /* decoding MPEG-2 requires additional alignment on some Intel GPUs,
+           but it causes issues for H.264 on certain AMD GPUs..... */
+        surface_alignment = 32;
+        surface_count += 2 + 2; /* 2 for deinterlacing which can hold up to 2
+                                 * pictures from the decoder for smoothing */
+        break;
+    case AV_CODEC_ID_HEVC:
+        /* the HEVC DXVA2 spec asks for 128 pixel aligned surfaces to ensure
+           all coding features have enough room to work with */
+           /* On the Xbox 1/S, the decoder cannot do 4K aligned to 128 but is OK with 64 */
+        if (flag_xbox)
+            surface_alignment = 16;
+        else
+            surface_alignment = 128;
+        surface_count += 16;
+        break;
+    case AV_CODEC_ID_H264:
+        surface_count += 16;
+        break;
+    case AV_CODEC_ID_VP9:
+        surface_count += 4;
+        break;
+    default:
+        surface_count += 2;
+    }
+
+    if ( avctx->active_thread_type & FF_THREAD_FRAME )
+        surface_count += avctx->thread_count;
+
+    int err = va_pool_SetupDecoder(va, &dx_sys->va_pool, avctx, surface_count, surface_alignment);
+    if (err != VLC_SUCCESS)
+        return err;
+    if (dx_sys->can_extern_pool)
+        return VLC_SUCCESS;
+    return va_pool_SetupSurfaces(va, &dx_sys->va_pool, surface_count);
+}
+
+void directx_va_Close(vlc_va_t *va, directx_sys_t *dx_sys)
+{
+    va_pool_Close(va, &dx_sys->va_pool);
+}
+
+int directx_va_Open(vlc_va_t *va, directx_sys_t *dx_sys)
+{
+    if (va_pool_Open(va, &dx_sys->va_pool) != VLC_SUCCESS)
+        goto error;
+
+    return VLC_SUCCESS;
+
+error:
+    return VLC_EGENERIC;
+}
+
+static bool profile_supported(const directx_va_mode_t *mode, const es_format_t *fmt,
+                              const AVCodecContext *avctx)
+{
+    bool is_supported = mode->p_profiles == NULL;
+    if (!is_supported)
+    {
+        int profile = fmt->i_profile >= 0 ? fmt->i_profile : avctx->profile;
+        if (mode->codec == AV_CODEC_ID_H264)
+        {
+            uint8_t h264_profile;
+            if ( h264_get_profile_level(fmt, &h264_profile, NULL, NULL) )
+                profile = h264_profile;
+        }
+        if (mode->codec == AV_CODEC_ID_HEVC)
+        {
+            uint8_t hevc_profile;
+            if (hevc_get_profile_level(fmt, &hevc_profile, NULL, NULL) )
+                profile = hevc_profile;
+        }
+
+        if (profile <= 0)
+            is_supported = true;
+        else for (const int *p_profile = &mode->p_profiles[0]; *p_profile; ++p_profile)
+        {
+            if (*p_profile == profile)
+            {
+                is_supported = true;
+                break;
+            }
+        }
+    }
+    return is_supported;
+}
+
+/**
+ * Find the best suited decoder mode GUID and render format.
+ */
+static int FindVideoServiceConversion(vlc_va_t *va, directx_sys_t *dx_sys,
+                                      const es_format_t *fmt, const AVCodecContext *avctx)
+{
+    input_list_t p_list = { 0 };
+    int err = dx_sys->pf_get_input_list(va, &p_list);
+    if (err != VLC_SUCCESS)
+        return err;
+    if (p_list.count == 0) {
+        msg_Warn( va, "No input format found for HWAccel" );
+        return VLC_EGENERIC;
+    }
+
+    err = VLC_EGENERIC;
+    /* Retreive supported modes from the decoder service */
+    for (unsigned i = 0; i < p_list.count; i++) {
+        const GUID *g = &p_list.list[i];
+        char *psz_decoder_name = directx_va_GetDecoderName(g);
+        msg_Dbg(va, "- '%s' is supported", psz_decoder_name);
+        free(psz_decoder_name);
+    }
+
+    /* Try all supported mode by our priority */
+    const directx_va_mode_t *mode = DXVA_MODES;
+    for (; mode->name; ++mode) {
+        if (!mode->codec || mode->codec != avctx->codec_id)
+            continue;
+
+        /* */
+        bool is_supported = false;
+        for (const GUID *g = &p_list.list[0]; !is_supported && g < &p_list.list[p_list.count]; g++) {
+            is_supported = IsEqualGUID(mode->guid, g);
+        }
+        if ( is_supported )
+        {
+            is_supported = profile_supported( mode, fmt, avctx );
+            if (!is_supported)
+            {
+                char *psz_name = directx_va_GetDecoderName(mode->guid);
+                msg_Warn( va, "Unsupported profile %d for %s ",
+                          fmt->i_profile, psz_name );
+                free( psz_name );
+            }
+        }
+        if (!is_supported)
+            continue;
+
+        /* */
+        msg_Dbg(va, "Trying to use '%s' as input", mode->name);
+        if (dx_sys->pf_setup_output(va, mode->guid, &fmt->video)==VLC_SUCCESS)
+        {
+            dx_sys->input = *mode->guid;
+            err = VLC_SUCCESS;
+            break;
+        }
+    }
+
+    p_list.pf_release(&p_list);
+    return err;
+}
+
+static UINT hevc_blacklist[] = {
+    /* Intel Broadwell GPUs with hybrid HEVC */
+    0x1606, /* HD Graphics */
+    0x160E, /* HD Graphics */
+    0x1612, /* HD Graphics 5600 */
+    0x1616, /* HD Graphics 5500 */
+    0x161A, /* HD Graphics P5700 */
+    0x161E, /* HD Graphics 5300 */
+    0x1622, /* Iris Pro Graphics 6200 */
+    0x1626, /* HD Graphics 6000 */
+    0x162A, /* Iris Pro Graphics P6300 */
+    0x162B, /* Iris Graphics 6100 */
+};
+
+bool directx_va_canUseHevc(vlc_va_t *va, UINT DeviceId)
+{
+    if (va->obj.force)
+        return true;
+
+    for (size_t i=0; i<ARRAY_SIZE(hevc_blacklist); i++)
+    {
+        if (hevc_blacklist[i] == DeviceId)
+        {
+            msg_Warn(va, "Intel Hybrid HEVC detected, disabling hardware decoding");
+            return false;
+        }
+    }
+
+    return true;
+}
diff --git modules/codec/avcodec/directx_va.h modules/codec/avcodec/directx_va.h
new file mode 100644
index 000000000..74c744353
--- /dev/null
+++ modules/codec/avcodec/directx_va.h
@@ -0,0 +1,87 @@
+/*****************************************************************************
+ * directx_va.h: DirectX Generic Video Acceleration helpers
+ *****************************************************************************
+ * Copyright (C) 2009 Geoffroy Couprie
+ * Copyright (C) 2009 Laurent Aimar
+ * Copyright (C) 2015 Steve Lhomme
+ * $Id$
+ *
+ * Authors: Geoffroy Couprie <geal@videolan.org>
+ *          Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *          Steve Lhomme <robux4@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef AVCODEC_DIRECTX_VA_H
+#define AVCODEC_DIRECTX_VA_H
+
+# if _WIN32_WINNT < _WIN32_WINNT_VISTA
+/* d3d11 needs Vista support */
+#  undef _WIN32_WINNT
+#  define _WIN32_WINNT _WIN32_WINNT_VISTA
+# endif
+
+#include <vlc_common.h>
+
+#include <libavcodec/avcodec.h>
+#include "va.h"
+
+#include <unknwn.h>
+#include <stdatomic.h>
+
+#include "va_surface_internal.h"
+
+typedef struct input_list_t {
+    void (*pf_release)(struct input_list_t *);
+    GUID *list;
+    unsigned count;
+} input_list_t;
+
+#define MAX_SURFACE_COUNT (64)
+typedef struct
+{
+    va_pool_t             va_pool;
+    bool                  can_extern_pool;
+
+    /* for pre allocation */
+    D3D_DecoderSurface     *hw_surface[MAX_SURFACE_COUNT];
+
+    /* Video service */
+    GUID                   input;
+    D3D_DecoderDevice      *d3ddec;
+
+    /* Video decoder */
+    D3D_DecoderType        *decoder;
+
+    /**
+     * Read the list of possible input GUIDs
+     */
+    int (*pf_get_input_list)(vlc_va_t *, input_list_t *);
+    /**
+     * Find a suitable decoder configuration for the input and set the
+     * internal state to use that output
+     */
+    int (*pf_setup_output)(vlc_va_t *, const GUID *input, const video_format_t *fmt);
+
+} directx_sys_t;
+
+int directx_va_Open(vlc_va_t *, directx_sys_t *);
+void directx_va_Close(vlc_va_t *, directx_sys_t *);
+int directx_va_Setup(vlc_va_t *, directx_sys_t *, const AVCodecContext *avctx, const es_format_t *, int flag_xbox);
+char *directx_va_GetDecoderName(const GUID *guid);
+bool directx_va_canUseHevc(vlc_va_t *, UINT DeviceId);
+
+#endif /* AVCODEC_DIRECTX_VA_H */
diff --git modules/codec/avcodec/dxva2.c modules/codec/avcodec/dxva2.c
index 372031915..6aa4160c1 100644
--- modules/codec/avcodec/dxva2.c
+++ modules/codec/avcodec/dxva2.c
@@ -27,50 +27,34 @@
 # include "config.h"
 #endif
 
-
-# if _WIN32_WINNT < 0x600
-/* dxva2 needs Vista support */
-#  undef _WIN32_WINNT
-#  define _WIN32_WINNT 0x600
-# endif
-
 #include <assert.h>
 
 #include <vlc_common.h>
 #include <vlc_picture.h>
-#include <vlc_fourcc.h>
-#include <vlc_cpu.h>
 #include <vlc_plugin.h>
 
-#include <libavcodec/avcodec.h>
-#    define DXVA2API_USE_BITFIELDS
-#    define COBJMACROS
-#    include <libavcodec/dxva2.h>
+#define DXVA2API_USE_BITFIELDS
+#define COBJMACROS
+#include <libavcodec/dxva2.h>
+#include "../../video_chroma/d3d9_fmt.h"
 
-#include "avcodec.h"
-#include "va.h"
-#include "../../video_chroma/copy.h"
-#include "../../demux/asf/libasf_guid.h"
+#define D3D_DecoderType     IDirectXVideoDecoder
+#define D3D_DecoderDevice   IDirectXVideoDecoderService
+#define D3D_DecoderSurface  IDirect3DSurface9
+#include "directx_va.h"
 
-static int Open(vlc_va_t *, AVCodecContext *, const es_format_t *);
-static void Close(vlc_va_t *);
+static int Open(vlc_va_t *, AVCodecContext *, enum PixelFormat,
+                const es_format_t *, picture_sys_t *p_sys);
+static void Close(vlc_va_t *, void **);
 
 vlc_module_begin()
     set_description(N_("DirectX Video Acceleration (DXVA) 2.0"))
-    set_capability("hw decoder", 0)
+    set_capability("hw decoder", 100)
     set_category(CAT_INPUT)
     set_subcategory(SUBCAT_INPUT_VCODEC)
     set_callbacks(Open, Close)
 vlc_module_end()
 
-#include <windows.h>
-#include <windowsx.h>
-#include <ole2.h>
-#include <commctrl.h>
-#include <shlwapi.h>
-#include <d3d9.h>
-#include <dxva2api.h>
-
 #include <initguid.h> /* must be last included to not redefine existing GUIDs */
 
 /* dxva2api.h GUIDs: http://msdn.microsoft.com/en-us/library/windows/desktop/ms697067(v=vs100).aspx
@@ -93,136 +77,28 @@ vlc_module_end()
 MS_GUID(IID_IDirectXVideoDecoderService, 0xfc51a551, 0xd5e7, 0x11d9, 0xaf,0x55,0x00,0x05,0x4e,0x43,0xff,0x02);
 MS_GUID(IID_IDirectXVideoAccelerationService, 0xfc51a550, 0xd5e7, 0x11d9, 0xaf,0x55,0x00,0x05,0x4e,0x43,0xff,0x02);
 
-MS_GUID    (DXVA_NoEncrypt,                         0x1b81bed0, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-
-/* Codec capabilities GUID, sorted by codec */
-MS_GUID    (DXVA2_ModeMPEG2_MoComp,                 0xe6a9f44b, 0x61b0, 0x4563, 0x9e, 0xa4, 0x63, 0xd2, 0xa3, 0xc6, 0xfe, 0x66);
-MS_GUID    (DXVA2_ModeMPEG2_IDCT,                   0xbf22ad00, 0x03ea, 0x4690, 0x80, 0x77, 0x47, 0x33, 0x46, 0x20, 0x9b, 0x7e);
-MS_GUID    (DXVA2_ModeMPEG2_VLD,                    0xee27417f, 0x5e28, 0x4e65, 0xbe, 0xea, 0x1d, 0x26, 0xb5, 0x08, 0xad, 0xc9);
-DEFINE_GUID(DXVA2_ModeMPEG2and1_VLD,                0x86695f12, 0x340e, 0x4f04, 0x9f, 0xd3, 0x92, 0x53, 0xdd, 0x32, 0x74, 0x60);
-DEFINE_GUID(DXVA2_ModeMPEG1_VLD,                    0x6f3ec719, 0x3735, 0x42cc, 0x80, 0x63, 0x65, 0xcc, 0x3c, 0xb3, 0x66, 0x16);
-
-MS_GUID    (DXVA2_ModeH264_A,                       0x1b81be64, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-MS_GUID    (DXVA2_ModeH264_B,                       0x1b81be65, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-MS_GUID    (DXVA2_ModeH264_C,                       0x1b81be66, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-MS_GUID    (DXVA2_ModeH264_D,                       0x1b81be67, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-MS_GUID    (DXVA2_ModeH264_E,                       0x1b81be68, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-MS_GUID    (DXVA2_ModeH264_F,                       0x1b81be69, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-DEFINE_GUID(DXVA_ModeH264_VLD_Multiview,            0x9901CCD3, 0xca12, 0x4b7e, 0x86, 0x7a, 0xe2, 0x22, 0x3d, 0x92, 0x55, 0xc3); // MVC
-DEFINE_GUID(DXVA_ModeH264_VLD_WithFMOASO_NoFGT,     0xd5f04ff9, 0x3418, 0x45d8, 0x95, 0x61, 0x32, 0xa7, 0x6a, 0xae, 0x2d, 0xdd);
-DEFINE_GUID(DXVADDI_Intel_ModeH264_A,               0x604F8E64, 0x4951, 0x4c54, 0x88, 0xFE, 0xAB, 0xD2, 0x5C, 0x15, 0xB3, 0xD6);
-DEFINE_GUID(DXVADDI_Intel_ModeH264_C,               0x604F8E66, 0x4951, 0x4c54, 0x88, 0xFE, 0xAB, 0xD2, 0x5C, 0x15, 0xB3, 0xD6);
-DEFINE_GUID(DXVADDI_Intel_ModeH264_E,               0x604F8E68, 0x4951, 0x4c54, 0x88, 0xFE, 0xAB, 0xD2, 0x5C, 0x15, 0xB3, 0xD6); // DXVA_Intel_H264_NoFGT_ClearVideo
-DEFINE_GUID(DXVA_ModeH264_VLD_NoFGT_Flash,          0x4245F676, 0x2BBC, 0x4166, 0xa0, 0xBB, 0x54, 0xE7, 0xB8, 0x49, 0xC3, 0x80);
-
-MS_GUID    (DXVA2_ModeWMV8_A,                       0x1b81be80, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-MS_GUID    (DXVA2_ModeWMV8_B,                       0x1b81be81, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-
-MS_GUID    (DXVA2_ModeWMV9_A,                       0x1b81be90, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-MS_GUID    (DXVA2_ModeWMV9_B,                       0x1b81be91, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-MS_GUID    (DXVA2_ModeWMV9_C,                       0x1b81be94, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-
-MS_GUID    (DXVA2_ModeVC1_A,                        0x1b81beA0, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-MS_GUID    (DXVA2_ModeVC1_B,                        0x1b81beA1, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-MS_GUID    (DXVA2_ModeVC1_C,                        0x1b81beA2, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-MS_GUID    (DXVA2_ModeVC1_D,                        0x1b81beA3, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
-DEFINE_GUID(DXVA2_ModeVC1_D2010,                    0x1b81beA4, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5); // August 2010 update
-DEFINE_GUID(DXVA_Intel_VC1_ClearVideo,              0xBCC5DB6D, 0xA2B6, 0x4AF0, 0xAC, 0xE4, 0xAD, 0xB1, 0xF7, 0x87, 0xBC, 0x89);
-DEFINE_GUID(DXVA_Intel_VC1_ClearVideo_2,            0xE07EC519, 0xE651, 0x4CD6, 0xAC, 0x84, 0x13, 0x70, 0xCC, 0xEE, 0xC8, 0x51);
-
-DEFINE_GUID(DXVA_nVidia_MPEG4_ASP,                  0x9947EC6F, 0x689B, 0x11DC, 0xA3, 0x20, 0x00, 0x19, 0xDB, 0xBC, 0x41, 0x84);
-DEFINE_GUID(DXVA_ModeMPEG4pt2_VLD_Simple,           0xefd64d74, 0xc9e8, 0x41d7, 0xa5, 0xe9, 0xe9, 0xb0, 0xe3, 0x9f, 0xa3, 0x19);
-DEFINE_GUID(DXVA_ModeMPEG4pt2_VLD_AdvSimple_NoGMC,  0xed418a9f, 0x010d, 0x4eda, 0x9a, 0xe3, 0x9a, 0x65, 0x35, 0x8d, 0x8d, 0x2e);
-DEFINE_GUID(DXVA_ModeMPEG4pt2_VLD_AdvSimple_GMC,    0xab998b5b, 0x4258, 0x44a9, 0x9f, 0xeb, 0x94, 0xe5, 0x97, 0xa6, 0xba, 0xae);
-DEFINE_GUID(DXVA_ModeMPEG4pt2_VLD_AdvSimple_Avivo,  0x7C74ADC6, 0xe2ba, 0x4ade, 0x86, 0xde, 0x30, 0xbe, 0xab, 0xb4, 0x0c, 0xc1);
-
+DEFINE_GUID(DXVA2_NoEncrypt,                        0x1b81bed0, 0xa0c7, 0x11d3, 0xb9, 0x84, 0x00, 0xc0, 0x4f, 0x2e, 0x73, 0xc5);
 
-/* */
-typedef struct {
-    const char   *name;
-    const GUID   *guid;
-    int          codec;
-} dxva2_mode_t;
-/* XXX Prefered modes must come first */
-static const dxva2_mode_t dxva2_modes[] = {
-    /* MPEG-1/2 */
-    { "MPEG-2 variable-length decoder",                                               &DXVA2_ModeMPEG2_VLD,                   AV_CODEC_ID_MPEG2VIDEO },
-    { "MPEG-2 & MPEG-1 variable-length decoder",                                      &DXVA2_ModeMPEG2and1_VLD,               AV_CODEC_ID_MPEG2VIDEO },
-    { "MPEG-2 motion compensation",                                                   &DXVA2_ModeMPEG2_MoComp,                0 },
-    { "MPEG-2 inverse discrete cosine transform",                                     &DXVA2_ModeMPEG2_IDCT,                  0 },
-
-    { "MPEG-1 variable-length decoder",                                               &DXVA2_ModeMPEG1_VLD,                   0 },
-
-    /* H.264 */
-    { "H.264 variable-length decoder, film grain technology",                         &DXVA2_ModeH264_F,                      AV_CODEC_ID_H264 },
-    { "H.264 variable-length decoder, no film grain technology (Intel ClearVideo)",   &DXVADDI_Intel_ModeH264_E,              AV_CODEC_ID_H264 },
-    { "H.264 variable-length decoder, no film grain technology",                      &DXVA2_ModeH264_E,                      AV_CODEC_ID_H264 },
-    { "H.264 variable-length decoder, no film grain technology, FMO/ASO",             &DXVA_ModeH264_VLD_WithFMOASO_NoFGT,    AV_CODEC_ID_H264 },
-    { "H.264 variable-length decoder, no film grain technology, Flash",               &DXVA_ModeH264_VLD_NoFGT_Flash,         AV_CODEC_ID_H264 },
-
-    { "H.264 inverse discrete cosine transform, film grain technology",               &DXVA2_ModeH264_D,                      0 },
-    { "H.264 inverse discrete cosine transform, no film grain technology",            &DXVA2_ModeH264_C,                      0 },
-    { "H.264 inverse discrete cosine transform, no film grain technology (Intel)",    &DXVADDI_Intel_ModeH264_C,              0 },
-
-    { "H.264 motion compensation, film grain technology",                             &DXVA2_ModeH264_B,                      0 },
-    { "H.264 motion compensation, no film grain technology",                          &DXVA2_ModeH264_A,                      0 },
-    { "H.264 motion compensation, no film grain technology (Intel)",                  &DXVADDI_Intel_ModeH264_A,              0 },
-
-    /* WMV */
-    { "Windows Media Video 8 motion compensation",                                    &DXVA2_ModeWMV8_B,                      0 },
-    { "Windows Media Video 8 post processing",                                        &DXVA2_ModeWMV8_A,                      0 },
-
-    { "Windows Media Video 9 IDCT",                                                   &DXVA2_ModeWMV9_C,                      0 },
-    { "Windows Media Video 9 motion compensation",                                    &DXVA2_ModeWMV9_B,                      0 },
-    { "Windows Media Video 9 post processing",                                        &DXVA2_ModeWMV9_A,                      0 },
-
-    /* VC-1 */
-    { "VC-1 variable-length decoder",                                                 &DXVA2_ModeVC1_D,                       AV_CODEC_ID_VC1 },
-    { "VC-1 variable-length decoder",                                                 &DXVA2_ModeVC1_D,                       AV_CODEC_ID_WMV3 },
-    { "VC-1 variable-length decoder",                                                 &DXVA2_ModeVC1_D2010,                   AV_CODEC_ID_VC1 },
-    { "VC-1 variable-length decoder",                                                 &DXVA2_ModeVC1_D2010,                   AV_CODEC_ID_WMV3 },
-    { "VC-1 variable-length decoder 2 (Intel)",                                       &DXVA_Intel_VC1_ClearVideo_2,           0 },
-    { "VC-1 variable-length decoder (Intel)",                                         &DXVA_Intel_VC1_ClearVideo,             0 },
-
-    { "VC-1 inverse discrete cosine transform",                                       &DXVA2_ModeVC1_C,                       0 },
-    { "VC-1 motion compensation",                                                     &DXVA2_ModeVC1_B,                       0 },
-    { "VC-1 post processing",                                                         &DXVA2_ModeVC1_A,                       0 },
-
-    /* Xvid/Divx: TODO */
-    { "MPEG-4 Part 2 nVidia bitstream decoder",                                       &DXVA_nVidia_MPEG4_ASP,                 0 },
-    { "MPEG-4 Part 2 variable-length decoder, Simple Profile",                        &DXVA_ModeMPEG4pt2_VLD_Simple,          0 },
-    { "MPEG-4 Part 2 variable-length decoder, Simple&Advanced Profile, no GMC",       &DXVA_ModeMPEG4pt2_VLD_AdvSimple_NoGMC, 0 },
-    { "MPEG-4 Part 2 variable-length decoder, Simple&Advanced Profile, GMC",          &DXVA_ModeMPEG4pt2_VLD_AdvSimple_GMC,   0 },
-    { "MPEG-4 Part 2 variable-length decoder, Simple&Advanced Profile, Avivo",        &DXVA_ModeMPEG4pt2_VLD_AdvSimple_Avivo, 0 },
-
-    { NULL, NULL, 0 }
-};
+DEFINE_GUID(DXVA_Intel_H264_NoFGT_ClearVideo,       0x604F8E68, 0x4951, 0x4c54, 0x88, 0xFE, 0xAB, 0xD2, 0x5C, 0x15, 0xB3, 0xD6);
 
-static const dxva2_mode_t *Dxva2FindMode(const GUID *guid)
-{
-    for (unsigned i = 0; dxva2_modes[i].name; i++) {
-        if (IsEqualGUID(dxva2_modes[i].guid, guid))
-            return &dxva2_modes[i];
-    }
-    return NULL;
-}
 
 /* */
 typedef struct {
     const char   *name;
     D3DFORMAT    format;
     vlc_fourcc_t codec;
-} d3d_format_t;
+} d3d9_format_t;
 /* XXX Prefered format must come first */
-static const d3d_format_t d3d_formats[] = {
+static const d3d9_format_t d3d_formats[] = {
     { "YV12",   MAKEFOURCC('Y','V','1','2'),    VLC_CODEC_YV12 },
     { "NV12",   MAKEFOURCC('N','V','1','2'),    VLC_CODEC_NV12 },
     { "IMC3",   MAKEFOURCC('I','M','C','3'),    VLC_CODEC_YV12 },
+    { "P010",   MAKEFOURCC('P','0','1','0'),    VLC_CODEC_P010 },
 
     { NULL, 0, 0 }
 };
 
-static const d3d_format_t *D3dFindFormat(D3DFORMAT format)
+static const d3d9_format_t *D3dFindFormat(D3DFORMAT format)
 {
     for (unsigned i = 0; d3d_formats[i].name; i++) {
         if (d3d_formats[i].format == format)
@@ -231,200 +107,123 @@ static const d3d_format_t *D3dFindFormat(D3DFORMAT format)
     return NULL;
 }
 
-/* */
-typedef struct {
-    LPDIRECT3DSURFACE9 d3d;
-    int                refcount;
-    unsigned int       order;
-} vlc_va_surface_t;
-
-#define VA_DXVA2_MAX_SURFACE_COUNT (64)
 struct vlc_va_sys_t
 {
-    int          codec_id;
-    int          width;
-    int          height;
-
-    /* DLL */
-    HINSTANCE             hd3d9_dll;
-    HINSTANCE             hdxva2_dll;
+    directx_sys_t         dx_sys;
 
     /* Direct3D */
-    D3DPRESENT_PARAMETERS  d3dpp;
-    LPDIRECT3D9            d3dobj;
-    D3DADAPTER_IDENTIFIER9 d3dai;
-    LPDIRECT3DDEVICE9      d3ddev;
+    d3d9_handle_t          hd3d;
+    d3d9_device_t          d3d_dev;
+
+    /* DLL */
+    HINSTANCE              dxva2_dll;
 
     /* Device manager */
-    UINT                     token;
     IDirect3DDeviceManager9  *devmng;
     HANDLE                   device;
 
     /* Video service */
-    IDirectXVideoDecoderService  *vs;
-    GUID                         input;
     D3DFORMAT                    render;
 
     /* Video decoder */
     DXVA2_ConfigPictureDecode    cfg;
-    IDirectXVideoDecoder         *decoder;
 
-    /* Option conversion */
-    D3DFORMAT                    output;
-    copy_cache_t                 surface_cache;
-
-    /* */
+    /* avcodec internals */
     struct dxva_context hw;
-
-    /* */
-    unsigned     surface_count;
-    unsigned     surface_order;
-    int          surface_width;
-    int          surface_height;
-    vlc_fourcc_t surface_chroma;
-
-    int          thread_count;
-
-    vlc_va_surface_t surface[VA_DXVA2_MAX_SURFACE_COUNT];
-    LPDIRECT3DSURFACE9 hw_surface[VA_DXVA2_MAX_SURFACE_COUNT];
 };
 
+
 /* */
 static int D3dCreateDevice(vlc_va_t *);
-static void D3dDestroyDevice(vlc_va_sys_t *);
+static void D3dDestroyDevice(vlc_va_t *);
 static char *DxDescribe(vlc_va_sys_t *);
 
 static int D3dCreateDeviceManager(vlc_va_t *);
-static void D3dDestroyDeviceManager(vlc_va_sys_t *);
+static void D3dDestroyDeviceManager(vlc_va_t *);
 
 static int DxCreateVideoService(vlc_va_t *);
-static void DxDestroyVideoService(vlc_va_sys_t *);
-static int DxFindVideoServiceConversion(vlc_va_t *, GUID *input, D3DFORMAT *output);
+static void DxDestroyVideoService(vlc_va_t *);
+static int DxGetInputList(vlc_va_t *, input_list_t *);
+static int DxSetupOutput(vlc_va_t *, const GUID *, const video_format_t *);
 
-static int DxCreateVideoDecoder(vlc_va_t *,
-                                int codec_id, const video_format_t *);
-static void DxDestroyVideoDecoder(vlc_va_sys_t *);
+static int DxCreateVideoDecoder(vlc_va_t *, int codec_id,
+                                const video_format_t *, unsigned surface_count);
+static void DxDestroyVideoDecoder(vlc_va_t *);
 static int DxResetVideoDecoder(vlc_va_t *);
+static void SetupAVCodecContext(vlc_va_t *);
 
-static void DxCreateVideoConversion(vlc_va_sys_t *);
-static void DxDestroyVideoConversion(vlc_va_sys_t *);
-
-/* */
-static int Setup(vlc_va_t *va, void **hw, vlc_fourcc_t *chroma,
-                 int width, int height)
+void SetupAVCodecContext(vlc_va_t *va)
 {
     vlc_va_sys_t *sys = va->sys;
+    directx_sys_t *dx_sys = &sys->dx_sys;
 
-    if (sys->width == width && sys->height == height && sys->decoder)
-        goto ok;
-
-    /* */
-    DxDestroyVideoConversion(sys);
-    DxDestroyVideoDecoder(sys);
-
-    *hw = NULL;
-    *chroma = 0;
-    if (width <= 0 || height <= 0)
-        return VLC_EGENERIC;
-
-    /* FIXME transmit a video_format_t by VaSetup directly */
-    video_format_t fmt;
-    memset(&fmt, 0, sizeof(fmt));
-    fmt.i_width = width;
-    fmt.i_height = height;
-
-    if (DxCreateVideoDecoder(va, sys->codec_id, &fmt))
-        return VLC_EGENERIC;
-    /* */
-    sys->hw.decoder = sys->decoder;
+    sys->hw.decoder = dx_sys->decoder;
     sys->hw.cfg = &sys->cfg;
-    sys->hw.surface_count = sys->surface_count;
-    sys->hw.surface = sys->hw_surface;
-
-    /* */
-    DxCreateVideoConversion(sys);
-
-    /* */
-ok:
-    *hw = &sys->hw;
-    const d3d_format_t *output = D3dFindFormat(sys->output);
-    *chroma = output->codec;
+    sys->hw.surface_count = dx_sys->va_pool.surface_count;
+    sys->hw.surface = dx_sys->hw_surface;
 
-    return VLC_SUCCESS;
+    if (IsEqualGUID(&dx_sys->input, &DXVA_Intel_H264_NoFGT_ClearVideo))
+        sys->hw.workaround |= FF_DXVA2_WORKAROUND_INTEL_CLEARVIDEO;
 }
 
-static int Extract(vlc_va_t *va, picture_t *picture, void *opaque,
-                   uint8_t *data)
+static void d3d9_pic_context_destroy(struct picture_context_t *opaque)
 {
-    vlc_va_sys_t *sys = va->sys;
-    LPDIRECT3DSURFACE9 d3d = (LPDIRECT3DSURFACE9)(uintptr_t)data;
+    struct va_pic_context *pic_ctx = (struct va_pic_context*)opaque;
+    if (pic_ctx->va_surface)
+    {
+        ReleasePictureSys(&pic_ctx->picsys);
+        va_surface_Release(pic_ctx->va_surface);
+        free(pic_ctx);
+    }
+}
 
-    if (!sys->surface_cache.buffer)
-        return VLC_EGENERIC;
+static struct va_pic_context *CreatePicContext(IDirect3DSurface9 *, IDirectXVideoDecoder *);
 
-    /* */
-    assert(sys->output == MAKEFOURCC('Y','V','1','2'));
-
-    /* */
-    D3DLOCKED_RECT lock;
-    if (FAILED(IDirect3DSurface9_LockRect(d3d, &lock, NULL, D3DLOCK_READONLY))) {
-        msg_Err(va, "Failed to lock surface");
-        return VLC_EGENERIC;
-    }
+static struct picture_context_t *d3d9_pic_context_copy(struct picture_context_t *ctx)
+{
+    struct va_pic_context *src_ctx = (struct va_pic_context*)ctx;
+    struct va_pic_context *pic_ctx = CreatePicContext(src_ctx->picsys.surface, src_ctx->picsys.decoder);
+    if (unlikely(pic_ctx==NULL))
+        return NULL;
+    pic_ctx->va_surface = src_ctx->va_surface;
+    va_surface_AddRef(pic_ctx->va_surface);
+    return &pic_ctx->s;
+}
 
-    if (sys->render == MAKEFOURCC('Y','V','1','2') ||
-        sys->render == MAKEFOURCC('I','M','C','3')) {
-        bool imc3 = sys->render == MAKEFOURCC('I','M','C','3');
-        size_t chroma_pitch = imc3 ? lock.Pitch : (lock.Pitch / 2);
-
-        size_t pitch[3] = {
-            lock.Pitch,
-            chroma_pitch,
-            chroma_pitch,
-        };
-
-        uint8_t *plane[3] = {
-            (uint8_t*)lock.pBits,
-            (uint8_t*)lock.pBits + pitch[0] * sys->surface_height,
-            (uint8_t*)lock.pBits + pitch[0] * sys->surface_height
-                                 + pitch[1] * sys->surface_height / 2,
-        };
-
-        if (imc3) {
-            uint8_t *V = plane[1];
-            plane[1] = plane[2];
-            plane[2] = V;
-        }
-        CopyFromYv12(picture, plane, pitch, sys->width, sys->height,
-                     &sys->surface_cache);
-    } else {
-        assert(sys->render == MAKEFOURCC('N','V','1','2'));
-        uint8_t *plane[2] = {
-            lock.pBits,
-            (uint8_t*)lock.pBits + lock.Pitch * sys->surface_height
-        };
-        size_t  pitch[2] = {
-            lock.Pitch,
-            lock.Pitch,
-        };
-        CopyFromNv12(picture, plane, pitch, sys->width, sys->height,
-                     &sys->surface_cache);
-    }
+static struct va_pic_context *CreatePicContext(IDirect3DSurface9 *surface, IDirectXVideoDecoder *decoder)
+{
+    struct va_pic_context *pic_ctx = calloc(1, sizeof(*pic_ctx));
+    if (unlikely(pic_ctx==NULL))
+        return NULL;
+    pic_ctx->s.destroy = d3d9_pic_context_destroy;
+    pic_ctx->s.copy    = d3d9_pic_context_copy;
+    pic_ctx->picsys.surface = surface;
+    pic_ctx->picsys.decoder = decoder;
+    AcquirePictureSys(&pic_ctx->picsys);
+    return pic_ctx;
+}
 
-    /* */
-    IDirect3DSurface9_UnlockRect(d3d);
-    (void) opaque;
-    return VLC_SUCCESS;
+static struct va_pic_context* NewSurfacePicContext(vlc_va_t *va, int surface_index)
+{
+    directx_sys_t *dx_sys = &va->sys->dx_sys;
+    struct va_pic_context *pic_ctx = CreatePicContext(dx_sys->hw_surface[surface_index], dx_sys->decoder);
+    if (unlikely(pic_ctx==NULL))
+        return NULL;
+    /* all the resources are acquired during surfaces init, and a second time in
+     * CreatePicContext(), undo one of them otherwise we need an extra release
+     * when the pool is emptied */
+    ReleasePictureSys(&pic_ctx->picsys);
+    return pic_ctx;
 }
 
-/* FIXME it is nearly common with VAAPI */
-static int Get(vlc_va_t *va, void **opaque, uint8_t **data)
+static int Get(vlc_va_t *va, picture_t *pic, uint8_t **data)
 {
     vlc_va_sys_t *sys = va->sys;
 
     /* Check the device */
     HRESULT hr = IDirect3DDeviceManager9_TestDevice(sys->devmng, sys->device);
     if (hr == DXVA2_E_NEW_VIDEO_DEVICE) {
+        msg_Warn(va, "New video device detected.");
         if (DxResetVideoDecoder(va))
             return VLC_EGENERIC;
     } else if (FAILED(hr)) {
@@ -432,116 +231,103 @@ static int Get(vlc_va_t *va, void **opaque, uint8_t **data)
         return VLC_EGENERIC;
     }
 
-    /* Grab an unused surface, in case none are, try the oldest
-     * XXX using the oldest is a workaround in case a problem happens with libavcodec */
-    unsigned i, old;
-    for (i = 0, old = 0; i < sys->surface_count; i++) {
-        vlc_va_surface_t *surface = &sys->surface[i];
-
-        if (!surface->refcount)
-            break;
-
-        if (surface->order < sys->surface[old].order)
-            old = i;
-    }
-    if (i >= sys->surface_count)
-        i = old;
-
-    vlc_va_surface_t *surface = &sys->surface[i];
-
-    surface->refcount = 1;
-    surface->order = sys->surface_order++;
-    *data = (void *)surface->d3d;
-    *opaque = surface;
-    return VLC_SUCCESS;
+    int res = va_pool_Get(&sys->dx_sys.va_pool, pic);
+    if (likely(res==VLC_SUCCESS))
+        *data = (uint8_t*)((struct va_pic_context*)pic->context)->picsys.surface;
+    return res;
 }
 
-static void Release(void *opaque, uint8_t *data)
-{
-    vlc_va_surface_t *surface = opaque;
-
-    surface->refcount--;
-    (void) data;
-}
-
-static void Close(vlc_va_t *va)
+static void Close(vlc_va_t *va, void **ctx)
 {
     vlc_va_sys_t *sys = va->sys;
+    if ( sys == NULL )
+        return;
+
+    (void) ctx;
 
-    DxDestroyVideoConversion(sys);
-    DxDestroyVideoDecoder(sys);
-    DxDestroyVideoService(sys);
-    D3dDestroyDeviceManager(sys);
-    D3dDestroyDevice(sys);
+    directx_va_Close(va, &sys->dx_sys);
 
-    if (sys->hdxva2_dll)
-        FreeLibrary(sys->hdxva2_dll);
-    if (sys->hd3d9_dll)
-        FreeLibrary(sys->hd3d9_dll);
+    if (sys->dxva2_dll)
+        FreeLibrary(sys->dxva2_dll);
 
     free((char *)va->description);
     free(sys);
 }
 
-static int Open(vlc_va_t *va, AVCodecContext *ctx, const es_format_t *fmt)
+static int Open(vlc_va_t *va, AVCodecContext *ctx, enum PixelFormat pix_fmt,
+                const es_format_t *fmt, picture_sys_t *p_sys)
 {
+    int err = VLC_EGENERIC;
+    directx_sys_t *dx_sys;
+
+    if (pix_fmt != AV_PIX_FMT_DXVA2_VLD)
+        return VLC_EGENERIC;
+
+    ctx->hwaccel_context = NULL;
+
     vlc_va_sys_t *sys = calloc(1, sizeof (*sys));
     if (unlikely(sys == NULL))
         return VLC_ENOMEM;
 
-    va->sys = sys;
-    sys->codec_id = ctx->codec_id;
-    (void) fmt;
-
     /* Load dll*/
-    sys->hd3d9_dll = LoadLibrary(TEXT("D3D9.DLL"));
-    if (!sys->hd3d9_dll) {
+    if (D3D9_Create(va, &sys->hd3d) != VLC_SUCCESS) {
         msg_Warn(va, "cannot load d3d9.dll");
+        free( sys );
         goto error;
     }
-    sys->hdxva2_dll = LoadLibrary(TEXT("DXVA2.DLL"));
-    if (!sys->hdxva2_dll) {
-        msg_Warn(va, "cannot load dxva2.dll");
-        goto error;
-    }
-    msg_Dbg(va, "DLLs loaded");
 
-    /* */
-    if (D3dCreateDevice(va)) {
-        msg_Err(va, "Failed to create Direct3D device");
+    /* Load dll*/
+    sys->dxva2_dll = LoadLibrary(TEXT("DXVA2.DLL"));
+    if (!sys->dxva2_dll) {
+        msg_Warn(va, "cannot load DXVA2 decoder DLL");
+        D3D9_Destroy( &sys->hd3d );
+        free( sys );
         goto error;
     }
-    msg_Dbg(va, "D3dCreateDevice succeed");
 
-    if (D3dCreateDeviceManager(va)) {
-        msg_Err(va, "D3dCreateDeviceManager failed");
-        goto error;
+    dx_sys = &sys->dx_sys;
+
+    dx_sys->va_pool.pf_create_device           = D3dCreateDevice;
+    dx_sys->va_pool.pf_destroy_device          = D3dDestroyDevice;
+    dx_sys->va_pool.pf_create_device_manager   = D3dCreateDeviceManager;
+    dx_sys->va_pool.pf_destroy_device_manager  = D3dDestroyDeviceManager;
+    dx_sys->va_pool.pf_create_video_service    = DxCreateVideoService;
+    dx_sys->va_pool.pf_destroy_video_service   = DxDestroyVideoService;
+    dx_sys->va_pool.pf_create_decoder_surfaces = DxCreateVideoDecoder;
+    dx_sys->va_pool.pf_destroy_surfaces        = DxDestroyVideoDecoder;
+    dx_sys->va_pool.pf_setup_avcodec_ctx       = SetupAVCodecContext;
+    dx_sys->va_pool.pf_new_surface_context     = NewSurfacePicContext;
+    dx_sys->pf_get_input_list          = DxGetInputList;
+    dx_sys->pf_setup_output            = DxSetupOutput;
+
+    va->sys = sys;
+
+    if (p_sys!=NULL)
+    {
+        D3DSURFACE_DESC src;
+        if (SUCCEEDED(IDirect3DSurface9_GetDesc(p_sys->surface, &src)))
+            sys->render = src.Format;
+        IDirect3DSurface9_GetDevice(p_sys->surface, &sys->d3d_dev.dev );
+        sys->d3d_dev.owner = false;
     }
 
-    if (DxCreateVideoService(va)) {
-        msg_Err(va, "DxCreateVideoService failed");
+    err = directx_va_Open(va, &sys->dx_sys);
+    if (err!=VLC_SUCCESS)
         goto error;
-    }
 
-    /* */
-    if (DxFindVideoServiceConversion(va, &sys->input, &sys->render)) {
-        msg_Err(va, "DxFindVideoServiceConversion failed");
+    err = directx_va_Setup(va, &sys->dx_sys, ctx, fmt, 0);
+    if (err != VLC_SUCCESS)
         goto error;
-    }
 
-    sys->thread_count = ctx->thread_count;
+    ctx->hwaccel_context = &sys->hw;
 
     /* TODO print the hardware name/vendor for debugging purposes */
     va->description = DxDescribe(sys);
-    va->pix_fmt = PIX_FMT_DXVA2_VLD;
-    va->setup   = Setup;
     va->get     = Get;
-    va->release = Release;
-    va->extract = Extract;
     return VLC_SUCCESS;
 
 error:
-    Close(va);
+    Close(va, NULL);
     return VLC_EGENERIC;
 }
 /* */
@@ -553,59 +339,18 @@ static int D3dCreateDevice(vlc_va_t *va)
 {
     vlc_va_sys_t *sys = va->sys;
 
-    /* */
-    LPDIRECT3D9 (WINAPI *Create9)(UINT SDKVersion);
-    Create9 = (void *)GetProcAddress(sys->hd3d9_dll, "Direct3DCreate9");
-    if (!Create9) {
-        msg_Err(va, "Cannot locate reference to Direct3DCreate9 ABI in DLL");
-        return VLC_EGENERIC;
-    }
-
-    /* */
-    LPDIRECT3D9 d3dobj;
-    d3dobj = Create9(D3D_SDK_VERSION);
-    if (!d3dobj) {
-        msg_Err(va, "Direct3DCreate9 failed");
-        return VLC_EGENERIC;
+    if (sys->d3d_dev.dev) {
+        msg_Dbg(va, "Reusing Direct3D9 device");
+        return VLC_SUCCESS;
     }
-    sys->d3dobj = d3dobj;
 
-    /* */
-    D3DADAPTER_IDENTIFIER9 *d3dai = &sys->d3dai;
-    if (FAILED(IDirect3D9_GetAdapterIdentifier(sys->d3dobj,
-                                               D3DADAPTER_DEFAULT, 0, d3dai))) {
-        msg_Warn(va, "IDirect3D9_GetAdapterIdentifier failed");
-        ZeroMemory(d3dai, sizeof(*d3dai));
-    }
-
-    /* */
-    D3DPRESENT_PARAMETERS *d3dpp = &sys->d3dpp;
-    ZeroMemory(d3dpp, sizeof(*d3dpp));
-    d3dpp->Flags                  = D3DPRESENTFLAG_VIDEO;
-    d3dpp->Windowed               = TRUE;
-    d3dpp->hDeviceWindow          = NULL;
-    d3dpp->SwapEffect             = D3DSWAPEFFECT_DISCARD;
-    d3dpp->MultiSampleType        = D3DMULTISAMPLE_NONE;
-    d3dpp->PresentationInterval   = D3DPRESENT_INTERVAL_DEFAULT;
-    d3dpp->BackBufferCount        = 0;                  /* FIXME what to put here */
-    d3dpp->BackBufferFormat       = D3DFMT_X8R8G8B8;    /* FIXME what to put here */
-    d3dpp->BackBufferWidth        = 0;
-    d3dpp->BackBufferHeight       = 0;
-    d3dpp->EnableAutoDepthStencil = FALSE;
-
-    /* Direct3D needs a HWND to create a device, even without using ::Present
-    this HWND is used to alert Direct3D when there's a change of focus window.
-    For now, use GetDesktopWindow, as it looks harmless */
-    LPDIRECT3DDEVICE9 d3ddev;
-    if (FAILED(IDirect3D9_CreateDevice(d3dobj, D3DADAPTER_DEFAULT,
-                                       D3DDEVTYPE_HAL, GetDesktopWindow(),
-                                       D3DCREATE_SOFTWARE_VERTEXPROCESSING |
-                                       D3DCREATE_MULTITHREADED,
-                                       d3dpp, &d3ddev))) {
+    video_format_t fmt = { 0 };
+    HRESULT hr = D3D9_CreateDevice(va, &sys->hd3d, GetDesktopWindow(), &fmt, &sys->d3d_dev);
+    if (FAILED(hr))
+    {
         msg_Err(va, "IDirect3D9_CreateDevice failed");
         return VLC_EGENERIC;
     }
-    sys->d3ddev = d3ddev;
 
     return VLC_SUCCESS;
 }
@@ -613,43 +358,27 @@ static int D3dCreateDevice(vlc_va_t *va)
 /**
  * It releases a Direct3D device and its resources.
  */
-static void D3dDestroyDevice(vlc_va_sys_t *va)
+static void D3dDestroyDevice(vlc_va_t *va)
 {
-    if (va->d3ddev)
-        IDirect3DDevice9_Release(va->d3ddev);
-    if (va->d3dobj)
-        IDirect3D9_Release(va->d3dobj);
+    vlc_va_sys_t *sys = va->sys;
+    D3D9_ReleaseDevice(&sys->d3d_dev);
+    D3D9_Destroy( &sys->hd3d );
 }
 /**
  * It describes our Direct3D object
  */
-static char *DxDescribe(vlc_va_sys_t *va)
+static char *DxDescribe(vlc_va_sys_t *sys)
 {
-    static const struct {
-        unsigned id;
-        char     name[32];
-    } vendors [] = {
-        { 0x1002, "ATI" },
-        { 0x10DE, "NVIDIA" },
-        { 0x1106, "VIA" },
-        { 0x8086, "Intel" },
-        { 0x5333, "S3 Graphics" },
-        { 0, "" }
-    };
-    D3DADAPTER_IDENTIFIER9 *id = &va->d3dai;
-
-    const char *vendor = "Unknown";
-    for (int i = 0; vendors[i].id != 0; i++) {
-        if (vendors[i].id == id->VendorId) {
-            vendor = vendors[i].name;
-            break;
-        }
+    D3DADAPTER_IDENTIFIER9 d3dai;
+    if (FAILED(IDirect3D9_GetAdapterIdentifier(sys->hd3d.obj,
+                                               sys->d3d_dev.adapterId, 0, &d3dai))) {
+        return NULL;
     }
 
     char *description;
-    if (asprintf(&description, "DXVA2 (%.*s, vendor %lu(%s), device %lu, revision %lu)",
-                 sizeof(id->Description), id->Description,
-                 id->VendorId, vendor, id->DeviceId, id->Revision) < 0)
+    if (asprintf(&description, "DXVA2 (%.*s, vendor %s(%lx), device %lx, revision %lx)",
+                 (int)sizeof(d3dai.Description), d3dai.Description,
+                 DxgiVendorStr(d3dai.VendorId), d3dai.VendorId, d3dai.DeviceId, d3dai.Revision) < 0)
         return NULL;
     return description;
 }
@@ -664,7 +393,7 @@ static int D3dCreateDeviceManager(vlc_va_t *va)
     HRESULT (WINAPI *CreateDeviceManager9)(UINT *pResetToken,
                                            IDirect3DDeviceManager9 **);
     CreateDeviceManager9 =
-      (void *)GetProcAddress(sys->hdxva2_dll,
+      (void *)GetProcAddress(sys->dxva2_dll,
                              "DXVA2CreateDirect3DDeviceManager9");
 
     if (!CreateDeviceManager9) {
@@ -679,11 +408,10 @@ static int D3dCreateDeviceManager(vlc_va_t *va)
         msg_Err(va, " OurDirect3DCreateDeviceManager9 failed");
         return VLC_EGENERIC;
     }
-    sys->token  = token;
     sys->devmng = devmng;
-    msg_Info(va, "obtained IDirect3DDeviceManager9");
+    msg_Dbg(va, "obtained IDirect3DDeviceManager9");
 
-    HRESULT hr = IDirect3DDeviceManager9_ResetDevice(devmng, sys->d3ddev, token);
+    HRESULT hr = IDirect3DDeviceManager9_ResetDevice(devmng, sys->d3d_dev.dev, token);
     if (FAILED(hr)) {
         msg_Err(va, "IDirect3DDeviceManager9_ResetDevice failed: %08x", (unsigned)hr);
         return VLC_EGENERIC;
@@ -693,10 +421,10 @@ static int D3dCreateDeviceManager(vlc_va_t *va)
 /**
  * It destroys a Direct3D device manager
  */
-static void D3dDestroyDeviceManager(vlc_va_sys_t *va)
+static void D3dDestroyDeviceManager(vlc_va_t *va)
 {
-    if (va->devmng)
-        IDirect3DDeviceManager9_Release(va->devmng);
+    if (va->sys->devmng)
+        IDirect3DDeviceManager9_Release(va->sys->devmng);
 }
 
 /**
@@ -705,19 +433,7 @@ static void D3dDestroyDeviceManager(vlc_va_sys_t *va)
 static int DxCreateVideoService(vlc_va_t *va)
 {
     vlc_va_sys_t *sys = va->sys;
-
-    HRESULT (WINAPI *CreateVideoService)(IDirect3DDevice9 *,
-                                         REFIID riid,
-                                         void **ppService);
-    CreateVideoService =
-      (void *)GetProcAddress(sys->hdxva2_dll, "DXVA2CreateVideoService");
-
-    if (!CreateVideoService) {
-        msg_Err(va, "cannot load function");
-        return 4;
-    }
-    msg_Info(va, "DXVA2CreateVideoService Success!");
-
+    directx_sys_t *dx_sys = &va->sys->dx_sys;
     HRESULT hr;
 
     HANDLE device;
@@ -735,7 +451,7 @@ static int DxCreateVideoService(vlc_va_t *va)
         msg_Err(va, "GetVideoService failed");
         return VLC_EGENERIC;
     }
-    sys->vs = pv;
+    dx_sys->d3ddec = pv;
 
     return VLC_SUCCESS;
 }
@@ -743,76 +459,93 @@ static int DxCreateVideoService(vlc_va_t *va)
 /**
  * It destroys a DirectX video service
  */
-static void DxDestroyVideoService(vlc_va_sys_t *va)
+static void DxDestroyVideoService(vlc_va_t *va)
 {
-    if (va->device)
-        IDirect3DDeviceManager9_CloseDeviceHandle(va->devmng, va->device);
-    if (va->vs)
-        IDirectXVideoDecoderService_Release(va->vs);
+    directx_sys_t *dx_sys = &va->sys->dx_sys;
+    if (va->sys->device)
+    {
+        HRESULT hr = IDirect3DDeviceManager9_CloseDeviceHandle(va->sys->devmng, va->sys->device);
+        if (FAILED(hr))
+            msg_Warn(va, "Failed to release device handle 0x%p. (hr=0x%lX)", va->sys->device, hr);
+    }
+    if (dx_sys->d3ddec)
+        IDirectXVideoDecoderService_Release(dx_sys->d3ddec);
 }
-/**
- * Find the best suited decoder mode GUID and render format.
- */
-static int DxFindVideoServiceConversion(vlc_va_t *va, GUID *input, D3DFORMAT *output)
+
+static void ReleaseInputList(input_list_t *p_list)
 {
-    vlc_va_sys_t *sys = va->sys;
+    CoTaskMemFree(p_list->list);
+}
 
-    /* Retreive supported modes from the decoder service */
+static int DxGetInputList(vlc_va_t *va, input_list_t *p_list)
+{
+    directx_sys_t *dx_sys = &va->sys->dx_sys;
     UINT input_count = 0;
     GUID *input_list = NULL;
-    if (FAILED(IDirectXVideoDecoderService_GetDecoderDeviceGuids(sys->vs,
+    if (FAILED(IDirectXVideoDecoderService_GetDecoderDeviceGuids(dx_sys->d3ddec,
                                                                  &input_count,
                                                                  &input_list))) {
         msg_Err(va, "IDirectXVideoDecoderService_GetDecoderDeviceGuids failed");
         return VLC_EGENERIC;
     }
-    for (unsigned i = 0; i < input_count; i++) {
-        const GUID *g = &input_list[i];
-        const dxva2_mode_t *mode = Dxva2FindMode(g);
-        if (mode) {
-            msg_Dbg(va, "- '%s' is supported by hardware", mode->name);
-        } else {
-            msg_Warn(va, "- Unknown GUID = " GUID_FMT, GUID_PRINT( *g ) );
-        }
-    }
 
-    /* Try all supported mode by our priority */
-    for (unsigned i = 0; dxva2_modes[i].name; i++) {
-        const dxva2_mode_t *mode = &dxva2_modes[i];
-        if (!mode->codec || mode->codec != sys->codec_id)
-            continue;
+    p_list->count = input_count;
+    p_list->list = input_list;
+    p_list->pf_release = ReleaseInputList;
+    return VLC_SUCCESS;
+}
 
-        /* */
-        bool is_supported = false;
-        for (const GUID *g = &input_list[0]; !is_supported && g < &input_list[input_count]; g++) {
-            is_supported = IsEqualGUID(mode->guid, g);
-        }
-        if (!is_supported)
-            continue;
+extern const GUID DXVA_ModeHEVC_VLD_Main;
+extern const GUID DXVA_ModeHEVC_VLD_Main10;
+static bool CanUseIntelHEVC(vlc_va_t *va)
+{
+    vlc_va_sys_t *sys = va->sys;
 
-        /* */
-        msg_Dbg(va, "Trying to use '%s' as input", mode->name);
-        UINT      output_count = 0;
-        D3DFORMAT *output_list = NULL;
-        if (FAILED(IDirectXVideoDecoderService_GetDecoderRenderTargets(sys->vs, mode->guid,
-                                                                       &output_count,
-                                                                       &output_list))) {
-            msg_Err(va, "IDirectXVideoDecoderService_GetDecoderRenderTargets failed");
-            continue;
-        }
-        for (unsigned j = 0; j < output_count; j++) {
-            const D3DFORMAT f = output_list[j];
-            const d3d_format_t *format = D3dFindFormat(f);
-            if (format) {
-                msg_Dbg(va, "%s is supported for output", format->name);
-            } else {
-                msg_Dbg(va, "%d is supported for output (%4.4s)", f, (const char*)&f);
-            }
+    D3DADAPTER_IDENTIFIER9 identifier;
+    HRESULT hr = IDirect3D9_GetAdapterIdentifier(sys->hd3d.obj, sys->d3d_dev.adapterId, 0, &identifier);
+    if (FAILED(hr))
+        return false;
+
+    if (identifier.VendorId != GPU_MANUFACTURER_INTEL)
+        return true;
+
+    return directx_va_canUseHevc( va, identifier.DeviceId );
+}
+
+static int DxSetupOutput(vlc_va_t *va, const GUID *input, const video_format_t *fmt)
+{
+    VLC_UNUSED(fmt);
+
+    if ((IsEqualGUID(input,&DXVA_ModeHEVC_VLD_Main) ||
+         IsEqualGUID(input,&DXVA_ModeHEVC_VLD_Main10)) && !CanUseIntelHEVC(va))
+        return VLC_EGENERIC;
+
+    int err = VLC_EGENERIC;
+    UINT      output_count = 0;
+    D3DFORMAT *output_list = NULL;
+    if (FAILED(IDirectXVideoDecoderService_GetDecoderRenderTargets(va->sys->dx_sys.d3ddec,
+                                                                   input,
+                                                                   &output_count,
+                                                                   &output_list))) {
+        msg_Err(va, "IDirectXVideoDecoderService_GetDecoderRenderTargets failed");
+        return VLC_EGENERIC;
+    }
+
+    for (unsigned j = 0; j < output_count; j++) {
+        const D3DFORMAT f = output_list[j];
+        const d3d9_format_t *format = D3dFindFormat(f);
+        if (format) {
+            msg_Dbg(va, "%s is supported for output", format->name);
+        } else {
+            msg_Dbg(va, "%d is supported for output (%4.4s)", f, (const char*)&f);
         }
+    }
 
-        /* */
+    /* */
+    for (unsigned pass = 0; pass < 2 && err != VLC_SUCCESS; ++pass)
+    {
         for (unsigned j = 0; d3d_formats[j].name; j++) {
-            const d3d_format_t *format = &d3d_formats[j];
+            const d3d9_format_t *format = &d3d_formats[j];
 
             /* */
             bool is_supported = false;
@@ -821,84 +554,70 @@ static int DxFindVideoServiceConversion(vlc_va_t *va, GUID *input, D3DFORMAT *ou
             }
             if (!is_supported)
                 continue;
+            if (pass == 0 && format->format != va->sys->render)
+                continue;
 
             /* We have our solution */
-            msg_Dbg(va, "Using '%s' to decode to '%s'", mode->name, format->name);
-            *input  = *mode->guid;
-            *output = format->format;
-            CoTaskMemFree(output_list);
-            CoTaskMemFree(input_list);
-            return VLC_SUCCESS;
+            msg_Dbg(va, "Using decoder output '%s'", format->name);
+            va->sys->render = format->format;
+            err = VLC_SUCCESS;
+            break;
         }
-        CoTaskMemFree(output_list);
     }
-    CoTaskMemFree(input_list);
-    return VLC_EGENERIC;
+    CoTaskMemFree(output_list);
+    return err;
 }
 
 /**
  * It creates a DXVA2 decoder using the given video format
  */
-static int DxCreateVideoDecoder(vlc_va_t *va,
-                                int codec_id, const video_format_t *fmt)
+static int DxCreateVideoDecoder(vlc_va_t *va, int codec_id,
+                                const video_format_t *fmt, unsigned surface_count)
 {
-    vlc_va_sys_t *sys = va->sys;
+    vlc_va_sys_t *p_sys = va->sys;
+    directx_sys_t *sys = &va->sys->dx_sys;
+    HRESULT hr;
 
-    /* */
-    msg_Dbg(va, "DxCreateVideoDecoder id %d %dx%d",
-            codec_id, fmt->i_width, fmt->i_height);
-
-    sys->width  = fmt->i_width;
-    sys->height = fmt->i_height;
-
-    /* Allocates all surfaces needed for the decoder */
-    sys->surface_width  = (fmt->i_width  + 15) & ~15;
-    sys->surface_height = (fmt->i_height + 15) & ~15;
-    int surface_count;
-    switch (codec_id) {
-    case AV_CODEC_ID_H264:
-        surface_count = 16 + sys->thread_count + 2;
-        break;
-    case AV_CODEC_ID_MPEG1VIDEO:
-    case AV_CODEC_ID_MPEG2VIDEO:
-        surface_count = 2 + 2;
-        break;
-    default:
-        surface_count = 2 + 1;
-        break;
-    }
-    if (surface_count > VA_DXVA2_MAX_SURFACE_COUNT)
-        return VLC_EGENERIC;
-    sys->surface_count = surface_count;
-    if (FAILED(IDirectXVideoDecoderService_CreateSurface(sys->vs,
-                                                         sys->surface_width,
-                                                         sys->surface_height,
-                                                         sys->surface_count - 1,
-                                                         sys->render,
+    hr = IDirectXVideoDecoderService_CreateSurface(sys->d3ddec,
+                                                         fmt->i_width,
+                                                         fmt->i_height,
+                                                         surface_count - 1,
+                                                         p_sys->render,
                                                          D3DPOOL_DEFAULT,
                                                          0,
                                                          DXVA2_VideoDecoderRenderTarget,
                                                          sys->hw_surface,
-                                                         NULL))) {
-        msg_Err(va, "IDirectXVideoAccelerationService_CreateSurface failed");
-        sys->surface_count = 0;
+                                                         NULL);
+    if (FAILED(hr)) {
+        msg_Err(va, "IDirectXVideoAccelerationService_CreateSurface %d failed (hr=0x%0lx)", surface_count - 1, hr);
         return VLC_EGENERIC;
     }
-    for (unsigned i = 0; i < sys->surface_count; i++) {
-        vlc_va_surface_t *surface = &sys->surface[i];
-        surface->d3d = sys->hw_surface[i];
-        surface->refcount = 0;
-        surface->order = 0;
-    }
     msg_Dbg(va, "IDirectXVideoAccelerationService_CreateSurface succeed with %d surfaces (%dx%d)",
-            sys->surface_count, fmt->i_width, fmt->i_height);
+            surface_count, fmt->i_width, fmt->i_height);
+
+    IDirect3DSurface9 *tstCrash;
+    hr = IDirectXVideoDecoderService_CreateSurface(sys->d3ddec,
+                                                         fmt->i_width,
+                                                         fmt->i_height,
+                                                         0,
+                                                         p_sys->render,
+                                                         D3DPOOL_DEFAULT,
+                                                         0,
+                                                         DXVA2_VideoDecoderRenderTarget,
+                                                         &tstCrash,
+                                                         NULL);
+    if (FAILED(hr)) {
+        msg_Err(va, "extra buffer impossible, avoid a crash (hr=0x%0lx)", hr);
+        goto error;
+    }
+    IDirect3DSurface9_Release(tstCrash);
 
     /* */
     DXVA2_VideoDesc dsc;
     ZeroMemory(&dsc, sizeof(dsc));
     dsc.SampleWidth     = fmt->i_width;
     dsc.SampleHeight    = fmt->i_height;
-    dsc.Format          = sys->render;
+    dsc.Format          = p_sys->render;
     if (fmt->i_frame_rate > 0 && fmt->i_frame_rate_base > 0) {
         dsc.InputSampleFreq.Numerator   = fmt->i_frame_rate;
         dsc.InputSampleFreq.Denominator = fmt->i_frame_rate_base;
@@ -923,14 +642,15 @@ static int DxCreateVideoDecoder(vlc_va_t *va,
     /* List all configurations available for the decoder */
     UINT                      cfg_count = 0;
     DXVA2_ConfigPictureDecode *cfg_list = NULL;
-    if (FAILED(IDirectXVideoDecoderService_GetDecoderConfigurations(sys->vs,
-                                                                    &sys->input,
-                                                                    &dsc,
-                                                                    NULL,
-                                                                    &cfg_count,
-                                                                    &cfg_list))) {
-        msg_Err(va, "IDirectXVideoDecoderService_GetDecoderConfigurations failed");
-        return VLC_EGENERIC;
+    hr = IDirectXVideoDecoderService_GetDecoderConfigurations(sys->d3ddec,
+                                                              &sys->input,
+                                                              &dsc,
+                                                              NULL,
+                                                              &cfg_count,
+                                                              &cfg_list);
+    if (FAILED(hr)) {
+        msg_Err(va, "IDirectXVideoDecoderService_GetDecoderConfigurations failed. (hr=0x%0lx)", hr);
+        goto error;
     }
     msg_Dbg(va, "we got %d decoder configurations", cfg_count);
 
@@ -951,46 +671,54 @@ static int DxCreateVideoDecoder(vlc_va_t *va,
             score = 2;
         else
             continue;
-        if (IsEqualGUID(&cfg->guidConfigBitstreamEncryption, &DXVA_NoEncrypt))
+        if (IsEqualGUID(&cfg->guidConfigBitstreamEncryption, &DXVA2_NoEncrypt))
             score += 16;
 
         if (cfg_score < score) {
-            sys->cfg = *cfg;
+            p_sys->cfg = *cfg;
             cfg_score = score;
         }
     }
     CoTaskMemFree(cfg_list);
     if (cfg_score <= 0) {
         msg_Err(va, "Failed to find a supported decoder configuration");
-        return VLC_EGENERIC;
+        goto error;
     }
 
     /* Create the decoder */
     IDirectXVideoDecoder *decoder;
-    if (FAILED(IDirectXVideoDecoderService_CreateVideoDecoder(sys->vs,
+    /* adds a reference on each decoder surface */
+    if (FAILED(IDirectXVideoDecoderService_CreateVideoDecoder(sys->d3ddec,
                                                               &sys->input,
                                                               &dsc,
-                                                              &sys->cfg,
+                                                              &p_sys->cfg,
                                                               sys->hw_surface,
-                                                              sys->surface_count,
+                                                              surface_count,
                                                               &decoder))) {
         msg_Err(va, "IDirectXVideoDecoderService_CreateVideoDecoder failed");
-        return VLC_EGENERIC;
+        goto error;
     }
     sys->decoder = decoder;
+
     msg_Dbg(va, "IDirectXVideoDecoderService_CreateVideoDecoder succeed");
     return VLC_SUCCESS;
+error:
+    for (unsigned i = 0; i < surface_count; i++)
+        IDirect3DSurface9_Release( sys->hw_surface[i] );
+    return VLC_EGENERIC;
 }
 
-static void DxDestroyVideoDecoder(vlc_va_sys_t *va)
+static void DxDestroyVideoDecoder(vlc_va_t *va)
 {
-    if (va->decoder)
-        IDirectXVideoDecoder_Release(va->decoder);
-    va->decoder = NULL;
-
-    for (unsigned i = 0; i < va->surface_count; i++)
-        IDirect3DSurface9_Release(va->surface[i].d3d);
-    va->surface_count = 0;
+    directx_sys_t *dx_sys = &va->sys->dx_sys;
+    if (dx_sys->decoder)
+    {
+        /* releases a reference on each decoder surface */
+        IDirectXVideoDecoder_Release(dx_sys->decoder);
+        dx_sys->decoder = NULL;
+        for (unsigned i = 0; i < dx_sys->va_pool.surface_count; i++)
+            IDirect3DSurface9_Release(dx_sys->hw_surface[i]);
+    }
 }
 
 static int DxResetVideoDecoder(vlc_va_t *va)
@@ -998,22 +726,3 @@ static int DxResetVideoDecoder(vlc_va_t *va)
     msg_Err(va, "DxResetVideoDecoder unimplemented");
     return VLC_EGENERIC;
 }
-
-static void DxCreateVideoConversion(vlc_va_sys_t *va)
-{
-    switch (va->render) {
-    case MAKEFOURCC('N','V','1','2'):
-    case MAKEFOURCC('I','M','C','3'):
-        va->output = MAKEFOURCC('Y','V','1','2');
-        break;
-    default:
-        va->output = va->render;
-        break;
-    }
-    CopyInitCache(&va->surface_cache, va->surface_width);
-}
-
-static void DxDestroyVideoConversion(vlc_va_sys_t *va)
-{
-    CopyCleanCache(&va->surface_cache);
-}
diff --git modules/codec/avcodec/encoder.c modules/codec/avcodec/encoder.c
index 457078a06..7ad08f051 100644
--- modules/codec/avcodec/encoder.c
+++ modules/codec/avcodec/encoder.c
@@ -32,6 +32,8 @@
 # include "config.h"
 #endif
 
+#include <math.h>
+
 #include <vlc_common.h>
 #include <vlc_aout.h>
 #include <vlc_sout.h>
@@ -41,7 +43,7 @@
 #include <vlc_cpu.h>
 
 #include <libavcodec/avcodec.h>
-#include <libavutil/audioconvert.h>
+#include <libavutil/channel_layout.h>
 
 #include "avcodec.h"
 #include "avcommon.h"
@@ -61,9 +63,6 @@
 /*****************************************************************************
  * Local prototypes
  *****************************************************************************/
-int  OpenEncoder ( vlc_object_t * );
-void CloseEncoder( vlc_object_t * );
-
 static block_t *EncodeVideo( encoder_t *, picture_t * );
 static block_t *EncodeAudio( encoder_t *, block_t * );
 
@@ -74,7 +73,7 @@ struct thread_context_t;
  *****************************************************************************/
 struct thread_context_t
 {
-    VLC_COMMON_MEMBERS
+    struct vlc_common_members obj;
 
     AVCodecContext  *p_context;
     int             (* pf_func)(AVCodecContext *c, void *arg);
@@ -89,7 +88,7 @@ struct thread_context_t
 /*****************************************************************************
  * encoder_sys_t : libavcodec encoder descriptor
  *****************************************************************************/
-struct encoder_sys_t
+typedef struct
 {
     /*
      * libavcodec properties
@@ -140,18 +139,14 @@ struct encoder_sys_t
     bool       b_hurry_up;
     bool       b_interlace, b_interlace_me;
     float      f_i_quant_factor;
-    int        i_noise_reduction;
     bool       b_mpeg4_matrix;
     bool       b_trellis;
     int        i_quality; /* for VBR */
     float      f_lumi_masking, f_dark_masking, f_p_masking, f_border_masking;
-#if (LIBAVCODEC_VERSION_MAJOR < 55)
-    int        i_luma_elim, i_chroma_elim;
-#endif
     int        i_aac_profile; /* AAC profile to use.*/
 
     AVFrame    *frame;
-};
+} encoder_sys_t;
 
 
 /* Taken from audio.c*/
@@ -198,9 +193,6 @@ static const char *const ppsz_enc_options[] = {
     "interlace", "interlace-me", "i-quant-factor", "noise-reduction", "mpeg4-matrix",
     "trellis", "qscale", "strict", "lumi-masking", "dark-masking",
     "p-masking", "border-masking",
-#if (LIBAVCODEC_VERSION_MAJOR < 55)
-    "luma-elim-threshold", "chroma-elim-threshold",
-#endif
     "aac-profile", "options",
     NULL
 };
@@ -236,15 +228,11 @@ static const uint16_t mpeg4_default_non_intra_matrix[64] = {
  23, 24, 25, 27, 28, 30, 31, 33,
 };
 
-#if LIBAVUTIL_VERSION_CHECK( 51, 27, 2, 46, 100 )
 static const int DEFAULT_ALIGN = 0;
-#else
-static const int DEFAULT_ALIGN = 1;
-#endif
 
 
 /*****************************************************************************
- * OpenEncoder: probe the encoder
+ * InitVideoEnc: probe the encoder
  *****************************************************************************/
 static void probe_video_frame_rate( encoder_t *p_enc, AVCodecContext *p_context, AVCodec *p_codec )
 {
@@ -256,7 +244,7 @@ static void probe_video_frame_rate( encoder_t *p_enc, AVCodecContext *p_context,
     p_context->time_base.den = p_enc->fmt_in.video.i_frame_rate_base ? p_enc->fmt_in.video.i_frame_rate :
                                   ( p_enc->fmt_out.i_codec == VLC_CODEC_MP4V ? 25 : CLOCK_FREQ );
 
-    msg_Dbg( p_enc, "Time base for probing setted to %d/%d", p_context->time_base.num, p_context->time_base.den );
+    msg_Dbg( p_enc, "Time base for probing set to %d/%d", p_context->time_base.num, p_context->time_base.den );
     if( p_codec->supported_framerates )
     {
         /* We are finding fps values so 1/time_base */
@@ -285,63 +273,70 @@ static void probe_video_frame_rate( encoder_t *p_enc, AVCodecContext *p_context,
     msg_Dbg( p_enc, "Time base set to %d/%d", p_context->time_base.num, p_context->time_base.den );
 }
 
-int OpenEncoder( vlc_object_t *p_this )
+static void add_av_option_int( encoder_t *p_enc, AVDictionary** pp_dict, const char* psz_name, int i_value )
+{
+    char buff[32];
+    if ( snprintf( buff, sizeof(buff), "%d", i_value ) < 0 )
+        return;
+    if( av_dict_set( pp_dict, psz_name, buff, 0 ) < 0 )
+        msg_Warn( p_enc, "Failed to set encoder option %s", psz_name );
+}
+
+static void add_av_option_float( encoder_t *p_enc, AVDictionary** pp_dict, const char* psz_name, float f_value )
+{
+    char buff[128];
+    if ( snprintf( buff, sizeof(buff), "%f", f_value ) < 0 )
+        return;
+    if( av_dict_set( pp_dict, psz_name, buff, 0 ) < 0 )
+        msg_Warn( p_enc, "Failed to set encoder option %s", psz_name );
+}
+
+int InitVideoEnc( vlc_object_t *p_this )
 {
     encoder_t *p_enc = (encoder_t *)p_this;
     encoder_sys_t *p_sys;
     AVCodecContext *p_context;
     AVCodec *p_codec = NULL;
     unsigned i_codec_id;
-    int i_cat;
     const char *psz_namecodec;
     float f_val;
     char *psz_val;
 
+    msg_Dbg( p_this, "using %s %s", AVPROVIDER(LIBAVCODEC), LIBAVCODEC_IDENT );
+
     /* Initialization must be done before avcodec_find_encoder() */
     vlc_init_avcodec(p_this);
 
     config_ChainParse( p_enc, ENC_CFG_PREFIX, ppsz_enc_options, p_enc->p_cfg );
 
-    if( p_enc->fmt_out.i_codec == VLC_CODEC_MP1V )
-    {
-        i_cat = VIDEO_ES;
-        i_codec_id = AV_CODEC_ID_MPEG1VIDEO;
-        psz_namecodec = "MPEG-1 video";
-    }
-    else if( !GetFfmpegCodec( p_enc->fmt_out.i_codec, &i_cat, &i_codec_id,
-                             &psz_namecodec ) )
-    {
-        if( FindFfmpegChroma( p_enc->fmt_out.i_codec ) == PIX_FMT_NONE )
-            return VLC_EGENERIC; /* handed chroma output */
-
-        i_cat      = VIDEO_ES;
-        i_codec_id = AV_CODEC_ID_RAWVIDEO;
-        psz_namecodec = "Raw video";
-    }
-
-    if( i_cat == UNKNOWN_ES )
-        return VLC_EGENERIC;
-
-    if( p_enc->fmt_out.i_cat == VIDEO_ES && i_cat != VIDEO_ES )
-    {
-        msg_Err( p_enc, "\"%s\" is not a video encoder", psz_namecodec );
-        dialog_Fatal( p_enc, _("Streaming / Transcoding failed"),
-                        _("\"%s\" is no video encoder."), psz_namecodec );
-        return VLC_EGENERIC;
-    }
-
-    if( p_enc->fmt_out.i_cat == AUDIO_ES && i_cat != AUDIO_ES )
+    switch( p_enc->fmt_out.i_cat )
     {
-        msg_Err( p_enc, "\"%s\" is not an audio encoder", psz_namecodec );
-        dialog_Fatal( p_enc, _("Streaming / Transcoding failed"),
-                        _("\"%s\" is no audio encoder."), psz_namecodec );
-        return VLC_EGENERIC;
-    }
+        case VIDEO_ES:
+            if( p_enc->fmt_out.i_codec == VLC_CODEC_MP1V )
+            {
+                i_codec_id = AV_CODEC_ID_MPEG1VIDEO;
+                psz_namecodec = "MPEG-1 video";
+                break;
+            }
+            if( GetFfmpegCodec( VIDEO_ES, p_enc->fmt_out.i_codec, &i_codec_id,
+                                &psz_namecodec ) )
+                break;
+            if( FindFfmpegChroma( p_enc->fmt_out.i_codec ) != AV_PIX_FMT_NONE )
+            {
+                i_codec_id = AV_CODEC_ID_RAWVIDEO;
+                psz_namecodec = "Raw video";
+                break;
+            }
+            return VLC_EGENERIC;
 
-    if( p_enc->fmt_out.i_cat == SPU_ES )
-    {
-        /* We don't support subtitle encoding */
-        return VLC_EGENERIC;
+        case AUDIO_ES:
+            if( GetFfmpegCodec( AUDIO_ES, p_enc->fmt_out.i_codec, &i_codec_id,
+                                &psz_namecodec ) )
+                break;
+            /* fall through */
+        default:
+            /* We don't support subtitle encoding */
+            return VLC_EGENERIC;
     }
 
     char *psz_encoder = var_GetString( p_this, ENC_CFG_PREFIX "codec" );
@@ -349,12 +344,15 @@ int OpenEncoder( vlc_object_t *p_this )
     {
         p_codec = avcodec_find_encoder_by_name( psz_encoder );
         if( !p_codec )
+        {
             msg_Err( p_this, "Encoder `%s' not found", psz_encoder );
+            return VLC_EGENERIC;
+        }
         else if( p_codec->id != i_codec_id )
         {
             msg_Err( p_this, "Encoder `%s' can't handle %4.4s",
                     psz_encoder, (char*)&p_enc->fmt_out.i_codec );
-            p_codec = NULL;
+            return VLC_EGENERIC;
         }
     }
     free( psz_encoder );
@@ -367,7 +365,7 @@ int OpenEncoder( vlc_object_t *p_this )
 "*** Please check with your Libav/FFmpeg packager. ***\n"
 "*** This is NOT a VLC media player issue.   ***", psz_namecodec );
 
-        dialog_Fatal( p_enc, _("Streaming / Transcoding failed"), _(
+        vlc_dialog_display_error( p_enc, _("Streaming / Transcoding failed"), _(
 /* I have had enough of all these MPEG-3 transcoding bug reports.
  * Downstream packager, you had better not patch this out, or I will be really
  * annoyed. Think about it - you don't want to fork the VLC translation files,
@@ -395,6 +393,11 @@ int OpenEncoder( vlc_object_t *p_this )
     p_sys->i_buffer_out = 0;
 
     p_context = avcodec_alloc_context3(p_codec);
+    if( unlikely(p_context == NULL) )
+    {
+        free( p_sys );
+        return VLC_ENOMEM;
+    }
     p_sys->p_context = p_context;
     p_sys->p_context->codec_id = p_sys->p_codec->id;
     p_context->thread_type = 0;
@@ -409,25 +412,18 @@ int OpenEncoder( vlc_object_t *p_this )
     p_sys->b_pre_me = var_GetBool( p_enc, ENC_CFG_PREFIX "pre-me" );
     p_sys->b_hurry_up = var_GetBool( p_enc, ENC_CFG_PREFIX "hurry-up" );
 
-    if( p_sys->b_hurry_up )
-    {
-        /* hurry up mode needs noise reduction, even small */
-        p_sys->i_noise_reduction = 1;
-    }
-
     p_sys->i_rc_buffer_size = var_GetInteger( p_enc, ENC_CFG_PREFIX "rc-buffer-size" );
     p_sys->f_rc_buffer_aggressivity = var_GetFloat( p_enc, ENC_CFG_PREFIX "rc-buffer-aggressivity" );
     p_sys->f_i_quant_factor = var_GetFloat( p_enc, ENC_CFG_PREFIX "i-quant-factor" );
-    p_sys->i_noise_reduction = var_GetInteger( p_enc, ENC_CFG_PREFIX "noise-reduction" );
     p_sys->b_mpeg4_matrix = var_GetBool( p_enc, ENC_CFG_PREFIX "mpeg4-matrix" );
 
     f_val = var_GetFloat( p_enc, ENC_CFG_PREFIX "qscale" );
 
     p_sys->i_quality = 0;
-    if( f_val < 0.01 || f_val > 255.0 )
-        f_val = 0;
+    if( f_val < .01f || f_val > 255.f )
+        f_val = 0.f;
     else
-        p_sys->i_quality = (int)(FF_QP2LAMBDA * f_val + 0.5);
+        p_sys->i_quality = lroundf(FF_QP2LAMBDA * f_val);
 
     psz_val = var_GetString( p_enc, ENC_CFG_PREFIX "hq" );
     p_sys->i_hq = FF_MB_DECISION_RD;
@@ -456,10 +452,6 @@ int OpenEncoder( vlc_object_t *p_this )
     p_sys->f_dark_masking = var_GetFloat( p_enc, ENC_CFG_PREFIX "dark-masking" );
     p_sys->f_p_masking = var_GetFloat( p_enc, ENC_CFG_PREFIX "p-masking" );
     p_sys->f_border_masking = var_GetFloat( p_enc, ENC_CFG_PREFIX "border-masking" );
-#if (LIBAVCODEC_VERSION_MAJOR < 55)
-    p_sys->i_luma_elim = var_GetInteger( p_enc, ENC_CFG_PREFIX "luma-elim-threshold" );
-    p_sys->i_chroma_elim = var_GetInteger( p_enc, ENC_CFG_PREFIX "chroma-elim-threshold" );
-#endif
 
     psz_val = var_GetString( p_enc, ENC_CFG_PREFIX "aac-profile" );
     /* libavcodec uses faac encoder atm, and it has issues with
@@ -475,7 +467,6 @@ int OpenEncoder( vlc_object_t *p_this )
             p_sys->i_aac_profile = FF_PROFILE_AAC_SSR;
         else if( !strncmp( psz_val, "ltp", 3 ) )
             p_sys->i_aac_profile = FF_PROFILE_AAC_LTP;
-#if LIBAVCODEC_VERSION_CHECK( 54, 19, 0, 35, 100 )
 /* These require libavcodec with libfdk-aac */
         else if( !strncmp( psz_val, "hev2", 4 ) )
             p_sys->i_aac_profile = FF_PROFILE_AAC_HE_V2;
@@ -485,7 +476,6 @@ int OpenEncoder( vlc_object_t *p_this )
             p_sys->i_aac_profile = FF_PROFILE_AAC_LD;
         else if( !strncmp( psz_val, "eld", 3 ) )
             p_sys->i_aac_profile = FF_PROFILE_AAC_ELD;
-#endif
         else
         {
             msg_Warn( p_enc, "unknown AAC profile requested, setting it to low" );
@@ -493,6 +483,7 @@ int OpenEncoder( vlc_object_t *p_this )
         }
     }
     free( psz_val );
+    AVDictionary *options = NULL;
 
     if( p_enc->fmt_in.i_cat == VIDEO_ES )
     {
@@ -500,6 +491,7 @@ int OpenEncoder( vlc_object_t *p_this )
         {
             msg_Warn( p_enc, "invalid size %ix%i", p_enc->fmt_in.video.i_visible_width,
                       p_enc->fmt_in.video.i_visible_height );
+            avcodec_free_context( &p_context );
             free( p_sys );
             return VLC_EGENERIC;
         }
@@ -510,6 +502,7 @@ int OpenEncoder( vlc_object_t *p_this )
         p_context->height = p_enc->fmt_in.video.i_visible_height;
 
         probe_video_frame_rate( p_enc, p_context, p_codec );
+        set_video_color_settings( &p_enc->fmt_in.video, p_context );
 
         /* Defaults from ffmpeg.c */
         p_context->qblur = 0.5;
@@ -522,21 +515,16 @@ int OpenEncoder( vlc_object_t *p_this )
         p_context->lumi_masking = p_sys->f_lumi_masking;
         p_context->dark_masking = p_sys->f_dark_masking;
         p_context->p_masking = p_sys->f_p_masking;
-        p_context->border_masking = p_sys->f_border_masking;
-#if (LIBAVCODEC_VERSION_MAJOR < 55)
-        p_context->luma_elim_threshold = p_sys->i_luma_elim;
-        p_context->chroma_elim_threshold = p_sys->i_chroma_elim;
-#endif
+        add_av_option_float( p_enc, &options, "border_mask", p_sys->f_border_masking );
 
         if( p_sys->i_key_int > 0 )
             p_context->gop_size = p_sys->i_key_int;
         p_context->max_b_frames =
             VLC_CLIP( p_sys->i_b_frames, 0, FF_MAX_B_FRAMES );
-        p_context->b_frame_strategy = 0;
         if( !p_context->max_b_frames  &&
             (  p_enc->fmt_out.i_codec == VLC_CODEC_MPGV ||
                p_enc->fmt_out.i_codec == VLC_CODEC_MP2V ) )
-            p_context->flags |= CODEC_FLAG_LOW_DELAY;
+            p_context->flags |= AV_CODEC_FLAG_LOW_DELAY;
 
         av_reduce( &p_context->sample_aspect_ratio.num,
                    &p_context->sample_aspect_ratio.den,
@@ -555,21 +543,36 @@ int OpenEncoder( vlc_object_t *p_this )
 
         if( p_codec->pix_fmts )
         {
+            static const enum AVPixelFormat vlc_pix_fmts[] = {
+                AV_PIX_FMT_YUV420P,
+                AV_PIX_FMT_NV12,
+                AV_PIX_FMT_RGB24,
+            };
+            bool found = false;
             const enum PixelFormat *p = p_codec->pix_fmts;
-            for( ; *p != -1; p++ )
+            for( ; !found && *p != -1; p++ )
             {
-                if( *p == p_context->pix_fmt ) break;
+                for( size_t i = 0; i < ARRAY_SIZE(vlc_pix_fmts); ++i )
+                {
+                    if( *p == vlc_pix_fmts[i] )
+                    {
+                        found = true;
+                        p_context->pix_fmt = *p;
+                        break;
+                    }
+                }
             }
-            if( *p == -1 ) p_context->pix_fmt = p_codec->pix_fmts[0];
+            if (!found) p_context->pix_fmt = p_codec->pix_fmts[0];
             GetVlcChroma( &p_enc->fmt_in.video, p_context->pix_fmt );
             p_enc->fmt_in.i_codec = p_enc->fmt_in.video.i_chroma;
         }
 
 
-        if ( p_sys->f_i_quant_factor != 0.0 )
+        if ( p_sys->f_i_quant_factor != 0.f )
             p_context->i_quant_factor = p_sys->f_i_quant_factor;
 
-        p_context->noise_reduction = p_sys->i_noise_reduction;
+        int nr = var_GetInteger( p_enc, ENC_CFG_PREFIX "noise-reduction" );
+        add_av_option_int( p_enc, &options, "noise_reduction", nr );
 
         if ( p_sys->b_mpeg4_matrix )
         {
@@ -579,7 +582,7 @@ int OpenEncoder( vlc_object_t *p_this )
 
         if ( p_sys->b_pre_me )
         {
-            p_context->pre_me = 1;
+            add_av_option_int( p_enc, &options, "mepre", 1 );
             p_context->me_pre_cmp = FF_CMP_CHROMA;
         }
 
@@ -594,16 +597,16 @@ int OpenEncoder( vlc_object_t *p_this )
             }
             else
             {
-                p_context->flags |= CODEC_FLAG_INTERLACED_DCT;
+                p_context->flags |= AV_CODEC_FLAG_INTERLACED_DCT;
                 if ( p_sys->b_interlace_me )
-                    p_context->flags |= CODEC_FLAG_INTERLACED_ME;
+                    p_context->flags |= AV_CODEC_FLAG_INTERLACED_ME;
             }
         }
 
         p_context->trellis = p_sys->b_trellis;
 
         if ( p_sys->i_qmin > 0 && p_sys->i_qmin == p_sys->i_qmax )
-            p_context->flags |= CODEC_FLAG_QSCALE;
+            p_context->flags |= AV_CODEC_FLAG_QSCALE;
         /* These codecs cause libavcodec to exit if thread_count is > 1.
            See libavcodec/mpegvideo_enc.c:MPV_encode_init and
            libavcodec/svq3.c , WMV2 calls MPV_encode_init also.
@@ -639,12 +642,14 @@ int OpenEncoder( vlc_object_t *p_this )
         if( p_sys->i_qmin > 0 )
         {
             p_context->qmin = p_sys->i_qmin;
-            p_context->mb_lmin = p_context->lmin = p_sys->i_qmin * FF_QP2LAMBDA;
+            p_context->mb_lmin = p_sys->i_qmin * FF_QP2LAMBDA;
+            add_av_option_int( p_enc, &options, "lmin", p_context->mb_lmin);
         }
         if( p_sys->i_qmax > 0 )
         {
             p_context->qmax = p_sys->i_qmax;
-            p_context->mb_lmax = p_context->lmax = p_sys->i_qmax * FF_QP2LAMBDA;
+            p_context->mb_lmax = p_sys->i_qmax * FF_QP2LAMBDA;
+            add_av_option_int( p_enc, &options, "lmax", p_context->mb_lmax);
         }
         p_context->max_qdiff = 3;
 
@@ -652,12 +657,12 @@ int OpenEncoder( vlc_object_t *p_this )
 
         if( p_sys->i_quality && !p_enc->fmt_out.i_bitrate )
         {
-            p_context->flags |= CODEC_FLAG_QSCALE;
+            p_context->flags |= AV_CODEC_FLAG_QSCALE;
             p_context->global_quality = p_sys->i_quality;
         }
         else
         {
-            p_context->rc_qsquish = 1.0;
+            av_dict_set(&options, "qsquish", "1.0", 0);
             /* Default to 1/2 second buffer for given bitrate unless defined otherwise*/
             if( !p_sys->i_rc_buffer_size )
             {
@@ -671,14 +676,11 @@ int OpenEncoder( vlc_object_t *p_this )
             /* This is from ffmpeg's ffmpeg.c : */
             p_context->rc_initial_buffer_occupancy
                 = p_sys->i_rc_buffer_size * 3/4;
-            p_context->rc_buffer_aggressivity = p_sys->f_rc_buffer_aggressivity;
+            add_av_option_float( p_enc, &options, "rc_buffer_aggressivity", p_sys->f_rc_buffer_aggressivity );
         }
     }
     else if( p_enc->fmt_in.i_cat == AUDIO_ES )
     {
-        /* work around bug in libmp3lame encoding */
-        if( i_codec_id == AV_CODEC_ID_MP3 && p_enc->fmt_out.audio.i_channels  > 2 )
-            p_enc->fmt_out.audio.i_channels = 2;
         p_context->codec_type  = AVMEDIA_TYPE_AUDIO;
         p_context->sample_fmt  = p_codec->sample_fmts ?
                                     p_codec->sample_fmts[0] :
@@ -739,7 +741,7 @@ int OpenEncoder( vlc_object_t *p_this )
          * Copied from audio.c
          */
         const unsigned i_order_max = 8 * sizeof(p_context->channel_layout);
-        uint32_t pi_order_dst[AOUT_CHAN_MAX];
+        uint32_t pi_order_dst[AOUT_CHAN_MAX] = { 0 };
         int i_channels_src = 0;
 
         if( p_context->channel_layout )
@@ -808,21 +810,22 @@ int OpenEncoder( vlc_object_t *p_this )
             if( !var_GetInteger( p_enc, ENC_CFG_PREFIX "qmin" ) )
             {
                 p_context->qmin = 10;
-                p_context->mb_lmin = p_context->lmin = 10 * FF_QP2LAMBDA;
+                p_context->mb_lmin = 10 * FF_QP2LAMBDA;
+                add_av_option_int( p_enc, &options, "lmin", p_context->mb_lmin );
             }
 
             if( !var_GetInteger( p_enc, ENC_CFG_PREFIX "qmax" ) )
             {
                 p_context->qmax = 42;
-                p_context->mb_lmax = p_context->lmax = 42 * FF_QP2LAMBDA;
+                p_context->mb_lmax = 42 * FF_QP2LAMBDA;
+                add_av_option_int( p_enc, &options, "lmax", p_context->mb_lmax );
             }
 
-            } else {
-            if( !var_GetInteger( p_enc, ENC_CFG_PREFIX "qmin" ) )
-            {
+        } else if( !var_GetInteger( p_enc, ENC_CFG_PREFIX "qmin" ) )
+        {
                 p_context->qmin = 1;
-                p_context->mb_lmin = p_context->lmin = FF_QP2LAMBDA;
-            }
+                p_context->mb_lmin = FF_QP2LAMBDA;
+                add_av_option_int( p_enc, &options, "lmin", p_context->mb_lmin );
         }
 
 
@@ -846,7 +849,7 @@ int OpenEncoder( vlc_object_t *p_this )
     /* Make sure we get extradata filled by the encoder */
     p_context->extradata_size = 0;
     p_context->extradata = NULL;
-    p_context->flags |= CODEC_FLAG_GLOBAL_HEADER;
+    p_context->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
 
     if( p_enc->i_threads >= 1)
         p_context->thread_count = p_enc->i_threads;
@@ -855,10 +858,10 @@ int OpenEncoder( vlc_object_t *p_this )
 
     int ret;
     char *psz_opts = var_InheritString(p_enc, ENC_CFG_PREFIX "options");
-    AVDictionary *options = NULL;
-    if (psz_opts && *psz_opts)
-        options = vlc_av_get_options(psz_opts);
-    free(psz_opts);
+    if (psz_opts) {
+        vlc_av_get_options(psz_opts, &options);
+        free(psz_opts);
+    }
 
     vlc_avcodec_lock();
     ret = avcodec_open2( p_context, p_codec, options ? &options : NULL );
@@ -890,9 +893,9 @@ errmsg:
             if (likely((unsigned)p_enc->fmt_in.i_cat < sizeof (types) / sizeof (types[0])))
                 type = types[p_enc->fmt_in.i_cat];
             msg_Err( p_enc, "cannot open %4.4s %s encoder", fcc.txt, type );
-            dialog_Fatal( p_enc, _("Streaming / Transcoding failed"),
-                          _("VLC could not open the %4.4s %s encoder."),
-                          fcc.txt, vlc_gettext(type) );
+            vlc_dialog_display_error( p_enc, _("Streaming / Transcoding failed"),
+                _("VLC could not open the %4.4s %s encoder."),
+                fcc.txt, vlc_gettext(type) );
             av_dict_free(&options);
             goto error;
         }
@@ -900,7 +903,14 @@ errmsg:
         if( p_context->channels > 2 )
         {
             p_context->channels = 2;
-            p_enc->fmt_in.audio.i_channels = 2; // FIXME
+            p_context->channel_layout = channel_mask[p_context->channels][1];
+
+            /* Change fmt_in in order to ask for a channels conversion */
+            p_enc->fmt_in.audio.i_channels =
+            p_enc->fmt_out.audio.i_channels = 2;
+            p_enc->fmt_in.audio.i_physical_channels =
+            p_enc->fmt_out.audio.i_physical_channels = AOUT_CHANS_STEREO;
+            p_sys->i_channels_to_reorder = 0;
             msg_Warn( p_enc, "stereo mode selected (codec limitation)" );
         }
 
@@ -915,10 +925,11 @@ errmsg:
 
             if ( i_frequency == 6 )
             {
-                msg_Err( p_enc, "MPEG audio doesn't support frequency=%d",
+                msg_Warn( p_enc, "MPEG audio doesn't support frequency=%d",
                         fmt->audio.i_rate );
-                av_dict_free(&options);
-                goto error;
+                /* Fallback to 44100 hz */
+                p_context->sample_rate = p_enc->fmt_in.audio.i_rate =
+                p_enc->fmt_out.audio.i_rate = 44100;
             }
 
             for ( i = 1; i < 14; i++ )
@@ -983,7 +994,7 @@ errmsg:
         }
     }
 
-    p_context->flags &= ~CODEC_FLAG_GLOBAL_HEADER;
+    p_context->flags &= ~AV_CODEC_FLAG_GLOBAL_HEADER;
 
     if( p_enc->fmt_in.i_cat == AUDIO_ES )
     {
@@ -993,7 +1004,7 @@ errmsg:
         p_sys->i_sample_bytes = (p_enc->fmt_in.audio.i_bitspersample / 8);
         p_sys->i_frame_size = p_context->frame_size > 1 ?
                                     p_context->frame_size :
-                                    FF_MIN_BUFFER_SIZE;
+                                    AV_INPUT_BUFFER_MIN_SIZE;
         p_sys->i_buffer_out = av_samples_get_buffer_size(NULL,
                 p_sys->p_context->channels, p_sys->i_frame_size,
                 p_sys->p_context->sample_fmt, DEFAULT_ALIGN);
@@ -1017,7 +1028,7 @@ errmsg:
         }
     }
 
-    p_sys->frame = avcodec_alloc_frame();
+    p_sys->frame = av_frame_alloc();
     if( !p_sys->frame )
     {
         goto error;
@@ -1033,11 +1044,11 @@ error:
     free( p_enc->fmt_out.p_extra );
     av_free( p_sys->p_buffer );
     av_free( p_sys->p_interleave_buf );
+    avcodec_free_context( &p_context );
     free( p_sys );
     return VLC_ENOMEM;
 }
 
-#if (LIBAVCODEC_VERSION_MAJOR >= 54)
 typedef struct
 {
     block_t self;
@@ -1048,19 +1059,25 @@ static void vlc_av_packet_Release(block_t *block)
 {
     vlc_av_packet_t *b = (void *) block;
 
-    av_free_packet(&b->packet);
+    av_packet_unref(&b->packet);
     free(b);
 }
 
 static block_t *vlc_av_packet_Wrap(AVPacket *packet, mtime_t i_length, AVCodecContext *context )
 {
+    if ( packet->data == NULL &&
+         packet->flags == 0 &&
+         packet->pts == AV_NOPTS_VALUE &&
+         packet->dts == AV_NOPTS_VALUE )
+        return NULL; /* totally empty AVPacket */
+
     vlc_av_packet_t *b = malloc( sizeof( *b ) );
     if( unlikely(b == NULL) )
         return NULL;
 
     block_t *p_block = &b->self;
 
-    block_Init(p_block, packet->data, packet->size);
+    block_Init( p_block, packet->data, packet->size );
     p_block->i_nb_samples = 0;
     p_block->pf_release = vlc_av_packet_Release;
     b->packet = *packet;
@@ -1070,12 +1087,76 @@ static block_t *vlc_av_packet_Wrap(AVPacket *packet, mtime_t i_length, AVCodecCo
     p_block->i_dts = packet->dts;
     if( unlikely( packet->flags & AV_PKT_FLAG_CORRUPT ) )
         p_block->i_flags |= BLOCK_FLAG_CORRUPTED;
+    if( packet->flags & AV_PKT_FLAG_KEY )
+        p_block->i_flags |= BLOCK_FLAG_TYPE_I;
     p_block->i_pts = p_block->i_pts * CLOCK_FREQ * context->time_base.num / context->time_base.den;
     p_block->i_dts = p_block->i_dts * CLOCK_FREQ * context->time_base.num / context->time_base.den;
 
     return p_block;
 }
-#endif
+
+static void check_hurry_up( encoder_sys_t *p_sys, AVFrame *frame, encoder_t *p_enc )
+{
+    mtime_t current_date = mdate();
+
+    if ( current_date + HURRY_UP_GUARD3 > frame->pts )
+    {
+        p_sys->p_context->mb_decision = FF_MB_DECISION_SIMPLE;
+        p_sys->p_context->trellis = 0;
+        msg_Dbg( p_enc, "hurry up mode 3" );
+    }
+    else
+    {
+        p_sys->p_context->mb_decision = p_sys->i_hq;
+
+        if ( current_date + HURRY_UP_GUARD2 > frame->pts )
+        {
+            p_sys->p_context->trellis = 0;
+            msg_Dbg( p_enc, "hurry up mode 2" );
+        }
+        else
+        {
+            p_sys->p_context->trellis = p_sys->b_trellis;
+        }
+    }
+
+    if ( current_date + HURRY_UP_GUARD1 > frame->pts )
+    {
+        frame->pict_type = AV_PICTURE_TYPE_P;
+        /* msg_Dbg( p_enc, "hurry up mode 1 %lld", current_date + HURRY_UP_GUARD1 - frame.pts ); */
+    }
+}
+
+static block_t *encode_avframe( encoder_t *p_enc, encoder_sys_t *p_sys, AVFrame *frame )
+{
+    AVPacket av_pkt;
+    av_pkt.data = NULL;
+    av_pkt.size = 0;
+
+    av_init_packet( &av_pkt );
+
+    int ret = avcodec_send_frame( p_sys->p_context, frame );
+    if( frame && ret != 0 && ret != AVERROR(EAGAIN) )
+    {
+        msg_Warn( p_enc, "cannot send one frame to encoder %d", ret );
+        return NULL;
+    }
+    ret = avcodec_receive_packet( p_sys->p_context, &av_pkt );
+    if( ret != 0 && ret != AVERROR(EAGAIN) )
+    {
+        msg_Warn( p_enc, "cannot encode one frame" );
+        return NULL;
+    }
+
+    block_t *p_block = vlc_av_packet_Wrap( &av_pkt,
+            av_pkt.duration / p_sys->p_context->time_base.den, p_sys->p_context );
+    if( unlikely(p_block == NULL) )
+    {
+        av_packet_unref( &av_pkt );
+        return NULL;
+    }
+    return p_block;
+}
 
 /****************************************************************************
  * EncodeVideo: the whole thing
@@ -1088,7 +1169,8 @@ static block_t *EncodeVideo( encoder_t *p_enc, picture_t *p_pict )
     AVFrame *frame = NULL;
     if( likely(p_pict) ) {
         frame = p_sys->frame;
-        avcodec_get_frame_defaults( frame );
+        av_frame_unref( frame );
+
         for( i_plane = 0; i_plane < p_pict->i_planes; i_plane++ )
         {
             p_sys->frame->data[i_plane] = p_pict->p[i_plane].p_pixels;
@@ -1102,53 +1184,23 @@ static block_t *EncodeVideo( encoder_t *p_enc, picture_t *p_pict )
         frame->interlaced_frame = !p_pict->b_progressive;
         frame->top_field_first = !!p_pict->b_top_field_first;
 
+        frame->format = p_sys->p_context->pix_fmt;
+        frame->width = p_sys->p_context->width;
+        frame->height = p_sys->p_context->height;
+
         /* Set the pts of the frame being encoded
          * avcodec likes pts to be in time_base units
          * frame number */
-        if( likely( p_pict->date > VLC_TS_INVALID ) )
+        if( likely( p_pict->date != VLC_TS_INVALID ) )
             frame->pts = p_pict->date * p_sys->p_context->time_base.den /
                           CLOCK_FREQ / p_sys->p_context->time_base.num;
         else
             frame->pts = AV_NOPTS_VALUE;
 
         if ( p_sys->b_hurry_up && frame->pts != AV_NOPTS_VALUE )
-        {
-            mtime_t current_date = mdate();
-
-            if ( current_date + HURRY_UP_GUARD3 > frame->pts )
-            {
-                p_sys->p_context->mb_decision = FF_MB_DECISION_SIMPLE;
-                p_sys->p_context->trellis = 0;
-                msg_Dbg( p_enc, "hurry up mode 3" );
-            }
-            else
-            {
-                p_sys->p_context->mb_decision = p_sys->i_hq;
-
-                if ( current_date + HURRY_UP_GUARD2 > frame->pts )
-                {
-                    p_sys->p_context->trellis = 0;
-                    p_sys->p_context->noise_reduction = p_sys->i_noise_reduction
-                        + (HURRY_UP_GUARD2 + current_date - frame->pts) / 500;
-                    msg_Dbg( p_enc, "hurry up mode 2" );
-                }
-                else
-                {
-                    p_sys->p_context->trellis = p_sys->b_trellis;
+            check_hurry_up( p_sys, frame, p_enc );
 
-                    p_sys->p_context->noise_reduction =
-                       p_sys->i_noise_reduction;
-                }
-            }
-
-            if ( current_date + HURRY_UP_GUARD1 > frame->pts )
-            {
-                frame->pict_type = AV_PICTURE_TYPE_P;
-                /* msg_Dbg( p_enc, "hurry up mode 1 %lld", current_date + HURRY_UP_GUARD1 - frame.pts ); */
-            }
-        }
-
-        if ( frame->pts != AV_NOPTS_VALUE && frame->pts != 0 )
+        if ( ( frame->pts != AV_NOPTS_VALUE ) && ( frame->pts != VLC_TS_INVALID ) )
         {
             if ( p_sys->i_last_pts == frame->pts )
             {
@@ -1170,171 +1222,45 @@ static block_t *EncodeVideo( encoder_t *p_enc, picture_t *p_pict )
         frame->quality = p_sys->i_quality;
     }
 
-#if (LIBAVCODEC_VERSION_MAJOR >= 54)
-    AVPacket av_pkt;
-    av_pkt.data = NULL;
-    av_pkt.size = 0;
-    int is_data;
-
-    av_init_packet( &av_pkt );
-
-    if( avcodec_encode_video2( p_sys->p_context, &av_pkt, frame, &is_data ) < 0
-     || is_data == 0 )
-    {
-        return NULL;
-    }
-
-    block_t *p_block = vlc_av_packet_Wrap( &av_pkt,
-            av_pkt.duration / p_sys->p_context->time_base.den, p_sys->p_context );
-    if( unlikely(p_block == NULL) )
-    {
-        av_free_packet( &av_pkt );
-        return NULL;
-    }
-
-#else
-    /* Initialize the video output buffer the first time.
-     * This is done here instead of OpenEncoder() because we need the actual
-     * bits_per_pixel value, without having to assume anything.
-     */
-    const int bitsPerPixel = p_enc->fmt_out.video.i_bits_per_pixel ?
-                         p_enc->fmt_out.video.i_bits_per_pixel :
-                         p_sys->p_context->bits_per_coded_sample ?
-                         p_sys->p_context->bits_per_coded_sample :
-                         24;
-    unsigned blocksize = __MAX( FF_MIN_BUFFER_SIZE, ( bitsPerPixel * p_sys->p_context->height * p_sys->p_context->width ) / 8 + 200 );
-    if( p_enc->fmt_out.i_codec == VLC_CODEC_TIFF )
-    {
-        blocksize = 2 * blocksize +
-            4 * p_sys->p_context->height; /* space for strip sizes */
-    }
-    block_t *p_block = block_Alloc( blocksize );
-    if( unlikely(p_block == NULL) )
-        return NULL;
-
-    int i_out = avcodec_encode_video( p_sys->p_context, p_block->p_buffer,
-                                      p_block->i_buffer, frame );
-    if( i_out <= 0 )
-    {
-        block_Release( p_block );
-        return NULL;
-    }
-
-    p_block->i_buffer = i_out;
-
-    /* FIXME, 3-2 pulldown is not handled correctly */
-    p_block->i_length = INT64_C(1000000) *
-        p_enc->fmt_in.video.i_frame_rate_base /
-            p_enc->fmt_in.video.i_frame_rate;
+    block_t *p_block = encode_avframe( p_enc, p_sys, frame );
 
-    if( !p_sys->p_context->max_b_frames || !p_sys->p_context->delay )
+    if( p_block )
     {
-        /* No delay -> output pts == input pts */
-        if( p_pict )
-            p_block->i_dts = p_pict->date;
-        p_block->i_pts = p_block->i_dts;
-    }
-    else if( p_sys->p_context->coded_frame->pts != AV_NOPTS_VALUE &&
-        p_sys->p_context->coded_frame->pts != 0 &&
-        p_sys->i_buggy_pts_detect != p_sys->p_context->coded_frame->pts )
-    {
-        p_sys->i_buggy_pts_detect = p_sys->p_context->coded_frame->pts;
-        p_block->i_pts = p_sys->p_context->coded_frame->pts;
-
-        if( p_sys->p_context->coded_frame->pict_type != AV_PICTURE_TYPE_I &&
-            p_sys->p_context->coded_frame->pict_type != AV_PICTURE_TYPE_P )
-        {
-            p_block->i_dts = p_block->i_pts;
-        }
-        else
-        {
-            if( p_sys->i_last_ref_pts )
-            {
-                p_block->i_dts = p_sys->i_last_ref_pts;
-            }
-            else
-            {
-                /* Let's put something sensible */
-                p_block->i_dts = p_block->i_pts;
-            }
-
-            p_sys->i_last_ref_pts = p_block->i_pts;
-        }
-    }
-    else if( p_pict )
-    {
-        /* Buggy libavcodec which doesn't update coded_frame->pts
-         * correctly */
-        p_block->i_dts = p_block->i_pts = p_pict->date;
-    }
-#endif
-
-    switch ( p_sys->p_context->coded_frame->pict_type )
-    {
-    case AV_PICTURE_TYPE_I:
-    case AV_PICTURE_TYPE_SI:
-        p_block->i_flags |= BLOCK_FLAG_TYPE_I;
-        break;
-    case AV_PICTURE_TYPE_P:
-    case AV_PICTURE_TYPE_SP:
-        p_block->i_flags |= BLOCK_FLAG_TYPE_P;
-        break;
-    case AV_PICTURE_TYPE_B:
-    case AV_PICTURE_TYPE_BI:
-        p_block->i_flags |= BLOCK_FLAG_TYPE_B;
-        break;
-    default:
-        p_block->i_flags |= BLOCK_FLAG_TYPE_PB;
+       switch ( p_sys->p_context->coded_frame->pict_type )
+       {
+       case AV_PICTURE_TYPE_I:
+       case AV_PICTURE_TYPE_SI:
+           p_block->i_flags |= BLOCK_FLAG_TYPE_I;
+           break;
+       case AV_PICTURE_TYPE_P:
+       case AV_PICTURE_TYPE_SP:
+           p_block->i_flags |= BLOCK_FLAG_TYPE_P;
+           break;
+       case AV_PICTURE_TYPE_B:
+       case AV_PICTURE_TYPE_BI:
+           p_block->i_flags |= BLOCK_FLAG_TYPE_B;
+           break;
+       default:
+           p_block->i_flags |= BLOCK_FLAG_TYPE_PB;
+       }
     }
 
     return p_block;
 }
 
-static block_t *encode_audio_buffer( encoder_t *p_enc, encoder_sys_t *p_sys,  AVFrame *frame )
-{
-    int got_packet, i_out;
-    got_packet=i_out=0;
-    AVPacket packet = {0};
-    block_t *p_block = block_Alloc( p_sys->i_buffer_out );
-    av_init_packet( &packet );
-    packet.data = p_block->p_buffer;
-    packet.size = p_block->i_buffer;
-
-    i_out = avcodec_encode_audio2( p_sys->p_context, &packet, frame, &got_packet );
-    if( unlikely( !got_packet || ( i_out < 0 ) ) )
-    {
-        if( i_out < 0 )
-        {
-            msg_Err( p_enc,"Encoding problem..");
-        }
-        block_Release( p_block );
-        return NULL;
-    }
-    p_block->i_buffer = packet.size;
-
-    p_block->i_length = (mtime_t)1000000 *
-     (mtime_t)p_sys->i_frame_size /
-     (mtime_t)p_sys->p_context->sample_rate;
-
-    if( likely( packet.pts != AV_NOPTS_VALUE ) )
-        p_block->i_dts = p_block->i_pts = packet.pts;
-    else
-        p_block->i_dts = p_block->i_pts = VLC_TS_INVALID;
-    return p_block;
-}
-
-static block_t *handle_delay_buffer( encoder_t *p_enc, encoder_sys_t *p_sys, int buffer_delay, block_t *p_aout_buf, int leftover_samples )
+static block_t *handle_delay_buffer( encoder_t *p_enc, encoder_sys_t *p_sys, unsigned int buffer_delay,
+                                     block_t *p_aout_buf, size_t leftover_samples )
 {
     block_t *p_block = NULL;
     //How much we need to copy from new packet
-    const int leftover = leftover_samples * p_sys->p_context->channels * p_sys->i_sample_bytes;
+    const size_t leftover = leftover_samples * p_sys->p_context->channels * p_sys->i_sample_bytes;
 
-    avcodec_get_frame_defaults( p_sys->frame );
+    av_frame_unref( p_sys->frame );
     p_sys->frame->format     = p_sys->p_context->sample_fmt;
     p_sys->frame->nb_samples = leftover_samples + p_sys->i_samples_delay;
 
-
-    p_sys->frame->pts        = date_Get( &p_sys->buffer_date );
+    p_sys->frame->pts        = date_Get( &p_sys->buffer_date ) * p_sys->p_context->time_base.den /
+                                CLOCK_FREQ / p_sys->p_context->time_base.num;
 
     if( likely( p_sys->frame->pts != AV_NOPTS_VALUE) )
         date_Increment( &p_sys->buffer_date, p_sys->frame->nb_samples );
@@ -1359,7 +1285,7 @@ static block_t *handle_delay_buffer( encoder_t *p_enc, encoder_sys_t *p_sys, int
     }
 
     if(unlikely( ( (leftover + buffer_delay) < p_sys->i_buffer_out ) &&
-                 !(p_sys->p_codec->capabilities & CODEC_CAP_SMALL_LAST_FRAME )))
+                 !(p_sys->p_codec->capabilities & AV_CODEC_CAP_SMALL_LAST_FRAME )))
     {
         msg_Dbg( p_enc, "No small last frame support, padding");
         size_t padding_size = p_sys->i_buffer_out - (leftover+buffer_delay);
@@ -1378,7 +1304,7 @@ static block_t *handle_delay_buffer( encoder_t *p_enc, encoder_sys_t *p_sys, int
 
     p_sys->i_samples_delay = 0;
 
-    p_block = encode_audio_buffer( p_enc, p_sys, p_sys->frame );
+    p_block = encode_avframe( p_enc, p_sys, p_sys->frame );
 
     return p_block;
 }
@@ -1402,7 +1328,7 @@ static block_t *EncodeAudio( encoder_t *p_enc, block_t *p_aout_buf )
     //Calculate how many bytes we would need from current buffer to fill frame
     size_t leftover_samples = __MAX(0,__MIN((ssize_t)i_samples_left, (ssize_t)(p_sys->i_frame_size - p_sys->i_samples_delay)));
 
-    if( p_aout_buf && ( p_aout_buf->i_pts > VLC_TS_INVALID ) )
+    if( p_aout_buf && ( p_aout_buf->i_pts != VLC_TS_INVALID ) )
     {
         date_Set( &p_sys->buffer_date, p_aout_buf->i_pts );
         /* take back amount we have leftover from previous buffer*/
@@ -1438,7 +1364,7 @@ static block_t *EncodeAudio( encoder_t *p_enc, block_t *p_aout_buf )
     {
         msg_Dbg(p_enc,"Flushing..");
         do {
-            p_block = encode_audio_buffer( p_enc, p_sys, NULL );
+            p_block = encode_avframe( p_enc, p_sys, NULL );
             if( likely( p_block ) )
             {
                 block_ChainAppend( &p_chain, p_block );
@@ -1451,13 +1377,15 @@ static block_t *EncodeAudio( encoder_t *p_enc, block_t *p_aout_buf )
     while( ( p_aout_buf->i_nb_samples >= p_sys->i_frame_size ) ||
            ( p_sys->b_variable && p_aout_buf->i_nb_samples ) )
     {
-        avcodec_get_frame_defaults( p_sys->frame );
+        av_frame_unref( p_sys->frame );
+
         if( p_sys->b_variable )
             p_sys->frame->nb_samples = p_aout_buf->i_nb_samples;
         else
             p_sys->frame->nb_samples = p_sys->i_frame_size;
         p_sys->frame->format     = p_sys->p_context->sample_fmt;
-        p_sys->frame->pts        = date_Get( &p_sys->buffer_date );
+        p_sys->frame->pts        = date_Get( &p_sys->buffer_date ) * p_sys->p_context->time_base.den /
+                                    CLOCK_FREQ / p_sys->p_context->time_base.num;
 
         const int in_bytes = p_sys->frame->nb_samples *
             p_sys->p_context->channels * p_sys->i_sample_bytes;
@@ -1489,7 +1417,7 @@ static block_t *EncodeAudio( encoder_t *p_enc, block_t *p_aout_buf )
         if( likely( p_sys->frame->pts != AV_NOPTS_VALUE) )
             date_Increment( &p_sys->buffer_date, p_sys->frame->nb_samples );
 
-        p_block = encode_audio_buffer( p_enc, p_sys, p_sys->frame );
+        p_block = encode_avframe( p_enc, p_sys, p_sys->frame );
         if( likely( p_block ) )
             block_ChainAppend( &p_chain, p_block );
     }
@@ -1507,20 +1435,19 @@ static block_t *EncodeAudio( encoder_t *p_enc, block_t *p_aout_buf )
 }
 
 /*****************************************************************************
- * CloseEncoder: libavcodec encoder destruction
+ * EndVideoEnc: libavcodec encoder destruction
  *****************************************************************************/
-void CloseEncoder( vlc_object_t *p_this )
+void EndVideoEnc( vlc_object_t *p_this )
 {
     encoder_t *p_enc = (encoder_t *)p_this;
     encoder_sys_t *p_sys = p_enc->p_sys;
 
-    /*FIXME: we should use avcodec_free_frame, but we don't require so new avcodec that has it*/
-    av_freep( &p_sys->frame );
+    av_frame_free( &p_sys->frame );
 
     vlc_avcodec_lock();
     avcodec_close( p_sys->p_context );
     vlc_avcodec_unlock();
-    av_free( p_sys->p_context );
+    avcodec_free_context( &p_sys->p_context );
 
 
     av_free( p_sys->p_interleave_buf );
diff --git modules/codec/avcodec/fourcc.c modules/codec/avcodec/fourcc.c
index f88a75fec..311ee69b1 100644
--- modules/codec/avcodec/fourcc.c
+++ modules/codec/avcodec/fourcc.c
@@ -36,240 +36,229 @@
  * Codec fourcc -> libavcodec Codec_id mapping
  * Sorted by AVCodecID enumeration order
  *****************************************************************************/
-static const struct
+struct vlc_avcodec_fourcc
 {
     vlc_fourcc_t i_fourcc;
     unsigned i_codec;
-    int i_cat;
-} codecs_table[] =
-{
-    { 0, AV_CODEC_ID_NONE, UNKNOWN_ES },
-
-    /*
-     * Video Codecs
-     */
+};
 
-    { VLC_CODEC_MP2V, AV_CODEC_ID_MPEG2VIDEO, VIDEO_ES }, /* prefer MPEG2 over MPEG1 */
-    { VLC_CODEC_MPGV, AV_CODEC_ID_MPEG2VIDEO, VIDEO_ES }, /* prefer MPEG2 over MPEG1 */
-    { VLC_CODEC_MP1V, AV_CODEC_ID_MPEG1VIDEO, VIDEO_ES },
+/*
+ * Video Codecs
+ */
+static const struct vlc_avcodec_fourcc video_codecs[] =
+{
+    { VLC_CODEC_MP1V, AV_CODEC_ID_MPEG1VIDEO },
+    { VLC_CODEC_MP2V, AV_CODEC_ID_MPEG2VIDEO }, /* prefer MPEG2 over MPEG1 */
+    { VLC_CODEC_MPGV, AV_CODEC_ID_MPEG2VIDEO }, /* prefer MPEG2 over MPEG1 */
     /* AV_CODEC_ID_MPEG2VIDEO_XVMC */
-    { VLC_CODEC_H261, AV_CODEC_ID_H261, VIDEO_ES },
-    { VLC_CODEC_H263, AV_CODEC_ID_H263, VIDEO_ES },
-    { VLC_CODEC_RV10, AV_CODEC_ID_RV10, VIDEO_ES },
-    { VLC_CODEC_RV13, AV_CODEC_ID_RV10, VIDEO_ES },
-    { VLC_CODEC_RV20, AV_CODEC_ID_RV20, VIDEO_ES },
-    { VLC_CODEC_MJPG, AV_CODEC_ID_MJPEG, VIDEO_ES },
-    { VLC_CODEC_MJPGB, AV_CODEC_ID_MJPEGB,VIDEO_ES },
-    { VLC_CODEC_LJPG, AV_CODEC_ID_LJPEG, VIDEO_ES },
-    { VLC_CODEC_SP5X, AV_CODEC_ID_SP5X, VIDEO_ES },
-    { VLC_CODEC_JPEGLS, AV_CODEC_ID_JPEGLS, VIDEO_ES },
-    { VLC_CODEC_MP4V, AV_CODEC_ID_MPEG4, VIDEO_ES },
+    { VLC_CODEC_H261, AV_CODEC_ID_H261 },
+    { VLC_CODEC_H263, AV_CODEC_ID_H263 },
+    { VLC_CODEC_RV10, AV_CODEC_ID_RV10 },
+    { VLC_CODEC_RV13, AV_CODEC_ID_RV10 },
+    { VLC_CODEC_RV20, AV_CODEC_ID_RV20 },
+    { VLC_CODEC_MJPG, AV_CODEC_ID_MJPEG },
+    { VLC_CODEC_MJPGB, AV_CODEC_ID_MJPEGB },
+    { VLC_CODEC_LJPG, AV_CODEC_ID_LJPEG },
+    { VLC_CODEC_SP5X, AV_CODEC_ID_SP5X },
+    { VLC_CODEC_JPEGLS, AV_CODEC_ID_JPEGLS },
+    { VLC_CODEC_MP4V, AV_CODEC_ID_MPEG4 },
     /* AV_CODEC_ID_RAWVIDEO */
-    { VLC_CODEC_DIV1, AV_CODEC_ID_MSMPEG4V1, VIDEO_ES },
-    { VLC_CODEC_DIV2, AV_CODEC_ID_MSMPEG4V2, VIDEO_ES },
-    { VLC_CODEC_DIV3, AV_CODEC_ID_MSMPEG4V3, VIDEO_ES },
-    { VLC_CODEC_WMV1, AV_CODEC_ID_WMV1, VIDEO_ES },
-    { VLC_CODEC_WMV2, AV_CODEC_ID_WMV2, VIDEO_ES },
-    { VLC_CODEC_H263P, AV_CODEC_ID_H263P, VIDEO_ES },
-    { VLC_CODEC_H263I, AV_CODEC_ID_H263I, VIDEO_ES },
-    { VLC_CODEC_FLV1, AV_CODEC_ID_FLV1, VIDEO_ES },
-    { VLC_CODEC_SVQ1, AV_CODEC_ID_SVQ1, VIDEO_ES },
-    { VLC_CODEC_SVQ3, AV_CODEC_ID_SVQ3, VIDEO_ES },
-    { VLC_CODEC_DV, AV_CODEC_ID_DVVIDEO, VIDEO_ES },
-    { VLC_CODEC_HUFFYUV, AV_CODEC_ID_HUFFYUV, VIDEO_ES },
-    { VLC_CODEC_CYUV, AV_CODEC_ID_CYUV, VIDEO_ES },
-    { VLC_CODEC_H264, AV_CODEC_ID_H264, VIDEO_ES },
-    { VLC_CODEC_INDEO3, AV_CODEC_ID_INDEO3, VIDEO_ES },
-    { VLC_CODEC_VP3, AV_CODEC_ID_VP3, VIDEO_ES },
-    { VLC_CODEC_THEORA, AV_CODEC_ID_THEORA, VIDEO_ES },
+    { VLC_CODEC_DIV1, AV_CODEC_ID_MSMPEG4V1 },
+    { VLC_CODEC_DIV2, AV_CODEC_ID_MSMPEG4V2 },
+    { VLC_CODEC_DIV3, AV_CODEC_ID_MSMPEG4V3 },
+    { VLC_CODEC_WMV1, AV_CODEC_ID_WMV1 },
+    { VLC_CODEC_WMV2, AV_CODEC_ID_WMV2 },
+    { VLC_CODEC_H263P, AV_CODEC_ID_H263P },
+    { VLC_CODEC_H263I, AV_CODEC_ID_H263I },
+    { VLC_CODEC_FLV1, AV_CODEC_ID_FLV1 },
+    { VLC_CODEC_SVQ1, AV_CODEC_ID_SVQ1 },
+    { VLC_CODEC_SVQ3, AV_CODEC_ID_SVQ3 },
+    { VLC_CODEC_DV, AV_CODEC_ID_DVVIDEO },
+    { VLC_CODEC_HUFFYUV, AV_CODEC_ID_HUFFYUV },
+    { VLC_CODEC_CYUV, AV_CODEC_ID_CYUV },
+    { VLC_CODEC_H264, AV_CODEC_ID_H264 },
+    { VLC_CODEC_INDEO3, AV_CODEC_ID_INDEO3 },
+    { VLC_CODEC_VP3, AV_CODEC_ID_VP3 },
+    { VLC_CODEC_THEORA, AV_CODEC_ID_THEORA },
 #if ( !defined( WORDS_BIGENDIAN ) )
     /* Asus Video (Another thing that doesn't work on PPC) */
-    { VLC_CODEC_ASV1, AV_CODEC_ID_ASV1, VIDEO_ES },
-    { VLC_CODEC_ASV2, AV_CODEC_ID_ASV2, VIDEO_ES },
+    { VLC_CODEC_ASV1, AV_CODEC_ID_ASV1 },
+    { VLC_CODEC_ASV2, AV_CODEC_ID_ASV2 },
 #endif
-    { VLC_CODEC_FFV1, AV_CODEC_ID_FFV1, VIDEO_ES },
-    { VLC_CODEC_4XM, AV_CODEC_ID_4XM, VIDEO_ES },
-    { VLC_CODEC_VCR1, AV_CODEC_ID_VCR1, VIDEO_ES },
-    { VLC_CODEC_CLJR, AV_CODEC_ID_CLJR, VIDEO_ES },
-    { VLC_CODEC_MDEC, AV_CODEC_ID_MDEC, VIDEO_ES },
-    { VLC_CODEC_ROQ, AV_CODEC_ID_ROQ, VIDEO_ES },
-    { VLC_CODEC_INTERPLAY, AV_CODEC_ID_INTERPLAY_VIDEO, VIDEO_ES },
-    /* AV_CODEC_ID_XAN_WC3 */
-    { VLC_CODEC_XAN_WC4, AV_CODEC_ID_XAN_WC4, VIDEO_ES },
-    { VLC_CODEC_RPZA, AV_CODEC_ID_RPZA, VIDEO_ES },
-    { VLC_CODEC_CINEPAK, AV_CODEC_ID_CINEPAK, VIDEO_ES },
-    /* AV_CODEC_ID_WS_VQA */
-    { VLC_CODEC_MSRLE, AV_CODEC_ID_MSRLE, VIDEO_ES },
-    { VLC_CODEC_MSVIDEO1, AV_CODEC_ID_MSVIDEO1, VIDEO_ES },
-    { VLC_CODEC_IDCIN, AV_CODEC_ID_IDCIN, VIDEO_ES },
-    { VLC_CODEC_8BPS, AV_CODEC_ID_8BPS, VIDEO_ES },
-    { VLC_CODEC_SMC, AV_CODEC_ID_SMC, VIDEO_ES },
-    { VLC_CODEC_FLIC, AV_CODEC_ID_FLIC, VIDEO_ES },
-    { VLC_CODEC_TRUEMOTION1, AV_CODEC_ID_TRUEMOTION1, VIDEO_ES },
-    { VLC_CODEC_VMDVIDEO, AV_CODEC_ID_VMDVIDEO, VIDEO_ES },
-    { VLC_CODEC_LCL_MSZH, AV_CODEC_ID_MSZH, VIDEO_ES },
-    { VLC_CODEC_LCL_ZLIB, AV_CODEC_ID_ZLIB, VIDEO_ES },
-    { VLC_CODEC_QTRLE, AV_CODEC_ID_QTRLE, VIDEO_ES },
-    { VLC_CODEC_TSCC, AV_CODEC_ID_TSCC, VIDEO_ES },
-    { VLC_CODEC_ULTI, AV_CODEC_ID_ULTI, VIDEO_ES },
-    { VLC_CODEC_QDRAW, AV_CODEC_ID_QDRAW, VIDEO_ES },
-    { VLC_CODEC_VIXL, AV_CODEC_ID_VIXL, VIDEO_ES },
-    { VLC_CODEC_QPEG, AV_CODEC_ID_QPEG, VIDEO_ES },
-    { VLC_CODEC_PNG, AV_CODEC_ID_PNG, VIDEO_ES },
-    { VLC_CODEC_PPM, AV_CODEC_ID_PPM, VIDEO_ES },
+    { VLC_CODEC_FFV1, AV_CODEC_ID_FFV1 },
+    { VLC_CODEC_4XM, AV_CODEC_ID_4XM },
+    { VLC_CODEC_VCR1, AV_CODEC_ID_VCR1 },
+    { VLC_CODEC_CLJR, AV_CODEC_ID_CLJR },
+    { VLC_CODEC_MDEC, AV_CODEC_ID_MDEC },
+    { VLC_CODEC_ROQ, AV_CODEC_ID_ROQ },
+    { VLC_CODEC_INTERPLAY, AV_CODEC_ID_INTERPLAY_VIDEO },
+    { VLC_CODEC_XAN_WC3, AV_CODEC_ID_XAN_WC3 },
+    { VLC_CODEC_XAN_WC4, AV_CODEC_ID_XAN_WC4 },
+    { VLC_CODEC_RPZA, AV_CODEC_ID_RPZA },
+    { VLC_CODEC_CINEPAK, AV_CODEC_ID_CINEPAK },
+    { VLC_CODEC_WS_VQA, AV_CODEC_ID_WS_VQA },
+    { VLC_CODEC_MSRLE, AV_CODEC_ID_MSRLE },
+    { VLC_CODEC_MSVIDEO1, AV_CODEC_ID_MSVIDEO1 },
+    { VLC_CODEC_IDCIN, AV_CODEC_ID_IDCIN },
+    { VLC_CODEC_8BPS, AV_CODEC_ID_8BPS },
+    { VLC_CODEC_SMC, AV_CODEC_ID_SMC },
+    { VLC_CODEC_FLIC, AV_CODEC_ID_FLIC },
+    { VLC_CODEC_TRUEMOTION1, AV_CODEC_ID_TRUEMOTION1 },
+    { VLC_CODEC_VMDVIDEO, AV_CODEC_ID_VMDVIDEO },
+    { VLC_CODEC_LCL_MSZH, AV_CODEC_ID_MSZH },
+    { VLC_CODEC_LCL_ZLIB, AV_CODEC_ID_ZLIB },
+    { VLC_CODEC_QTRLE, AV_CODEC_ID_QTRLE },
+    { VLC_CODEC_TSCC, AV_CODEC_ID_TSCC },
+    { VLC_CODEC_ULTI, AV_CODEC_ID_ULTI },
+    { VLC_CODEC_QDRAW, AV_CODEC_ID_QDRAW },
+    { VLC_CODEC_VIXL, AV_CODEC_ID_VIXL },
+    { VLC_CODEC_QPEG, AV_CODEC_ID_QPEG },
+    { VLC_CODEC_PNG, AV_CODEC_ID_PNG },
+    { VLC_CODEC_PPM, AV_CODEC_ID_PPM },
     /* AV_CODEC_ID_PBM */
-    { VLC_CODEC_PGM, AV_CODEC_ID_PGM, VIDEO_ES },
-    { VLC_CODEC_PGMYUV, AV_CODEC_ID_PGMYUV, VIDEO_ES },
-    { VLC_CODEC_PAM, AV_CODEC_ID_PAM, VIDEO_ES },
-    { VLC_CODEC_FFVHUFF, AV_CODEC_ID_FFVHUFF, VIDEO_ES },
-    { VLC_CODEC_RV30, AV_CODEC_ID_RV30, VIDEO_ES },
-    { VLC_CODEC_RV40, AV_CODEC_ID_RV40, VIDEO_ES },
-    { VLC_CODEC_VC1,  AV_CODEC_ID_VC1, VIDEO_ES },
-    { VLC_CODEC_WMVA, AV_CODEC_ID_VC1, VIDEO_ES },
-    { VLC_CODEC_WMV3, AV_CODEC_ID_WMV3, VIDEO_ES },
-    { VLC_CODEC_WMVP, AV_CODEC_ID_WMV3, VIDEO_ES },
-    { VLC_CODEC_LOCO, AV_CODEC_ID_LOCO, VIDEO_ES },
-    { VLC_CODEC_WNV1, AV_CODEC_ID_WNV1, VIDEO_ES },
-    { VLC_CODEC_AASC, AV_CODEC_ID_AASC, VIDEO_ES },
-    { VLC_CODEC_INDEO2, AV_CODEC_ID_INDEO2, VIDEO_ES },
-    { VLC_CODEC_FRAPS, AV_CODEC_ID_FRAPS, VIDEO_ES },
-    { VLC_CODEC_TRUEMOTION2, AV_CODEC_ID_TRUEMOTION2, VIDEO_ES },
-    { VLC_CODEC_BMP, AV_CODEC_ID_BMP, VIDEO_ES },
-    { VLC_CODEC_CSCD, AV_CODEC_ID_CSCD, VIDEO_ES },
-    /* AV_CODEC_ID_MMVIDEO */
-    { VLC_CODEC_ZMBV, AV_CODEC_ID_ZMBV, VIDEO_ES },
-    /* AV_CODEC_ID_AVS */
-    { VLC_CODEC_SMACKVIDEO, AV_CODEC_ID_SMACKVIDEO, VIDEO_ES },
-    { VLC_CODEC_NUV, AV_CODEC_ID_NUV, VIDEO_ES },
-    { VLC_CODEC_KMVC, AV_CODEC_ID_KMVC, VIDEO_ES },
-    { VLC_CODEC_FLASHSV, AV_CODEC_ID_FLASHSV, VIDEO_ES },
-    { VLC_CODEC_CAVS, AV_CODEC_ID_CAVS, VIDEO_ES },
-    { VLC_CODEC_JPEG2000, AV_CODEC_ID_JPEG2000, VIDEO_ES },
-    { VLC_CODEC_VMNC, AV_CODEC_ID_VMNC, VIDEO_ES },
-    { VLC_CODEC_VP5, AV_CODEC_ID_VP5, VIDEO_ES },
-    { VLC_CODEC_VP6, AV_CODEC_ID_VP6, VIDEO_ES },
-    { VLC_CODEC_VP6F, AV_CODEC_ID_VP6F, VIDEO_ES },
-    { VLC_CODEC_TARGA, AV_CODEC_ID_TARGA, VIDEO_ES },
-    /* AV_CODEC_ID_DSICINVIDEO */
-    /* AV_CODEC_ID_TIERTEXSEQVIDEO */
-    { VLC_CODEC_TIFF, AV_CODEC_ID_TIFF, VIDEO_ES },
-    { VLC_CODEC_GIF, AV_CODEC_ID_GIF, VIDEO_ES },
-    /* AV_CODEC_ID_DXA */
-    { VLC_CODEC_DNXHD, AV_CODEC_ID_DNXHD, VIDEO_ES },
-    { VLC_CODEC_THP, AV_CODEC_ID_THP, VIDEO_ES },
-    { VLC_CODEC_SGI, AV_CODEC_ID_SGI, VIDEO_ES },
-    /* AV_CODEC_ID_C93 */
-    /* AV_CODEC_ID_BETHSOFTVID */
+    { VLC_CODEC_PGM, AV_CODEC_ID_PGM },
+    { VLC_CODEC_PGMYUV, AV_CODEC_ID_PGMYUV },
+    { VLC_CODEC_PAM, AV_CODEC_ID_PAM },
+    { VLC_CODEC_FFVHUFF, AV_CODEC_ID_FFVHUFF },
+    { VLC_CODEC_RV30, AV_CODEC_ID_RV30 },
+    { VLC_CODEC_RV40, AV_CODEC_ID_RV40 },
+    { VLC_CODEC_VC1,  AV_CODEC_ID_VC1 },
+    { VLC_CODEC_WMVA, AV_CODEC_ID_VC1 },
+    { VLC_CODEC_WMV3, AV_CODEC_ID_WMV3 },
+    { VLC_CODEC_WMVP, AV_CODEC_ID_WMV3 },
+    { VLC_CODEC_LOCO, AV_CODEC_ID_LOCO },
+    { VLC_CODEC_WNV1, AV_CODEC_ID_WNV1 },
+    { VLC_CODEC_AASC, AV_CODEC_ID_AASC },
+    { VLC_CODEC_INDEO2, AV_CODEC_ID_INDEO2 },
+    { VLC_CODEC_FRAPS, AV_CODEC_ID_FRAPS },
+    { VLC_CODEC_TRUEMOTION2, AV_CODEC_ID_TRUEMOTION2 },
+    { VLC_CODEC_BMP, AV_CODEC_ID_BMP },
+    { VLC_CODEC_CSCD, AV_CODEC_ID_CSCD },
+    { VLC_CODEC_MMVIDEO, AV_CODEC_ID_MMVIDEO },
+    { VLC_CODEC_ZMBV, AV_CODEC_ID_ZMBV },
+    { VLC_CODEC_AVS, AV_CODEC_ID_AVS },
+    { VLC_CODEC_SMACKVIDEO, AV_CODEC_ID_SMACKVIDEO },
+    { VLC_CODEC_NUV, AV_CODEC_ID_NUV },
+    { VLC_CODEC_KMVC, AV_CODEC_ID_KMVC },
+    { VLC_CODEC_FLASHSV, AV_CODEC_ID_FLASHSV },
+    { VLC_CODEC_CAVS, AV_CODEC_ID_CAVS },
+    { VLC_CODEC_JPEG2000, AV_CODEC_ID_JPEG2000 },
+    { VLC_CODEC_VMNC, AV_CODEC_ID_VMNC },
+    { VLC_CODEC_VP5, AV_CODEC_ID_VP5 },
+    { VLC_CODEC_VP6, AV_CODEC_ID_VP6 },
+    { VLC_CODEC_VP6F, AV_CODEC_ID_VP6F },
+    { VLC_CODEC_TARGA, AV_CODEC_ID_TARGA },
+    { VLC_CODEC_DSICINVIDEO, AV_CODEC_ID_DSICINVIDEO },
+    { VLC_CODEC_TIERTEXSEQVIDEO, AV_CODEC_ID_TIERTEXSEQVIDEO },
+    { VLC_CODEC_TIFF, AV_CODEC_ID_TIFF },
+    { VLC_CODEC_GIF, AV_CODEC_ID_GIF },
+    { VLC_CODEC_DXA, AV_CODEC_ID_DXA },
+    { VLC_CODEC_DNXHD, AV_CODEC_ID_DNXHD },
+    { VLC_CODEC_THP, AV_CODEC_ID_THP },
+    { VLC_CODEC_SGI, AV_CODEC_ID_SGI },
+    { VLC_CODEC_C93, AV_CODEC_ID_C93 },
+    { VLC_CODEC_BETHSOFTVID, AV_CODEC_ID_BETHSOFTVID },
     /* AV_CODEC_ID_PTX */
-    { VLC_CODEC_TXD, AV_CODEC_ID_TXD, VIDEO_ES },
-    { VLC_CODEC_VP6A, AV_CODEC_ID_VP6A, VIDEO_ES },
-    { VLC_CODEC_AMV, AV_CODEC_ID_AMV, VIDEO_ES },
-    /* AV_CODEC_ID_VB */
-    { VLC_CODEC_PCX, AV_CODEC_ID_PCX, VIDEO_ES },
+    { VLC_CODEC_TXD, AV_CODEC_ID_TXD },
+    { VLC_CODEC_VP6A, AV_CODEC_ID_VP6A },
+    { VLC_CODEC_AMV, AV_CODEC_ID_AMV },
+    { VLC_CODEC_VB, AV_CODEC_ID_VB },
+    { VLC_CODEC_PCX, AV_CODEC_ID_PCX },
     /* AV_CODEC_ID_SUNRAST */
-    { VLC_CODEC_INDEO4, AV_CODEC_ID_INDEO4, VIDEO_ES },
-    { VLC_CODEC_INDEO5, AV_CODEC_ID_INDEO5, VIDEO_ES },
-    { VLC_CODEC_MIMIC, AV_CODEC_ID_MIMIC, VIDEO_ES },
-    /* AV_CODEC_ID_RL2 */
-    { VLC_CODEC_ESCAPE124, AV_CODEC_ID_ESCAPE124, VIDEO_ES },
-    { VLC_CODEC_DIRAC, AV_CODEC_ID_DIRAC, VIDEO_ES },
-    /* AV_CODEC_ID_BFI */
-    /* AV_CODEC_ID_CMV */
-    /* AV_CODEC_ID_MOTIONPIXELS */
-    /* AV_CODEC_ID_TGV */
-    /* AV_CODEC_ID_TGQ */
-    /* AV_CODEC_ID_TQI */
-    { VLC_CODEC_AURA, AV_CODEC_ID_AURA, VIDEO_ES },
+    { VLC_CODEC_INDEO4, AV_CODEC_ID_INDEO4 },
+    { VLC_CODEC_INDEO5, AV_CODEC_ID_INDEO5 },
+    { VLC_CODEC_MIMIC, AV_CODEC_ID_MIMIC },
+    { VLC_CODEC_RL2, AV_CODEC_ID_RL2 },
+    { VLC_CODEC_ESCAPE124, AV_CODEC_ID_ESCAPE124 },
+    { VLC_CODEC_DIRAC, AV_CODEC_ID_DIRAC },
+    { VLC_CODEC_BFI, AV_CODEC_ID_BFI },
+    { VLC_CODEC_CMV, AV_CODEC_ID_CMV },
+    { VLC_CODEC_MOTIONPIXELS, AV_CODEC_ID_MOTIONPIXELS },
+    { VLC_CODEC_TGV, AV_CODEC_ID_TGV },
+    { VLC_CODEC_TGQ, AV_CODEC_ID_TGQ },
+    { VLC_CODEC_TQI, AV_CODEC_ID_TQI },
+    { VLC_CODEC_AURA, AV_CODEC_ID_AURA },
     /* AV_CODEC_ID_AURA2 */
     /* AV_CODEC_ID_V210X */
-    /* AV_CODEC_ID_TMV */
-    { VLC_CODEC_V210, AV_CODEC_ID_V210, VIDEO_ES },
+    { VLC_CODEC_TMV, AV_CODEC_ID_TMV },
+    { VLC_CODEC_V210, AV_CODEC_ID_V210 },
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 54, 50, 100 ) && LIBAVCODEC_VERSION_MICRO >= 100
+    { VLC_CODEC_VUYA, AV_CODEC_ID_AYUV },
+#endif
     /* AV_CODEC_ID_DPX */
-    /* AV_CODEC_ID_MAD */
-    { VLC_CODEC_FRWU, AV_CODEC_ID_FRWU, VIDEO_ES },
-    { VLC_CODEC_FLASHSV2, AV_CODEC_ID_FLASHSV2, VIDEO_ES },
+    { VLC_CODEC_MAD, AV_CODEC_ID_MAD },
+    { VLC_CODEC_FRWU, AV_CODEC_ID_FRWU },
+    { VLC_CODEC_FLASHSV2, AV_CODEC_ID_FLASHSV2 },
     /* AV_CODEC_ID_CDGRAPHICS */
     /* AV_CODEC_ID_R210 */
-    /* AV_CODEC_ID_ANM */
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 52, 55, 0 )
-    { VLC_CODEC_BINKVIDEO, AV_CODEC_ID_BINKVIDEO, VIDEO_ES },
-#endif
+    { VLC_CODEC_ANM, AV_CODEC_ID_ANM },
+    { VLC_CODEC_BINKVIDEO, AV_CODEC_ID_BINKVIDEO },
     /* AV_CODEC_ID_IFF_ILBM */
     /* AV_CODEC_ID_IFF_BYTERUN1 */
-    { VLC_CODEC_KGV1, AV_CODEC_ID_KGV1, VIDEO_ES },
-    /* AV_CODEC_ID_YOP */
-    { VLC_CODEC_VP8, AV_CODEC_ID_VP8, VIDEO_ES },
+    { VLC_CODEC_KGV1, AV_CODEC_ID_KGV1 },
+    { VLC_CODEC_YOP, AV_CODEC_ID_YOP },
+    { VLC_CODEC_VP8, AV_CODEC_ID_VP8 },
     /* AV_CODEC_ID_PICTOR */
     /* AV_CODEC_ID_ANSI */
     /* AV_CODEC_ID_A64_MULTI */
     /* AV_CODEC_ID_A64_MULTI5 */
     /* AV_CODEC_ID_R10K */
-    { VLC_CODEC_MXPEG, AV_CODEC_ID_MXPEG, VIDEO_ES },
-    { VLC_CODEC_LAGARITH, AV_CODEC_ID_LAGARITH, VIDEO_ES },
-    { VLC_CODEC_PRORES, AV_CODEC_ID_PRORES, VIDEO_ES },
-    /* AV_CODEC_ID_JV */
-    /* AV_CODEC_ID_DFA */
-    { VLC_CODEC_WMVP, AV_CODEC_ID_WMV3IMAGE, VIDEO_ES },
-    { VLC_CODEC_WMVP2, AV_CODEC_ID_VC1IMAGE, VIDEO_ES },
-    { VLC_CODEC_UTVIDEO, AV_CODEC_ID_UTVIDEO, VIDEO_ES },
-    { VLC_CODEC_BMVVIDEO, AV_CODEC_ID_BMV_VIDEO, VIDEO_ES },
-    { VLC_CODEC_VBLE, AV_CODEC_ID_VBLE, VIDEO_ES },
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 53, 42, 0 )
-    { VLC_CODEC_DXTORY, AV_CODEC_ID_DXTORY, VIDEO_ES },
-#endif
+    { VLC_CODEC_MXPEG, AV_CODEC_ID_MXPEG },
+    { VLC_CODEC_LAGARITH, AV_CODEC_ID_LAGARITH },
+    { VLC_CODEC_PRORES, AV_CODEC_ID_PRORES },
+    { VLC_CODEC_JV, AV_CODEC_ID_JV },
+    { VLC_CODEC_DFA, AV_CODEC_ID_DFA },
+    { VLC_CODEC_WMVP, AV_CODEC_ID_WMV3IMAGE },
+    { VLC_CODEC_WMVP2, AV_CODEC_ID_VC1IMAGE },
+    { VLC_CODEC_UTVIDEO, AV_CODEC_ID_UTVIDEO },
+    { VLC_CODEC_BMVVIDEO, AV_CODEC_ID_BMV_VIDEO },
+    { VLC_CODEC_VBLE, AV_CODEC_ID_VBLE },
+    { VLC_CODEC_DXTORY, AV_CODEC_ID_DXTORY },
     /* AV_CODEC_ID_V410 */
     /* AV_CODEC_ID_XWD */
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 54, 1, 0 )
-    { VLC_CODEC_CDXL, AV_CODEC_ID_CDXL, VIDEO_ES },
-#endif
+    { VLC_CODEC_CDXL, AV_CODEC_ID_CDXL },
     /* AV_CODEC_ID_XBM */
     /* AV_CODEC_ID_ZEROCODEC */
-#if LIBAVCODEC_VERSION_CHECK( 54, 16, 0, 27, 100 )
-    { VLC_CODEC_MSS1, AV_CODEC_ID_MSS1, VIDEO_ES },
-#endif
-#if LIBAVCODEC_VERSION_CHECK( 54, 17, 0, 32, 100 )
-    { VLC_CODEC_MSA1, AV_CODEC_ID_MSA1, VIDEO_ES },
-#endif
-#if LIBAVCODEC_VERSION_CHECK( 54, 18, 0, 34, 100 )
-    { VLC_CODEC_TSC2, AV_CODEC_ID_TSCC2, VIDEO_ES },
-#endif
-#if LIBAVCODEC_VERSION_CHECK( 54, 20, 0, 37, 100 )
-    { VLC_CODEC_MTS2, AV_CODEC_ID_MTS2, VIDEO_ES },
-#endif
-#if LIBAVCODEC_VERSION_CHECK( 54, 24, 0, 47, 100 )
-    { VLC_CODEC_CLLC, AV_CODEC_ID_CLLC, VIDEO_ES },
-#endif
-#if LIBAVCODEC_VERSION_CHECK( 54, 27, 0, 55, 100 )
-    { VLC_CODEC_MSS2, AV_CODEC_ID_MSS2, VIDEO_ES },
-#endif
-#if LIBAVCODEC_VERSION_CHECK( 54, 41, 0, 89, 100 )
-    { VLC_CODEC_VP9, AV_CODEC_ID_VP9, VIDEO_ES },
-#endif
-#if LIBAVCODEC_VERSION_CHECK( 55, 5, 0, 10, 100 )
-    { VLC_CODEC_ICOD, AV_CODEC_ID_AIC, VIDEO_ES },
+    { VLC_CODEC_MSS1, AV_CODEC_ID_MSS1 },
+    { VLC_CODEC_MSA1, AV_CODEC_ID_MSA1 },
+    { VLC_CODEC_TSC2, AV_CODEC_ID_TSCC2 },
+    { VLC_CODEC_MTS2, AV_CODEC_ID_MTS2 },
+    { VLC_CODEC_CLLC, AV_CODEC_ID_CLLC },
+    { VLC_CODEC_MSS2, AV_CODEC_ID_MSS2 },
+    { VLC_CODEC_VP9, AV_CODEC_ID_VP9 },
+#if LIBAVCODEC_VERSION_CHECK( 57, 26, 0, 83, 101 )
+    { VLC_CODEC_AV1, AV_CODEC_ID_AV1 },
 #endif
+    { VLC_CODEC_ICOD, AV_CODEC_ID_AIC },
     /* AV_CODEC_ID_ESCAPE130 */
-#if LIBAVCODEC_VERSION_CHECK( 55, 8, 0, 15, 100 )
-    { VLC_CODEC_G2M4, AV_CODEC_ID_G2M, VIDEO_ES },
-#endif
+    { VLC_CODEC_G2M4, AV_CODEC_ID_G2M },
+    { VLC_CODEC_G2M2, AV_CODEC_ID_G2M },
+    { VLC_CODEC_G2M3, AV_CODEC_ID_G2M },
     /* AV_CODEC_ID_WEBP */
-    /* AV_CODEC_ID_HNM4_VIDEO */
-#if LIBAVCODEC_VERSION_CHECK( 55, 24, 0, 37, 100 )
-    { VLC_CODEC_HEVC, AV_CODEC_ID_HEVC, VIDEO_ES },
-#endif
+    { VLC_CODEC_HNM4_VIDEO, AV_CODEC_ID_HNM4_VIDEO },
+    { VLC_CODEC_HEVC, AV_CODEC_ID_HEVC },
 
-#if LIBAVCODEC_VERSION_CHECK( 55, 33, 0, 50, 100 )
-    { VLC_CODEC_FIC , AV_CODEC_ID_FIC, VIDEO_ES },
-#endif
+    { VLC_CODEC_FIC , AV_CODEC_ID_FIC },
+    /* AV_CODEC_ID_ALIAS_PIX */
+    /* AV_CODEC_ID_BRENDER_PIX */
+    /* AV_CODEC_ID_PAF_VIDEO */
+    /* AV_CODEC_ID_EXR */
 
-#if LIBAVCODEC_VERSION_CHECK( 55, 43, 0, 56, 108 )
-    { VLC_CODEC_VP7 , AV_CODEC_ID_VP7, VIDEO_ES },
-#endif
+    { VLC_CODEC_VP7 , AV_CODEC_ID_VP7 },
+    /* AV_CODEC_ID_SANM */
+    /* AV_CODEC_ID_SGIRLE */
+    /* AV_CODEC_ID_MVC1 */
+    /* AV_CODEC_ID_MVC2 */
+    { VLC_CODEC_HQX, AV_CODEC_ID_HQX },
 
-#if LIBAVCODEC_VERSION_CHECK( 56, 31, 0, 46, 100 )
-    { VLC_CODEC_G2M2, AV_CODEC_ID_G2M, VIDEO_ES },
-    { VLC_CODEC_G2M3, AV_CODEC_ID_G2M, VIDEO_ES },
-#endif
+    { VLC_CODEC_TDSC, AV_CODEC_ID_TDSC },
+
+    { VLC_CODEC_HQ_HQA, AV_CODEC_ID_HQ_HQA },
+
+    { VLC_CODEC_HAP, AV_CODEC_ID_HAP },
+    /* AV_CODEC_ID_DDS */
+
+    { VLC_CODEC_DXV, AV_CODEC_ID_DXV },
 
     /* ffmpeg only: AV_CODEC_ID_BRENDER_PIX */
     /* ffmpeg only: AV_CODEC_ID_Y41P */
@@ -277,7 +266,6 @@ static const struct
     /* ffmpeg only: AV_CODEC_ID_AVRP */
     /* ffmpeg only: AV_CODEC_ID_012V */
     /* ffmpeg only: AV_CODEC_ID_AVUI */
-    /* ffmpeg only: AV_CODEC_ID_AYUV */
     /* ffmpeg only: AV_CODEC_ID_TARGA_Y216 */
     /* ffmpeg only: AV_CODEC_ID_V308 */
     /* ffmpeg only: AV_CODEC_ID_V408 */
@@ -293,37 +281,58 @@ static const struct
     /* ffmpeg only: AV_CODEC_ID_SNOW */
     /* ffmpeg only: AV_CODEC_ID_SMVJPEG */
 
+#if LIBAVCODEC_VERSION_CHECK( 58, 0, 0, 1, 100 )
+    { VLC_CODEC_MAGICYUV, AV_CODEC_ID_MAGICYUV },
+#endif
+
+#if LIBAVCODEC_VERSION_CHECK( 57, 999, 999, 24, 102 )
+    { VLC_CODEC_CINEFORM, AV_CODEC_ID_CFHD },
+#endif
+
+#if LIBAVCODEC_VERSION_CHECK( 57, 999, 999, 70, 100 )
+    { VLC_CODEC_PIXLET, AV_CODEC_ID_PIXLET },
+#endif
+
+#if LIBAVCODEC_VERSION_CHECK( 57, 999, 999, 71, 101 )
+    { VLC_CODEC_SPEEDHQ, AV_CODEC_ID_SPEEDHQ },
+#endif
 
-    /*
-     *  Audio Codecs
-     */
+#if LIBAVCODEC_VERSION_CHECK( 57, 999, 999, 79, 100 )
+    { VLC_CODEC_FMVC, AV_CODEC_ID_FMVC },
+#endif
+};
 
+/*
+ *  Audio Codecs
+ */
+static const struct vlc_avcodec_fourcc audio_codecs[] =
+{
     /* PCM */
-    { VLC_CODEC_S16L, AV_CODEC_ID_PCM_S16LE, AUDIO_ES },
-    { VLC_CODEC_S16B, AV_CODEC_ID_PCM_S16BE, AUDIO_ES },
-    { VLC_CODEC_U16L, AV_CODEC_ID_PCM_U16LE, AUDIO_ES },
-    { VLC_CODEC_U16B, AV_CODEC_ID_PCM_U16BE, AUDIO_ES },
-    { VLC_CODEC_S8, AV_CODEC_ID_PCM_S8, AUDIO_ES },
-    { VLC_CODEC_U8, AV_CODEC_ID_PCM_U8, AUDIO_ES },
-    { VLC_CODEC_MULAW, AV_CODEC_ID_PCM_MULAW, AUDIO_ES },
-    { VLC_CODEC_ALAW, AV_CODEC_ID_PCM_ALAW, AUDIO_ES },
-    { VLC_CODEC_S32L, AV_CODEC_ID_PCM_S32LE, AUDIO_ES },
-    { VLC_CODEC_S32B, AV_CODEC_ID_PCM_S32BE, AUDIO_ES },
-    { VLC_CODEC_U32L, AV_CODEC_ID_PCM_U32LE, AUDIO_ES },
-    { VLC_CODEC_U32B, AV_CODEC_ID_PCM_U32BE, AUDIO_ES },
-    { VLC_CODEC_S24L, AV_CODEC_ID_PCM_S24LE, AUDIO_ES },
-    { VLC_CODEC_S24B, AV_CODEC_ID_PCM_S24BE, AUDIO_ES },
-    { VLC_CODEC_U24L, AV_CODEC_ID_PCM_U24LE, AUDIO_ES },
-    { VLC_CODEC_U24B, AV_CODEC_ID_PCM_U24BE, AUDIO_ES },
-    { VLC_CODEC_S24DAUD, AV_CODEC_ID_PCM_S24DAUD, AUDIO_ES },
+    { VLC_CODEC_S16L, AV_CODEC_ID_PCM_S16LE },
+    { VLC_CODEC_S16B, AV_CODEC_ID_PCM_S16BE },
+    { VLC_CODEC_U16L, AV_CODEC_ID_PCM_U16LE },
+    { VLC_CODEC_U16B, AV_CODEC_ID_PCM_U16BE },
+    { VLC_CODEC_S8, AV_CODEC_ID_PCM_S8 },
+    { VLC_CODEC_U8, AV_CODEC_ID_PCM_U8 },
+    { VLC_CODEC_MULAW, AV_CODEC_ID_PCM_MULAW },
+    { VLC_CODEC_ALAW, AV_CODEC_ID_PCM_ALAW },
+    { VLC_CODEC_S32L, AV_CODEC_ID_PCM_S32LE },
+    { VLC_CODEC_S32B, AV_CODEC_ID_PCM_S32BE },
+    { VLC_CODEC_U32L, AV_CODEC_ID_PCM_U32LE },
+    { VLC_CODEC_U32B, AV_CODEC_ID_PCM_U32BE },
+    { VLC_CODEC_S24L, AV_CODEC_ID_PCM_S24LE },
+    { VLC_CODEC_S24B, AV_CODEC_ID_PCM_S24BE },
+    { VLC_CODEC_U24L, AV_CODEC_ID_PCM_U24LE },
+    { VLC_CODEC_U24B, AV_CODEC_ID_PCM_U24BE },
+    { VLC_CODEC_S24DAUD, AV_CODEC_ID_PCM_S24DAUD },
     /* AV_CODEC_ID_PCM_ZORK */
-    /* AV_CODEC_ID_PCM_S16LE_PLANAR */
+    { VLC_CODEC_S16L_PLANAR, AV_CODEC_ID_PCM_S16LE_PLANAR },
     /* AV_CODEC_ID_PCM_DVD */
-    { VLC_CODEC_F32B, AV_CODEC_ID_PCM_F32BE, AUDIO_ES },
-    { VLC_CODEC_F32L, AV_CODEC_ID_PCM_F32LE, AUDIO_ES },
-    { VLC_CODEC_F64B, AV_CODEC_ID_PCM_F64BE, AUDIO_ES },
-    { VLC_CODEC_F64L, AV_CODEC_ID_PCM_F64LE, AUDIO_ES },
-    { VLC_CODEC_BD_LPCM, AV_CODEC_ID_PCM_BLURAY, AUDIO_ES },
+    { VLC_CODEC_F32B, AV_CODEC_ID_PCM_F32BE },
+    { VLC_CODEC_F32L, AV_CODEC_ID_PCM_F32LE },
+    { VLC_CODEC_F64B, AV_CODEC_ID_PCM_F64BE },
+    { VLC_CODEC_F64L, AV_CODEC_ID_PCM_F64LE },
+    { VLC_CODEC_BD_LPCM, AV_CODEC_ID_PCM_BLURAY },
     /* AV_CODEC_ID_PCM_LXF */
     /* AV_CODEC_ID_S302M */
     /* AV_CODEC_ID_PCM_S8_PLANAR */
@@ -332,36 +341,36 @@ static const struct
     /* ffmpeg only: AV_CODEC_ID_PCM_S16BE_PLANAR */
 
     /* ADPCM */
-    { VLC_CODEC_ADPCM_IMA_QT, AV_CODEC_ID_ADPCM_IMA_QT, AUDIO_ES },
-    { VLC_CODEC_ADPCM_IMA_WAV, AV_CODEC_ID_ADPCM_IMA_WAV, AUDIO_ES },
+    { VLC_CODEC_ADPCM_IMA_QT, AV_CODEC_ID_ADPCM_IMA_QT },
+    { VLC_CODEC_ADPCM_IMA_WAV, AV_CODEC_ID_ADPCM_IMA_WAV },
     /* AV_CODEC_ID_ADPCM_IMA_DK3 */
     /* AV_CODEC_ID_ADPCM_IMA_DK4 */
-    { VLC_CODEC_ADPCM_IMA_WS, AV_CODEC_ID_ADPCM_IMA_WS, AUDIO_ES },
+    { VLC_CODEC_ADPCM_IMA_WS, AV_CODEC_ID_ADPCM_IMA_WS },
     /* AV_CODEC_ID_ADPCM_IMA_SMJPEG */
-    { VLC_CODEC_ADPCM_MS, AV_CODEC_ID_ADPCM_MS, AUDIO_ES },
-    { VLC_CODEC_ADPCM_4XM, AV_CODEC_ID_ADPCM_4XM, AUDIO_ES },
-    { VLC_CODEC_ADPCM_XA, AV_CODEC_ID_ADPCM_XA, AUDIO_ES },
-    { VLC_CODEC_ADPCM_ADX, AV_CODEC_ID_ADPCM_ADX, AUDIO_ES },
-    { VLC_CODEC_ADPCM_EA, AV_CODEC_ID_ADPCM_EA, AUDIO_ES },
-    { VLC_CODEC_ADPCM_G726, AV_CODEC_ID_ADPCM_G726, AUDIO_ES },
-    /* AV_CODEC_ID_ADPCM_CT */
-    { VLC_CODEC_ADPCM_SWF, AV_CODEC_ID_ADPCM_SWF, AUDIO_ES },
-    { VLC_CODEC_ADPCM_YAMAHA, AV_CODEC_ID_ADPCM_YAMAHA, AUDIO_ES },
-    /* AV_CODEC_ID_ADPCM_SBPRO_4 */
-    /* AV_CODEC_ID_ADPCM_SBPRO_3 */
-    /* AV_CODEC_ID_ADPCM_SBPRO_2 */
-    { VLC_CODEC_ADPCM_THP, AV_CODEC_ID_ADPCM_THP, AUDIO_ES },
-    { VLC_CODEC_ADPCM_IMA_AMV, AV_CODEC_ID_ADPCM_IMA_AMV, AUDIO_ES },
-    /* AV_CODEC_ID_ADPCM_EA_R1 */
+    { VLC_CODEC_ADPCM_MS, AV_CODEC_ID_ADPCM_MS },
+    { VLC_CODEC_ADPCM_4XM, AV_CODEC_ID_ADPCM_4XM },
+    { VLC_CODEC_ADPCM_XA, AV_CODEC_ID_ADPCM_XA },
+    { VLC_CODEC_ADPCM_ADX, AV_CODEC_ID_ADPCM_ADX },
+    { VLC_CODEC_ADPCM_EA, AV_CODEC_ID_ADPCM_EA },
+    { VLC_CODEC_ADPCM_G726, AV_CODEC_ID_ADPCM_G726 },
+    { VLC_CODEC_ADPCM_CREATIVE, AV_CODEC_ID_ADPCM_CT },
+    { VLC_CODEC_ADPCM_SWF, AV_CODEC_ID_ADPCM_SWF },
+    { VLC_CODEC_ADPCM_YAMAHA, AV_CODEC_ID_ADPCM_YAMAHA },
+    { VLC_CODEC_ADPCM_SBPRO_4, AV_CODEC_ID_ADPCM_SBPRO_4 },
+    { VLC_CODEC_ADPCM_SBPRO_3, AV_CODEC_ID_ADPCM_SBPRO_3 },
+    { VLC_CODEC_ADPCM_SBPRO_2, AV_CODEC_ID_ADPCM_SBPRO_2 },
+    { VLC_CODEC_ADPCM_THP, AV_CODEC_ID_ADPCM_THP },
+    { VLC_CODEC_ADPCM_IMA_AMV, AV_CODEC_ID_ADPCM_IMA_AMV },
+    { VLC_CODEC_ADPCM_EA_R1, AV_CODEC_ID_ADPCM_EA_R1 },
     /* AV_CODEC_ID_ADPCM_EA_R3 */
     /* AV_CODEC_ID_ADPCM_EA_R2 */
-    /* AV_CODEC_ID_ADPCM_IMA_EA_SEAD */
+    { VLC_CODEC_ADPCM_IMA_EA_SEAD, AV_CODEC_ID_ADPCM_IMA_EA_SEAD },
     /* AV_CODEC_ID_ADPCM_IMA_EA_EACS */
     /* AV_CODEC_ID_ADPCM_EA_XAS */
     /* AV_CODEC_ID_ADPCM_EA_MAXIS_XA */
     /* AV_CODEC_ID_ADPCM_IMA_ISS */
-    { VLC_CODEC_ADPCM_G722, AV_CODEC_ID_ADPCM_G722, AUDIO_ES },
-    /* AV_CODEC_ID_ADPCM_IMA_APC */
+    { VLC_CODEC_ADPCM_G722, AV_CODEC_ID_ADPCM_G722 },
+    { VLC_CODEC_ADPCM_IMA_APC, AV_CODEC_ID_ADPCM_IMA_APC },
     /* ffmpeg only: AV_CODEC_ID_VIMA */
     /* ffmpeg only: AV_CODEC_ID_ADPCM_AFC */
     /* ffmpeg only: AV_CODEC_ID_ADPCM_IMA_OKI */
@@ -370,105 +379,90 @@ static const struct
     /* ffmpeg only: AV_CODEC_ID_ADPCM_G726LE */
 
     /* AMR */
-    { VLC_CODEC_AMR_NB, AV_CODEC_ID_AMR_NB, AUDIO_ES },
-    { VLC_CODEC_AMR_WB, AV_CODEC_ID_AMR_WB, AUDIO_ES },
+    { VLC_CODEC_AMR_NB, AV_CODEC_ID_AMR_NB },
+    { VLC_CODEC_AMR_WB, AV_CODEC_ID_AMR_WB },
 
     /* RealAudio */
-    { VLC_CODEC_RA_144, AV_CODEC_ID_RA_144, AUDIO_ES },
-    { VLC_CODEC_RA_288, AV_CODEC_ID_RA_288, AUDIO_ES },
+    { VLC_CODEC_RA_144, AV_CODEC_ID_RA_144 },
+    { VLC_CODEC_RA_288, AV_CODEC_ID_RA_288 },
 
     /* DPCM */
-    { VLC_CODEC_ROQ_DPCM, AV_CODEC_ID_ROQ_DPCM, AUDIO_ES },
-    { VLC_CODEC_INTERPLAY_DPCM, AV_CODEC_ID_INTERPLAY_DPCM, AUDIO_ES },
+    { VLC_CODEC_ROQ_DPCM, AV_CODEC_ID_ROQ_DPCM },
+    { VLC_CODEC_INTERPLAY_DPCM, AV_CODEC_ID_INTERPLAY_DPCM },
     /* AV_CODEC_ID_XAN_DPCM */
     /* AV_CODEC_ID_SOL_DPCM */
 
     /* audio codecs */
-    { VLC_CODEC_MP3, AV_CODEC_ID_MP3, AUDIO_ES },
-    { VLC_CODEC_MPGA, AV_CODEC_ID_MP2, AUDIO_ES },
-    { VLC_CODEC_MP2, AV_CODEC_ID_MP2, AUDIO_ES },
-    { VLC_CODEC_MP4A, AV_CODEC_ID_AAC, AUDIO_ES },
-    { VLC_CODEC_A52, AV_CODEC_ID_AC3, AUDIO_ES },
-    { VLC_CODEC_DTS, AV_CODEC_ID_DTS, AUDIO_ES },
-    { VLC_CODEC_VORBIS, AV_CODEC_ID_VORBIS, AUDIO_ES },
-    { VLC_CODEC_DVAUDIO, AV_CODEC_ID_DVAUDIO, AUDIO_ES },
-    { VLC_CODEC_WMA1, AV_CODEC_ID_WMAV1, AUDIO_ES },
-    { VLC_CODEC_WMA2, AV_CODEC_ID_WMAV2, AUDIO_ES },
-    { VLC_CODEC_MACE3, AV_CODEC_ID_MACE3, AUDIO_ES },
-    { VLC_CODEC_MACE6, AV_CODEC_ID_MACE6, AUDIO_ES },
-    { VLC_CODEC_VMDAUDIO, AV_CODEC_ID_VMDAUDIO, AUDIO_ES },
-    { VLC_CODEC_FLAC, AV_CODEC_ID_FLAC, AUDIO_ES },
+    { VLC_CODEC_MPGA, AV_CODEC_ID_MP2 },
+    { VLC_CODEC_MP2, AV_CODEC_ID_MP2 },
+    { VLC_CODEC_MP3, AV_CODEC_ID_MP3 },
+    { VLC_CODEC_MP4A, AV_CODEC_ID_AAC },
+    { VLC_CODEC_A52, AV_CODEC_ID_AC3 },
+    { VLC_CODEC_DTS, AV_CODEC_ID_DTS },
+    { VLC_CODEC_VORBIS, AV_CODEC_ID_VORBIS },
+    { VLC_CODEC_DVAUDIO, AV_CODEC_ID_DVAUDIO },
+    { VLC_CODEC_WMA1, AV_CODEC_ID_WMAV1 },
+    { VLC_CODEC_WMA2, AV_CODEC_ID_WMAV2 },
+    { VLC_CODEC_MACE3, AV_CODEC_ID_MACE3 },
+    { VLC_CODEC_MACE6, AV_CODEC_ID_MACE6 },
+    { VLC_CODEC_VMDAUDIO, AV_CODEC_ID_VMDAUDIO },
+    { VLC_CODEC_FLAC, AV_CODEC_ID_FLAC },
     /* AV_CODEC_ID_MP3ADU */
     /* AV_CODEC_ID_MP3ON4 */
-    { VLC_CODEC_SHORTEN, AV_CODEC_ID_SHORTEN, AUDIO_ES },
-    { VLC_CODEC_ALAC, AV_CODEC_ID_ALAC, AUDIO_ES },
+    { VLC_CODEC_SHORTEN, AV_CODEC_ID_SHORTEN },
+    { VLC_CODEC_ALAC, AV_CODEC_ID_ALAC },
     /* AV_CODEC_ID_WESTWOOD_SND1 */
-    { VLC_CODEC_GSM, AV_CODEC_ID_GSM, AUDIO_ES },
-    { VLC_CODEC_QDM2, AV_CODEC_ID_QDM2, AUDIO_ES },
-    { VLC_CODEC_COOK, AV_CODEC_ID_COOK, AUDIO_ES },
-    { VLC_CODEC_TRUESPEECH, AV_CODEC_ID_TRUESPEECH, AUDIO_ES },
-    { VLC_CODEC_TTA, AV_CODEC_ID_TTA, AUDIO_ES },
-    { VLC_CODEC_SMACKAUDIO, AV_CODEC_ID_SMACKAUDIO, AUDIO_ES },
-    { VLC_CODEC_QCELP, AV_CODEC_ID_QCELP, AUDIO_ES },
-    { VLC_CODEC_WAVPACK, AV_CODEC_ID_WAVPACK, AUDIO_ES },
-    { VLC_CODEC_DSICINAUDIO, AV_CODEC_ID_DSICINAUDIO, AUDIO_ES },
-    { VLC_CODEC_IMC, AV_CODEC_ID_IMC, AUDIO_ES },
-    { VLC_CODEC_MUSEPACK7, AV_CODEC_ID_MUSEPACK7, AUDIO_ES },
-    { VLC_CODEC_MLP, AV_CODEC_ID_MLP, AUDIO_ES },
-    { VLC_CODEC_GSM_MS, AV_CODEC_ID_GSM_MS, AUDIO_ES },
-    { VLC_CODEC_ATRAC3, AV_CODEC_ID_ATRAC3, AUDIO_ES },
-    { VLC_CODEC_APE, AV_CODEC_ID_APE, AUDIO_ES },
-    { VLC_CODEC_NELLYMOSER, AV_CODEC_ID_NELLYMOSER, AUDIO_ES },
-    { VLC_CODEC_MUSEPACK8, AV_CODEC_ID_MUSEPACK8, AUDIO_ES },
-    { VLC_CODEC_SPEEX, AV_CODEC_ID_SPEEX, AUDIO_ES },
-    { VLC_CODEC_WMAS, AV_CODEC_ID_WMAVOICE, AUDIO_ES },
-    { VLC_CODEC_WMAP, AV_CODEC_ID_WMAPRO, AUDIO_ES },
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 54, 5, 0 )
-    { VLC_CODEC_WMAL, AV_CODEC_ID_WMALOSSLESS, AUDIO_ES },
-#endif
-#if LIBAVCODEC_VERSION_CHECK( 55, 32, 0, 47, 100 )
-    { VLC_CODEC_ATRAC3P, AV_CODEC_ID_ATRAC3P, AUDIO_ES },
+    { VLC_CODEC_GSM, AV_CODEC_ID_GSM },
+    { VLC_CODEC_QDM2, AV_CODEC_ID_QDM2 },
+#if LIBAVCODEC_VERSION_CHECK( 57, 999, 999, 71, 100 )
+    { VLC_CODEC_QDMC, AV_CODEC_ID_QDMC },
 #endif
-    { VLC_CODEC_EAC3, AV_CODEC_ID_EAC3, AUDIO_ES },
-    { VLC_CODEC_SIPR, AV_CODEC_ID_SIPR, AUDIO_ES },
+    { VLC_CODEC_COOK, AV_CODEC_ID_COOK },
+    { VLC_CODEC_TRUESPEECH, AV_CODEC_ID_TRUESPEECH },
+    { VLC_CODEC_TTA, AV_CODEC_ID_TTA },
+    { VLC_CODEC_SMACKAUDIO, AV_CODEC_ID_SMACKAUDIO },
+    { VLC_CODEC_QCELP, AV_CODEC_ID_QCELP },
+    { VLC_CODEC_WAVPACK, AV_CODEC_ID_WAVPACK },
+    { VLC_CODEC_DSICINAUDIO, AV_CODEC_ID_DSICINAUDIO },
+    { VLC_CODEC_IMC, AV_CODEC_ID_IMC },
+    { VLC_CODEC_MUSEPACK7, AV_CODEC_ID_MUSEPACK7 },
+    { VLC_CODEC_MLP, AV_CODEC_ID_MLP },
+    { VLC_CODEC_GSM_MS, AV_CODEC_ID_GSM_MS },
+    { VLC_CODEC_ATRAC3, AV_CODEC_ID_ATRAC3 },
+    { VLC_CODEC_APE, AV_CODEC_ID_APE },
+    { VLC_CODEC_NELLYMOSER, AV_CODEC_ID_NELLYMOSER },
+    { VLC_CODEC_MUSEPACK8, AV_CODEC_ID_MUSEPACK8 },
+    { VLC_CODEC_SPEEX, AV_CODEC_ID_SPEEX },
+    { VLC_CODEC_WMAS, AV_CODEC_ID_WMAVOICE },
+    { VLC_CODEC_WMAP, AV_CODEC_ID_WMAPRO },
+    { VLC_CODEC_WMAL, AV_CODEC_ID_WMALOSSLESS },
+    { VLC_CODEC_ATRAC3P, AV_CODEC_ID_ATRAC3P },
+    { VLC_CODEC_EAC3, AV_CODEC_ID_EAC3 },
+    { VLC_CODEC_SIPR, AV_CODEC_ID_SIPR },
     /* AV_CODEC_ID_MP1 */
-    { VLC_CODEC_TWINVQ, AV_CODEC_ID_TWINVQ, AUDIO_ES },
-    { VLC_CODEC_TRUEHD, AV_CODEC_ID_TRUEHD, AUDIO_ES },
-    { VLC_CODEC_ALS, AV_CODEC_ID_MP4ALS, AUDIO_ES },
-    { VLC_CODEC_ATRAC1, AV_CODEC_ID_ATRAC1, AUDIO_ES },
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 52, 55, 0 )
-    { VLC_CODEC_BINKAUDIO_DCT, AV_CODEC_ID_BINKAUDIO_DCT, AUDIO_ES },
-    { VLC_CODEC_BINKAUDIO_RDFT, AV_CODEC_ID_BINKAUDIO_RDFT, AUDIO_ES },
-#endif
-    { VLC_CODEC_MP4A, AV_CODEC_ID_AAC_LATM, AUDIO_ES },
+    { VLC_CODEC_TWINVQ, AV_CODEC_ID_TWINVQ },
+    { VLC_CODEC_TRUEHD, AV_CODEC_ID_TRUEHD },
+    { VLC_CODEC_ALS, AV_CODEC_ID_MP4ALS },
+    { VLC_CODEC_ATRAC1, AV_CODEC_ID_ATRAC1 },
+    { VLC_CODEC_BINKAUDIO_RDFT, AV_CODEC_ID_BINKAUDIO_RDFT },
+    { VLC_CODEC_BINKAUDIO_DCT, AV_CODEC_ID_BINKAUDIO_DCT },
+    { VLC_CODEC_MP4A, AV_CODEC_ID_AAC_LATM },
     /* AV_CODEC_ID_QDMC */
     /* AV_CODEC_ID_CELT */
-    { VLC_CODEC_G723_1, AV_CODEC_ID_G723_1, AUDIO_ES },
+    { VLC_CODEC_G723_1, AV_CODEC_ID_G723_1 },
     /* AV_CODEC_ID_G729 */
     /* AV_CODEC_ID_8SVX_EXP */
     /* AV_CODEC_ID_8SVX_FIB */
-    { VLC_CODEC_BMVAUDIO, AV_CODEC_ID_BMV_AUDIO, AUDIO_ES },
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 54, 12, 0 )
-    { VLC_CODEC_RALF, AV_CODEC_ID_RALF, AUDIO_ES },
-#endif
-#if LIBAVCODEC_VERSION_CHECK( 54, 14, 0, 26, 100 )
-    { VLC_CODEC_INDEO_AUDIO, AV_CODEC_ID_IAC, AUDIO_ES },
-#endif
+    { VLC_CODEC_BMVAUDIO, AV_CODEC_ID_BMV_AUDIO },
+    { VLC_CODEC_RALF, AV_CODEC_ID_RALF },
+    { VLC_CODEC_INDEO_AUDIO, AV_CODEC_ID_IAC },
     /* AV_CODEC_ID_ILBC */
-#if LIBAVCODEC_VERSION_CHECK( 54, 29, 0, 17, 101 )
-    { VLC_CODEC_OPUS, AV_CODEC_ID_OPUS, AUDIO_ES },
-#endif
+    { VLC_CODEC_OPUS, AV_CODEC_ID_OPUS },
     /* AV_CODEC_ID_COMFORT_NOISE */
-#if LIBAVCODEC_VERSION_CHECK( 54, 34, 0, 65, 100 )
-    { VLC_CODEC_TAK, AV_CODEC_ID_TAK, AUDIO_ES },
-#endif
-#if LIBAVCODEC_VERSION_CHECK( 55, 15, 0, 24, 100 )
-    { VLC_CODEC_METASOUND, AV_CODEC_ID_METASOUND, AUDIO_ES },
-#endif
+    { VLC_CODEC_TAK, AV_CODEC_ID_TAK },
+    { VLC_CODEC_METASOUND, AV_CODEC_ID_METASOUND },
     /* AV_CODEC_ID_PAF_AUDIO */
-#if LIBAVCODEC_VERSION_CHECK( 55, 49, 0, 59, 100 )
-    { VLC_CODEC_ON2AVC, AV_CODEC_ID_ON2AVC, AUDIO_ES },
-#endif
+    { VLC_CODEC_ON2AVC, AV_CODEC_ID_ON2AVC },
 
     /* ffmpeg only: AV_CODEC_ID_FFWAVESYNTH */
     /* ffmpeg only: AV_CODEC_ID_SONIC */
@@ -476,16 +470,22 @@ static const struct
     /* ffmpeg only: AV_CODEC_ID_PAF_AUDIO */
     /* ffmpeg only: AV_CODEC_ID_EVRC */
     /* ffmpeg only: AV_CODEC_ID_SMV */
+};
 
-    /* Subtitle streams */
-    { VLC_CODEC_SPU, AV_CODEC_ID_DVD_SUBTITLE, SPU_ES },
-    { VLC_CODEC_DVBS, AV_CODEC_ID_DVB_SUBTITLE, SPU_ES },
-    { VLC_CODEC_SUBT, AV_CODEC_ID_TEXT, SPU_ES },
-    { VLC_CODEC_XSUB, AV_CODEC_ID_XSUB, SPU_ES },
-    { VLC_CODEC_SSA, AV_CODEC_ID_SSA, SPU_ES },
-    /* AV_CODEC_ID_MOV_TEXT */
-    { VLC_CODEC_BD_PG, AV_CODEC_ID_HDMV_PGS_SUBTITLE, SPU_ES },
-    { VLC_CODEC_TELETEXT, AV_CODEC_ID_DVB_TELETEXT, SPU_ES },
+/* Subtitle streams */
+static const struct vlc_avcodec_fourcc spu_codecs[] =
+{
+    { VLC_CODEC_SPU, AV_CODEC_ID_DVD_SUBTITLE },
+    { VLC_CODEC_DVBS, AV_CODEC_ID_DVB_SUBTITLE },
+    { VLC_CODEC_SUBT, AV_CODEC_ID_TEXT },
+    { VLC_CODEC_XSUB, AV_CODEC_ID_XSUB },
+    { VLC_CODEC_SSA, AV_CODEC_ID_SSA },
+    { VLC_CODEC_TX3G, AV_CODEC_ID_MOV_TEXT },
+    { VLC_CODEC_BD_PG, AV_CODEC_ID_HDMV_PGS_SUBTITLE },
+#if LIBAVCODEC_VERSION_CHECK( 57, 999, 999, 71, 100 )
+    { VLC_CODEC_BD_TEXT, AV_CODEC_ID_HDMV_TEXT_SUBTITLE },
+#endif
+    { VLC_CODEC_TELETEXT, AV_CODEC_ID_DVB_TELETEXT },
     /* AV_CODEC_ID_SRT */
     /* ffmpeg only: AV_CODEC_ID_MICRODVD */
     /* ffmpeg only: AV_CODEC_ID_EIA_608 */
@@ -502,40 +502,63 @@ static const struct
     /* ffmpeg only: AV_CODEC_ID_ASS */
 };
 
-static const size_t codecs_count = sizeof (codecs_table)
-                                 / sizeof (codecs_table[0]);
-
-int GetFfmpegCodec( vlc_fourcc_t i_fourcc, int *pi_cat,
-                    unsigned *pi_ffmpeg_codec, const char **ppsz_name )
+bool GetFfmpegCodec( enum es_format_category_e cat, vlc_fourcc_t i_fourcc,
+                     unsigned *pi_ffmpeg_codec, const char **ppsz_name )
 {
-    i_fourcc = vlc_fourcc_GetCodec( UNKNOWN_ES, i_fourcc );
-    for( unsigned i = 0; i < codecs_count; i++ )
+    const struct vlc_avcodec_fourcc *base;
+    size_t count;
+
+    switch( cat )
     {
-        if( codecs_table[i].i_fourcc == i_fourcc )
-        {
-            if( pi_cat ) *pi_cat = codecs_table[i].i_cat;
-            if( pi_ffmpeg_codec ) *pi_ffmpeg_codec = codecs_table[i].i_codec;
-            if( ppsz_name ) *ppsz_name = vlc_fourcc_GetDescription( UNKNOWN_ES, i_fourcc );//char *)codecs_table[i].psz_name;
+        case VIDEO_ES:
+            base = video_codecs;
+            count = ARRAY_SIZE(video_codecs);
+            break;
+        case AUDIO_ES:
+            base = audio_codecs;
+            count = ARRAY_SIZE(audio_codecs);
+            break;
+        case SPU_ES:
+            base = spu_codecs;
+            count = ARRAY_SIZE(spu_codecs);
+            break;
+        default:
+            base = NULL;
+            count = 0;
+    }
+
+    i_fourcc = vlc_fourcc_GetCodec( cat, i_fourcc );
 
+    for( size_t i = 0; i < count; i++ )
+    {
+        if( base[i].i_fourcc == i_fourcc )
+        {
+            if( pi_ffmpeg_codec != NULL )
+                *pi_ffmpeg_codec = base[i].i_codec;
+            if( ppsz_name )
+                *ppsz_name = vlc_fourcc_GetDescription( cat, i_fourcc );
             return true;
         }
     }
     return false;
 }
 
-int GetVlcFourcc( unsigned i_ffmpeg_codec, int *pi_cat,
-                  vlc_fourcc_t *pi_fourcc, const char **ppsz_name )
+vlc_fourcc_t GetVlcFourcc( unsigned i_ffmpeg_codec )
 {
-    for( unsigned i = 0; i < codecs_count; i++ )
+    for( size_t i = 0; i < ARRAY_SIZE(video_codecs); i++ )
     {
-        if( codecs_table[i].i_codec == i_ffmpeg_codec )
-        {
-            if( pi_cat ) *pi_cat = codecs_table[i].i_cat;
-            if( pi_fourcc ) *pi_fourcc = codecs_table[i].i_fourcc;
-            if( ppsz_name ) *ppsz_name = vlc_fourcc_GetDescription( codecs_table[i].i_cat, codecs_table[i].i_fourcc );
-
-            return true;
-        }
+        if( video_codecs[i].i_codec == i_ffmpeg_codec )
+            return video_codecs[i].i_fourcc;
     }
-    return false;
+    for( size_t i = 0; i < ARRAY_SIZE(audio_codecs); i++ )
+    {
+        if( audio_codecs[i].i_codec == i_ffmpeg_codec )
+            return audio_codecs[i].i_fourcc;
+    }
+    for( size_t i = 0; i < ARRAY_SIZE(spu_codecs); i++ )
+    {
+        if( spu_codecs[i].i_codec == i_ffmpeg_codec )
+            return spu_codecs[i].i_fourcc;
+    }
+    return VLC_CODEC_UNKNOWN;
 }
diff --git modules/codec/avcodec/hwdummy.c modules/codec/avcodec/hwdummy.c
deleted file mode 100644
index eecebae4e..000000000
--- modules/codec/avcodec/hwdummy.c
+++ /dev/null
@@ -1,139 +0,0 @@
-/*****************************************************************************
- * hwdummy.c: dummy hardware decoding acceleration plugin for VLC/libav
- *****************************************************************************
- * Copyright (C) 2013 Rémi Denis-Courmont
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2.1 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-#ifdef HAVE_CONFIG_H
-# include "config.h"
-#endif
-
-#include <string.h>
-#include <stdlib.h>
-#include <assert.h>
-
-#include <libavutil/mem.h>
-#include <libavcodec/avcodec.h>
-#include <libavcodec/vdpau.h>
-#include <vlc_common.h>
-#include <vlc_plugin.h>
-#include <vlc_fourcc.h>
-#include <vlc_picture.h>
-#include "../../codec/avcodec/va.h"
-
-static int Open(vlc_va_t *, AVCodecContext *, const es_format_t *);
-static void Close(vlc_va_t *);
-
-vlc_module_begin()
-    set_description(N_("Dummy video decoder"))
-    set_capability("hw decoder", 0)
-    set_category(CAT_INPUT)
-    set_subcategory(SUBCAT_INPUT_VCODEC)
-    set_callbacks(Open, Close)
-    add_shortcut("dummy")
-vlc_module_end()
-
-#define DECODER_MAGIC 0xdec0dea0
-#define DATA_MAGIC    0xda1a0000
-#define OPAQUE_MAGIC  0x0da00e00
-
-static int Lock(vlc_va_t *va, void **opaque, uint8_t **data)
-{
-    *data = (void *)(uintptr_t)DATA_MAGIC;
-    *opaque = (void *)(uintptr_t)OPAQUE_MAGIC;
-    (void) va;
-    return VLC_SUCCESS;
-}
-
-static void Unlock(void *opaque, uint8_t *data)
-{
-    assert((uintptr_t)opaque == OPAQUE_MAGIC);
-    assert((uintptr_t)data == DATA_MAGIC);
-}
-
-static VdpStatus Render(VdpDecoder decoder, VdpVideoSurface target,
-                        VdpPictureInfo const *picture_info,
-                        uint32_t bitstream_buffer_count,
-                        VdpBitstreamBuffer const *bitstream_buffers)
-{
-    (void) decoder; (void) target; (void) picture_info;
-    (void) bitstream_buffer_count; (void) bitstream_buffers;
-    assert(decoder == DECODER_MAGIC);
-    assert(target == DATA_MAGIC);
-    return VDP_STATUS_OK;
-}
-
-static int Copy(vlc_va_t *va, picture_t *pic, void *opaque, uint8_t *data)
-{
-    (void) va;
-
-    assert((uintptr_t)opaque == OPAQUE_MAGIC);
-    assert((uintptr_t)data == DATA_MAGIC);
-
-    /* Put some dummy picture content */
-    memset(pic->p[0].p_pixels, 0xF0,
-           pic->p[0].i_pitch * pic->p[0].i_visible_lines);
-    for (int i = 0; i < pic->p[1].i_visible_lines; i++)
-        memset(pic->p[1].p_pixels + (i * pic->p[1].i_pitch), i,
-               pic->p[1].i_visible_pitch);
-    for (int i = 0; i < pic->p[2].i_visible_lines; i++)
-        for (int j = 0; j < pic->p[2].i_visible_pitch; j++)
-            pic->p[2].p_pixels[(i * pic->p[2].i_pitch) + j] = j;
-    return VLC_SUCCESS;
-}
-
-static int Setup(vlc_va_t *va, void **ctxp, vlc_fourcc_t *chromap,
-                 int width, int height)
-{
-    (void) width; (void) height;
-    *ctxp = (AVVDPAUContext *)va->sys;
-    *chromap = VLC_CODEC_YV12;
-    return VLC_SUCCESS;
-}
-
-static int Open(vlc_va_t *va, AVCodecContext *ctx, const es_format_t *fmt)
-{
-    union
-    {
-        char str[4];
-        vlc_fourcc_t fourcc;
-    } u = { .fourcc = fmt->i_codec };
-
-    AVVDPAUContext *hwctx = av_vdpau_alloc_context();
-    if (unlikely(hwctx == NULL))
-       return VLC_ENOMEM;
-
-    msg_Dbg(va, "codec %d (%4.4s) profile %d level %d", ctx->codec_id, u.str,
-            fmt->i_profile, fmt->i_level);
-
-    hwctx->decoder = DECODER_MAGIC;
-    hwctx->render = Render;
-
-    va->sys = (vlc_va_sys_t *)hwctx;
-    va->description = "Dummy video decoding accelerator";
-    va->pix_fmt = AV_PIX_FMT_VDPAU;
-    va->setup = Setup;
-    va->get = Lock;
-    va->release = Unlock;
-    va->extract = Copy;
-    return VLC_SUCCESS;
-}
-
-static void Close(vlc_va_t *va)
-{
-    av_free(va->sys);
-}
diff --git modules/codec/avcodec/subtitle.c modules/codec/avcodec/subtitle.c
index db2fbf4c4..91c391115 100644
--- modules/codec/avcodec/subtitle.c
+++ modules/codec/avcodec/subtitle.c
@@ -38,50 +38,82 @@
 
 #include "avcodec.h"
 
-struct decoder_sys_t {
-    AVCODEC_COMMON_MEMBERS
-};
+typedef struct
+{
+    AVCodecContext *p_context;
+    const AVCodec  *p_codec;
+    bool b_need_ephemer; /* Does the format need the ephemer flag (no end time set) */
+} decoder_sys_t;
 
 static subpicture_t *ConvertSubtitle(decoder_t *, AVSubtitle *, mtime_t pts,
                                      AVCodecContext *avctx);
+static int  DecodeSubtitle(decoder_t *, block_t *);
+static void Flush(decoder_t *);
 
 /**
  * Initialize subtitle decoder
  */
-int InitSubtitleDec(decoder_t *dec, AVCodecContext *context,
-                    AVCodec *codec, int codec_id, const char *namecodec)
+int InitSubtitleDec(vlc_object_t *obj)
 {
+    decoder_t *dec = (decoder_t *)obj;
+    const AVCodec *codec;
+    AVCodecContext *context = ffmpeg_AllocContext(dec, &codec);
+    if (context == NULL)
+        return VLC_EGENERIC;
+
     decoder_sys_t *sys;
 
     /* */
-    switch (codec_id) {
+    switch (codec->id) {
     case AV_CODEC_ID_HDMV_PGS_SUBTITLE:
     case AV_CODEC_ID_XSUB:
     case AV_CODEC_ID_DVB_SUBTITLE:
         break;
     default:
         msg_Warn(dec, "refusing to decode non validated subtitle codec");
+        avcodec_free_context(&context);
         return VLC_EGENERIC;
     }
 
     /* */
     dec->p_sys = sys = malloc(sizeof(*sys));
-    if (!sys)
+    if (unlikely(sys == NULL))
+    {
+        avcodec_free_context(&context);
         return VLC_ENOMEM;
+    }
 
-    codec->type = AVMEDIA_TYPE_SUBTITLE;
-    context->codec_type = AVMEDIA_TYPE_SUBTITLE;
-    context->codec_id = codec_id;
     sys->p_context = context;
     sys->p_codec = codec;
-    sys->i_codec_id = codec_id;
-    sys->psz_namecodec = namecodec;
-    sys->b_delayed_open = false;
+    sys->b_need_ephemer = codec->id == AV_CODEC_ID_HDMV_PGS_SUBTITLE;
 
     /* */
     context->extradata_size = 0;
     context->extradata = NULL;
 
+    if( codec->id == AV_CODEC_ID_DVB_SUBTITLE )
+    {
+        if( dec->fmt_in.i_extra > 3 )
+        {
+            context->extradata = malloc( dec->fmt_in.i_extra );
+            if( context->extradata )
+            {
+                context->extradata_size = dec->fmt_in.i_extra;
+                memcpy( context->extradata, dec->fmt_in.p_extra, dec->fmt_in.i_extra );
+            }
+        }
+        else
+        {
+            context->extradata = malloc( 4 );
+            if( context->extradata )
+            {
+                context->extradata_size = 4;
+                SetWBE( &context->extradata[0], dec->fmt_in.subs.dvb.i_id & 0xFFFF );
+                SetWBE( &context->extradata[2], dec->fmt_in.subs.dvb.i_id >> 16 );
+            }
+        }
+    }
+
 #if LIBAVFORMAT_VERSION_MICRO >= 100
     av_codec_set_pkt_timebase(context, AV_TIME_BASE_Q);
 #endif
@@ -90,9 +122,10 @@ int InitSubtitleDec(decoder_t *dec, AVCodecContext *context,
     int ret;
     char *psz_opts = var_InheritString(dec, "avcodec-options");
     AVDictionary *options = NULL;
-    if (psz_opts && *psz_opts)
-        options = vlc_av_get_options(psz_opts);
-    free(psz_opts);
+    if (psz_opts) {
+        vlc_av_get_options(psz_opts, &options);
+        free(psz_opts);
+    }
 
     vlc_avcodec_lock();
     ret = avcodec_open2(context, codec, options ? &options : NULL);
@@ -105,23 +138,44 @@ int InitSubtitleDec(decoder_t *dec, AVCodecContext *context,
     av_dict_free(&options);
 
     if (ret < 0) {
-        msg_Err(dec, "cannot open codec (%s)", namecodec);
-        free(context->extradata);
+        msg_Err(dec, "cannot open codec (%s)", codec->name);
         free(sys);
+        avcodec_free_context(&context);
         return VLC_EGENERIC;
     }
 
     /* */
-    msg_Dbg(dec, "libavcodec codec (%s) started", namecodec);
-    dec->fmt_out.i_cat = SPU_ES;
+    msg_Dbg(dec, "libavcodec codec (%s) started", codec->name);
+    dec->pf_decode = DecodeSubtitle;
+    dec->pf_flush  = Flush;
 
     return VLC_SUCCESS;
 }
 
+void EndSubtitleDec(vlc_object_t *obj)
+{
+    decoder_t *dec = (decoder_t *)obj;
+    decoder_sys_t *sys = dec->p_sys;
+    AVCodecContext *ctx = sys->p_context;
+
+    avcodec_free_context(&ctx);
+    free(sys);
+}
+
+/**
+ * Flush
+ */
+static void Flush(decoder_t *dec)
+{
+    decoder_sys_t *sys = dec->p_sys;
+
+    avcodec_flush_buffers(sys->p_context);
+}
+
 /**
  * Decode one subtitle
  */
-subpicture_t *DecodeSubtitle(decoder_t *dec, block_t **block_ptr)
+static subpicture_t *DecodeBlock(decoder_t *dec, block_t **block_ptr)
 {
     decoder_sys_t *sys = dec->p_sys;
 
@@ -130,10 +184,12 @@ subpicture_t *DecodeSubtitle(decoder_t *dec, block_t **block_ptr)
 
     block_t *block = *block_ptr;
 
-    if (block->i_flags & (BLOCK_FLAG_DISCONTINUITY|BLOCK_FLAG_CORRUPTED)) {
-        block_Release(block);
-        avcodec_flush_buffers(sys->p_context);
-        return NULL;
+    if (block->i_flags & (BLOCK_FLAG_DISCONTINUITY | BLOCK_FLAG_CORRUPTED)) {
+        if (block->i_flags & BLOCK_FLAG_CORRUPTED) {
+            Flush(dec);
+            block_Release(block);
+            return NULL;
+        }
     }
 
     if (block->i_buffer <= 0) {
@@ -150,6 +206,12 @@ subpicture_t *DecodeSubtitle(decoder_t *dec, block_t **block_ptr)
     block->i_buffer -= FF_INPUT_BUFFER_PADDING_SIZE;
     memset(&block->p_buffer[block->i_buffer], 0, FF_INPUT_BUFFER_PADDING_SIZE);
 
+    if( sys->p_codec->id == AV_CODEC_ID_DVB_SUBTITLE && block->i_buffer > 3 )
+    {
+        block->p_buffer += 2; /* drop data identifier / stream id */
+        block->i_buffer -= 3; /* drop 0x3F/FF */
+    }
+
     /* */
     AVSubtitle subtitle;
     memset(&subtitle, 0, sizeof(subtitle));
@@ -190,6 +252,15 @@ subpicture_t *DecodeSubtitle(decoder_t *dec, block_t **block_ptr)
     return spu;
 }
 
+static int DecodeSubtitle(decoder_t *dec, block_t *block)
+{
+    block_t **block_ptr = block ? &block : NULL;
+    subpicture_t *spu;
+    while ((spu = DecodeBlock(dec, block_ptr)) != NULL)
+        decoder_QueueSub(dec, spu);
+    return VLCDEC_SUCCESS;
+}
+
 /**
  * Convert a RGBA libavcodec region to our format.
  */
@@ -200,7 +271,7 @@ static subpicture_region_t *ConvertRegionRGBA(AVSubtitleRect *ffregion)
 
     video_format_t fmt;
     memset(&fmt, 0, sizeof(fmt));
-    fmt.i_chroma         = VLC_FOURCC('R','G','B','A');
+    fmt.i_chroma         = VLC_CODEC_RGBA;
     fmt.i_width          =
     fmt.i_visible_width  = ffregion->w;
     fmt.i_height         =
@@ -220,11 +291,11 @@ static subpicture_region_t *ConvertRegionRGBA(AVSubtitleRect *ffregion)
     for (int y = 0; y < ffregion->h; y++) {
         for (int x = 0; x < ffregion->w; x++) {
             /* I don't think don't have paletized RGB_A_ */
-            const uint8_t index = ffregion->pict.data[0][y * ffregion->w+x];
+            const uint8_t index = ffregion->data[0][y * ffregion->w+x];
             assert(index < ffregion->nb_colors);
 
             uint32_t color;
-            memcpy(&color, &ffregion->pict.data[1][4*index], 4);
+            memcpy(&color, &ffregion->data[1][4*index], 4);
 
             uint8_t *p_rgba = &p->p_pixels[y * p->i_pitch + x * p->i_pixel_pitch];
             p_rgba[0] = (color >> 16) & 0xff;
@@ -247,12 +318,15 @@ static subpicture_t *ConvertSubtitle(decoder_t *dec, AVSubtitle *ffsub, mtime_t
     if (!spu)
         return NULL;
 
+    decoder_sys_t *p_sys = dec->p_sys;
+
     //msg_Err(dec, "%lld %d %d",
     //        pts, ffsub->start_display_time, ffsub->end_display_time);
     spu->i_start    = pts + ffsub->start_display_time * INT64_C(1000);
     spu->i_stop     = pts + ffsub->end_display_time * INT64_C(1000);
-    spu->b_absolute = true; /* FIXME How to set it right ? */
-    spu->b_ephemer  = true; /* FIXME How to set it right ? */
+    spu->b_absolute = true; /* We have offset and size for subtitle */
+    spu->b_ephemer  = p_sys->b_need_ephemer;
+                    /* We only show subtitle for i_stop time only */
 
     if (avctx->coded_width != 0 && avctx->coded_height != 0) {
         spu->i_original_picture_width = avctx->coded_width;
@@ -286,11 +360,8 @@ static subpicture_t *ConvertSubtitle(decoder_t *dec, AVSubtitle *ffsub, mtime_t
             *region_next = region;
             region_next = &region->p_next;
         }
-        /* Free AVSubtitleRect */
-        avpicture_free(&rec->pict);
-        av_free(rec);
     }
-    av_free(ffsub->rects);
+    avsubtitle_free(ffsub);
 
     return spu;
 }
diff --git modules/codec/avcodec/va.c modules/codec/avcodec/va.c
index f2b22fbe1..d1e304825 100644
--- modules/codec/avcodec/va.c
+++ modules/codec/avcodec/va.c
@@ -25,36 +25,107 @@
 
 #include <vlc_common.h>
 #include <vlc_modules.h>
+#include <vlc_fourcc.h>
+#include <libavutil/pixfmt.h>
 #include <libavcodec/avcodec.h>
 #include "va.h"
 
+vlc_fourcc_t vlc_va_GetChroma(enum PixelFormat hwfmt, enum PixelFormat swfmt)
+{
+    /* NOTE: At the time of writing this comment, the return value was only
+     * used to probe support as decoder output. So incorrect values were not
+     * fatal, especially not if a software format. */
+    switch (hwfmt)
+    {
+        case AV_PIX_FMT_VAAPI_VLD:
+            switch (swfmt)
+            {
+                case AV_PIX_FMT_YUV420P:
+                    return VLC_CODEC_VAAPI_420;
+                case AV_PIX_FMT_YUV420P10LE:
+                    return VLC_CODEC_VAAPI_420_10BPP;
+                default:
+                    return 0;
+            }
+        case AV_PIX_FMT_DXVA2_VLD:
+            switch (swfmt)
+            {
+                case AV_PIX_FMT_YUV420P10LE:
+                    return VLC_CODEC_D3D9_OPAQUE_10B;
+                default:
+                    return VLC_CODEC_D3D9_OPAQUE;
+            }
+            break;
+
+#if LIBAVUTIL_VERSION_CHECK(54, 13, 1, 24, 100)
+        case AV_PIX_FMT_D3D11VA_VLD:
+            switch (swfmt)
+            {
+                case AV_PIX_FMT_YUV420P10LE:
+                    return VLC_CODEC_D3D11_OPAQUE_10B;
+                default:
+                    return VLC_CODEC_D3D11_OPAQUE;
+            }
+        break;
+#endif
+#if (LIBAVUTIL_VERSION_INT >= AV_VERSION_INT(52, 4, 0))
+        case AV_PIX_FMT_VDPAU:
+            switch (swfmt)
+            {
+                case AV_PIX_FMT_YUVJ444P:
+                case AV_PIX_FMT_YUV444P:
+                    return VLC_CODEC_VDPAU_VIDEO_444;
+                case AV_PIX_FMT_YUVJ422P:
+                case AV_PIX_FMT_YUV422P:
+                    return VLC_CODEC_VDPAU_VIDEO_422;
+                case AV_PIX_FMT_YUVJ420P:
+                case AV_PIX_FMT_YUV420P:
+                    return VLC_CODEC_VDPAU_VIDEO_420;
+                default:
+                    return 0;
+            }
+            break;
+#endif
+        default:
+            return 0;
+    }
+}
+
 static int vlc_va_Start(void *func, va_list ap)
 {
     vlc_va_t *va = va_arg(ap, vlc_va_t *);
     AVCodecContext *ctx = va_arg(ap, AVCodecContext *);
+    enum PixelFormat pix_fmt = va_arg(ap, enum PixelFormat);
     const es_format_t *fmt = va_arg(ap, const es_format_t *);
-    int (*open)(vlc_va_t *, AVCodecContext *, const es_format_t *) = func;
+    void *p_sys = va_arg(ap, void *);
+    int (*open)(vlc_va_t *, AVCodecContext *, enum PixelFormat,
+                const es_format_t *, void *) = func;
 
-    return open(va, ctx, fmt);
+    return open(va, ctx, pix_fmt, fmt, p_sys);
 }
 
 static void vlc_va_Stop(void *func, va_list ap)
 {
     vlc_va_t *va = va_arg(ap, vlc_va_t *);
-    void (*close)(vlc_va_t *) = func;
+    void *hwctx = va_arg(ap, void *);
+    void (*close)(vlc_va_t *, void *) = func;
 
-    close(va);
+    close(va, hwctx);
 }
 
 vlc_va_t *vlc_va_New(vlc_object_t *obj, AVCodecContext *avctx,
-                     const es_format_t *fmt)
+                     enum PixelFormat pix_fmt, const es_format_t *fmt,
+                     void *p_sys)
 {
     vlc_va_t *va = vlc_object_create(obj, sizeof (*va));
     if (unlikely(va == NULL))
         return NULL;
 
-    va->module = vlc_module_load(va, "hw decoder", "$avcodec-hw", true,
-                                 vlc_va_Start, va, avctx, fmt);
+    char *modlist = var_InheritString(obj, "avcodec-hw");
+
+    va->module = vlc_module_load(va, "hw decoder", modlist, true,
+                                 vlc_va_Start, va, avctx, pix_fmt, fmt, p_sys);
+    free(modlist);
     if (va->module == NULL)
     {
         vlc_object_release(va);
@@ -63,8 +134,8 @@ vlc_va_t *vlc_va_New(vlc_object_t *obj, AVCodecContext *avctx,
     return va;
 }
 
-void vlc_va_Delete(vlc_va_t *va)
+void vlc_va_Delete(vlc_va_t *va, void **hwctx)
 {
-    vlc_module_unload(va->module, vlc_va_Stop, va);
+    vlc_module_unload(va, va->module, vlc_va_Stop, va, hwctx);
     vlc_object_release(va);
 }
diff --git modules/codec/avcodec/va.h modules/codec/avcodec/va.h
index 4a376cbec..178047ad1 100644
--- modules/codec/avcodec/va.h
+++ modules/codec/avcodec/va.h
@@ -21,6 +21,8 @@
  * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
  *****************************************************************************/
 
+#include "avcommon_compat.h"
+
 #ifndef VLC_AVCODEC_VA_H
 #define VLC_AVCODEC_VA_H 1
 
@@ -28,102 +30,55 @@ typedef struct vlc_va_t vlc_va_t;
 typedef struct vlc_va_sys_t vlc_va_sys_t;
 
 struct vlc_va_t {
-    VLC_COMMON_MEMBERS
+    struct vlc_common_members obj;
 
     vlc_va_sys_t *sys;
     module_t *module;
     const char *description;
-    int pix_fmt;
 
-    int  (*setup)(vlc_va_t *, void **hw, vlc_fourcc_t *output,
-                  int width, int height);
-    int  (*get)(vlc_va_t *, void **opaque, uint8_t **data);
-    void (*release)(void *opaque, uint8_t *surface);
-    int  (*extract)(vlc_va_t *, picture_t *dst, void *opaque, uint8_t *data);
+    int  (*get)(vlc_va_t *, picture_t *pic, uint8_t **data);
 };
 
+/**
+ * Determines the VLC video chroma value for a pair of hardware acceleration
+ * PixelFormat and software PixelFormat.
+ * @param hwfmt the hardware acceleration pixel format
+ * @param swfmt the software pixel format
+ * @return a VLC chroma value, or 0 on error.
+ */
+vlc_fourcc_t vlc_va_GetChroma(enum PixelFormat hwfmt, enum PixelFormat swfmt);
+
 /**
  * Creates an accelerated video decoding back-end for libavcodec.
  * @param obj parent VLC object
  * @param fmt VLC format of the content to decode
  * @return a new VLC object on success, NULL on error.
  */
-vlc_va_t *vlc_va_New(vlc_object_t *obj, AVCodecContext *, const es_format_t *fmt);
-
-/**
- * Initializes the acceleration video decoding back-end for libavcodec.
- * @param hw pointer to libavcodec hardware context pointer [OUT]
- * @param output pointer to video chroma output by the back-end [OUT]
- * @param width coded video width in pixels
- * @param height coded video height in pixels
- * @return VLC_SUCCESS on success, otherwise an error code.
- */
-static inline int vlc_va_Setup(vlc_va_t *va, void **hw, vlc_fourcc_t *output,
-                               int width, int height)
-{
-    return va->setup(va, hw, output, width, height);
-}
+vlc_va_t *vlc_va_New(vlc_object_t *obj, AVCodecContext *,
+                     enum PixelFormat, const es_format_t *fmt,
+                     void *p_sys);
 
 /**
  * Allocates a hardware video surface for a libavcodec frame.
  * The surface will be used as output for the hardware decoder, and possibly
  * also as a reference frame to decode other surfaces.
  *
- * @param opaque pointer to storage space for surface internal data [OUT]
+ * @param pic pointer to VLC picture being allocated [IN/OUT]
  * @param data pointer to the AVFrame data[0] and data[3] pointers [OUT]
  *
- * @note This function needs not be reentrant. However it may be called
- * concurrently with vlc_va_Extract() and/or vlc_va_Release() from other
- * threads and other frames.
+ * @note This function needs not be reentrant.
  *
- * @param frame libavcodec frame [IN/OUT]
  * @return VLC_SUCCESS on success, otherwise an error code.
  */
-static inline int vlc_va_Get(vlc_va_t *va, void **opaque, uint8_t **data)
-{
-    return va->get(va, opaque, data);
-}
-
-/**
- * Releases a hardware surface from a libavcodec frame.
- * The surface has been previously allocated with vlc_va_Get().
- *
- * @param opaque opaque data pointer of the AVFrame set by vlc_va_Get()
- * @param data data[0] pointer of the AVFrame set by vlc_va_Get()
- *
- * @note This function needs not be reentrant. However it may be called
- * concurrently with vlc_va_Get() and/or vlc_va_Extract() from other threads
- * and other frames.
- *
- * @param frame libavcodec frame previously allocated by vlc_va_Get()
- */
-static inline void vlc_va_Release(vlc_va_t *va, void *opaque, uint8_t *data)
-{
-    va->release(opaque, data);
-}
-
-/**
- * Extracts a hardware surface from a libavcodec frame into a VLC picture.
- * The surface has been previously allocated with vlc_va_Get() and decoded
- * by the libavcodec hardware acceleration.
- * The surface may still be used by libavcodec as a reference frame until it is
- * freed with vlc_va_Release().
- *
- * @note This function needs not be reentrant, but it may run concurrently with
- * vlc_va_Get() or vlc_va_Release() in other threads (with distinct frames).
- *
- * @param frame libavcodec frame previously allocated by vlc_va_Get()
- */
-static inline int vlc_va_Extract(vlc_va_t *va, picture_t *dst, void *opaque,
-                                 uint8_t *data)
+static inline int vlc_va_Get(vlc_va_t *va, picture_t *pic, uint8_t **data)
 {
-    return va->extract(va, dst, opaque, data);
+    return va->get(va, pic, data);
 }
 
 /**
  * Destroys a libavcodec hardware acceleration back-end.
  * All allocated surfaces shall have been released beforehand.
  */
-void vlc_va_Delete(vlc_va_t *);
+void vlc_va_Delete(vlc_va_t *, void **);
 
 #endif
diff --git modules/codec/avcodec/va_surface.c modules/codec/avcodec/va_surface.c
new file mode 100644
index 000000000..a4415cbd2
--- /dev/null
+++ modules/codec/avcodec/va_surface.c
@@ -0,0 +1,228 @@
+/*****************************************************************************
+ * va_surface.c: libavcodec Generic Video Acceleration helpers
+ *****************************************************************************
+ * Copyright (C) 2009 Geoffroy Couprie
+ * Copyright (C) 2009 Laurent Aimar
+ * Copyright (C) 2015 Steve Lhomme
+ *
+ * Authors: Geoffroy Couprie <geal@videolan.org>
+ *          Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *          Steve Lhomme <robux4@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <assert.h>
+
+#include <vlc_common.h>
+#include <vlc_codecs.h>
+#include <vlc_codec.h>
+#include <vlc_picture.h>
+
+typedef struct
+{
+    void *dummy;
+} picture_sys_t;
+#include "va_surface_internal.h"
+
+#include "avcodec.h"
+
+struct vlc_va_surface_t {
+    atomic_uintptr_t     refcount;
+};
+
+static void DestroyVideoDecoder(vlc_va_t *va, va_pool_t *va_pool)
+{
+    for (unsigned i = 0; i < va_pool->surface_count; i++)
+        va_surface_Release(va_pool->surface[i]->va_surface);
+    va_pool->pf_destroy_surfaces(va);
+    va_pool->surface_count = 0;
+}
+
+/* */
+int va_pool_SetupDecoder(vlc_va_t *va, va_pool_t *va_pool, const AVCodecContext *avctx, unsigned count, int alignment)
+{
+    int err = VLC_ENOMEM;
+    unsigned i = va_pool->surface_count;
+
+    if (avctx->coded_width <= 0 || avctx->coded_height <= 0)
+        return VLC_EGENERIC;
+
+    assert((alignment & (alignment - 1)) == 0); /* power of 2 */
+#define ALIGN(x, y) (((x) + ((y) - 1)) & ~((y) - 1))
+    int surface_width  = ALIGN(avctx->coded_width,  alignment);
+    int surface_height = ALIGN(avctx->coded_height, alignment);
+
+    if (avctx->coded_width != surface_width || avctx->coded_height != surface_height)
+        msg_Warn( va, "surface dimensions (%dx%d) differ from avcodec dimensions (%dx%d)",
+                  surface_width, surface_height,
+                  avctx->coded_width, avctx->coded_height);
+
+    if ( va_pool->surface_count >= count &&
+         va_pool->surface_width == surface_width &&
+         va_pool->surface_height == surface_height )
+    {
+        msg_Dbg(va, "reusing surface pool");
+        err = VLC_SUCCESS;
+        goto done;
+    }
+
+    /* */
+    DestroyVideoDecoder(va, va_pool);
+
+    /* */
+    msg_Dbg(va, "va_pool_SetupDecoder id %d %dx%d count: %d", avctx->codec_id, avctx->coded_width, avctx->coded_height, count);
+
+    if (count > MAX_SURFACE_COUNT)
+        return VLC_EGENERIC;
+
+    /* FIXME transmit a video_format_t by VaSetup directly */
+    video_format_t fmt;
+    memset(&fmt, 0, sizeof(fmt));
+    fmt.i_width  = surface_width;
+    fmt.i_height = surface_height;
+    fmt.i_frame_rate      = avctx->framerate.num;
+    fmt.i_frame_rate_base = avctx->framerate.den;
+
+    err = va_pool->pf_create_decoder_surfaces(va, avctx->codec_id, &fmt, count);
+    if (err == VLC_SUCCESS)
+    {
+        va_pool->surface_width  = surface_width;
+        va_pool->surface_height = surface_height;
+    }
+
+done:
+    va_pool->surface_count = i;
+    if (err == VLC_SUCCESS)
+        va_pool->pf_setup_avcodec_ctx(va);
+
+    return err;
+}
+
+int va_pool_SetupSurfaces(vlc_va_t *va, va_pool_t *va_pool, unsigned count)
+{
+    int err = VLC_ENOMEM;
+    unsigned i = va_pool->surface_count;
+
+    for (i = 0; i < count; i++) {
+        struct vlc_va_surface_t *p_surface = malloc(sizeof(*p_surface));
+        if (unlikely(p_surface==NULL))
+            goto done;
+        va_pool->surface[i] = va_pool->pf_new_surface_context(va, i);
+        if (unlikely(va_pool->surface[i]==NULL))
+        {
+            free(p_surface);
+            goto done;
+        }
+        va_pool->surface[i]->va_surface = p_surface;
+        atomic_init(&va_pool->surface[i]->va_surface->refcount, 1);
+    }
+    err = VLC_SUCCESS;
+
+done:
+    va_pool->surface_count = i;
+    if (err == VLC_SUCCESS)
+        va_pool->pf_setup_avcodec_ctx(va);
+
+    return err;
+}
+
+static picture_context_t *GetSurface(va_pool_t *va_pool)
+{
+    for (unsigned i = 0; i < va_pool->surface_count; i++) {
+        struct va_pic_context *surface = va_pool->surface[i];
+        uintptr_t expected = 1;
+
+        if (atomic_compare_exchange_strong(&surface->va_surface->refcount, &expected, 2))
+        {
+            picture_context_t *field = surface->s.copy(&surface->s);
+            /* the copy should have added an extra reference */
+            atomic_fetch_sub(&surface->va_surface->refcount, 1);
+            return field;
+        }
+    }
+    return NULL;
+}
+
+int va_pool_Get(va_pool_t *va_pool, picture_t *pic)
+{
+    unsigned tries = (CLOCK_FREQ + VOUT_OUTMEM_SLEEP) / VOUT_OUTMEM_SLEEP;
+    picture_context_t *field;
+
+    if (va_pool->surface_count == 0)
+        return VLC_ENOITEM;
+
+    while ((field = GetSurface(va_pool)) == NULL)
+    {
+        if (--tries == 0)
+            return VLC_ENOITEM;
+        /* Pool empty. Wait for some time as in src/input/decoder.c.
+         * XXX: Both this and the core should use a semaphore or a CV. */
+        msleep(VOUT_OUTMEM_SLEEP);
+    }
+    pic->context = field;
+    return VLC_SUCCESS;
+}
+
+void va_surface_AddRef(vlc_va_surface_t *surface)
+{
+    atomic_fetch_add(&surface->refcount, 1);
+}
+
+void va_surface_Release(vlc_va_surface_t *surface)
+{
+    if (atomic_fetch_sub(&surface->refcount, 1) != 1)
+        return;
+    free(surface);
+}
+
+void va_pool_Close(vlc_va_t *va, va_pool_t *va_pool)
+{
+    DestroyVideoDecoder(va, va_pool);
+    va_pool->pf_destroy_video_service(va);
+    if (va_pool->pf_destroy_device_manager)
+        va_pool->pf_destroy_device_manager(va);
+    va_pool->pf_destroy_device(va);
+}
+
+int va_pool_Open(vlc_va_t *va, va_pool_t *va_pool)
+{
+    /* */
+    if (va_pool->pf_create_device(va)) {
+        msg_Err(va, "Failed to create device");
+        goto error;
+    }
+    msg_Dbg(va, "CreateDevice succeed");
+
+    if (va_pool->pf_create_device_manager &&
+        va_pool->pf_create_device_manager(va) != VLC_SUCCESS) {
+        msg_Err(va, "CreateDeviceManager failed");
+        goto error;
+    }
+
+    if (va_pool->pf_create_video_service(va)) {
+        msg_Err(va, "CreateVideoService failed");
+        goto error;
+    }
+
+    return VLC_SUCCESS;
+
+error:
+    return VLC_EGENERIC;
+}
+
diff --git modules/codec/avcodec/va_surface.h modules/codec/avcodec/va_surface.h
new file mode 100644
index 000000000..abb52eb81
--- /dev/null
+++ modules/codec/avcodec/va_surface.h
@@ -0,0 +1,39 @@
+/*****************************************************************************
+ * va_surface.h: libavcodec Generic Video Acceleration helpers
+ *****************************************************************************
+ * Copyright (C) 2009 Geoffroy Couprie
+ * Copyright (C) 2009 Laurent Aimar
+ * Copyright (C) 2015 Steve Lhomme
+ *
+ * Authors: Geoffroy Couprie <geal@videolan.org>
+ *          Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *          Steve Lhomme <robux4@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef AVCODEC_VA_SURFACE_H
+#define AVCODEC_VA_SURFACE_H
+
+#include <vlc_picture.h>
+
+struct va_pic_context
+{
+    picture_context_t         s;
+    struct vlc_va_surface_t *va_surface;
+    picture_sys_t             picsys;
+};
+
+#endif /* AVCODEC_VA_SURFACE_H */
diff --git modules/codec/avcodec/va_surface_internal.h modules/codec/avcodec/va_surface_internal.h
new file mode 100644
index 000000000..7a566dbee
--- /dev/null
+++ modules/codec/avcodec/va_surface_internal.h
@@ -0,0 +1,89 @@
+/*****************************************************************************
+ * va_surface_internal.h: libavcodec Generic Video Acceleration helpers
+ *****************************************************************************
+ * Copyright (C) 2009 Geoffroy Couprie
+ * Copyright (C) 2009 Laurent Aimar
+ * Copyright (C) 2015 Steve Lhomme
+ *
+ * Authors: Geoffroy Couprie <geal@videolan.org>
+ *          Laurent Aimar <fenrir _AT_ videolan _DOT_ org>
+ *          Steve Lhomme <robux4@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2.1 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
+ *****************************************************************************/
+
+#ifndef AVCODEC_VA_SURFACE_INTERNAL_H
+#define AVCODEC_VA_SURFACE_INTERNAL_H
+
+#include "va_surface.h"
+
+#include <libavcodec/avcodec.h>
+#include "va.h"
+
+#include <stdatomic.h>
+
+/* */
+typedef struct vlc_va_surface_t vlc_va_surface_t;
+
+#define MAX_SURFACE_COUNT (64)
+typedef struct
+{
+    /* */
+    unsigned     surface_count;
+    int          surface_width;
+    int          surface_height;
+
+    struct va_pic_context  *surface[MAX_SURFACE_COUNT];
+
+    int (*pf_create_device)(vlc_va_t *);
+    void (*pf_destroy_device)(vlc_va_t *);
+
+    int (*pf_create_device_manager)(vlc_va_t *);
+    void (*pf_destroy_device_manager)(vlc_va_t *);
+
+    int (*pf_create_video_service)(vlc_va_t *);
+    void (*pf_destroy_video_service)(vlc_va_t *);
+
+    /**
+     * Create the DirectX surfaces in hw_surface and the decoder in decoder
+     */
+    int (*pf_create_decoder_surfaces)(vlc_va_t *, int codec_id,
+                                      const video_format_t *fmt,
+                                      unsigned surface_count);
+    /**
+     * Destroy resources allocated with the surfaces and the associated decoder
+     */
+    void (*pf_destroy_surfaces)(vlc_va_t *);
+    /**
+     * Set the avcodec hw context after the decoder is created
+     */
+    void (*pf_setup_avcodec_ctx)(vlc_va_t *);
+
+    /**
+     * Create a new context for the surface being acquired
+     */
+    struct va_pic_context* (*pf_new_surface_context)(vlc_va_t *, int surface_index);
+
+} va_pool_t;
+
+int va_pool_Open(vlc_va_t *, va_pool_t *);
+void va_pool_Close(vlc_va_t *va, va_pool_t *);
+int va_pool_SetupDecoder(vlc_va_t *, va_pool_t *, const AVCodecContext *, unsigned count, int alignment);
+int va_pool_SetupSurfaces(vlc_va_t *, va_pool_t *, unsigned count);
+int va_pool_Get(va_pool_t *, picture_t *);
+void va_surface_AddRef(vlc_va_surface_t *surface);
+void va_surface_Release(vlc_va_surface_t *surface);
+
+#endif /* AVCODEC_VA_SURFACE_INTERNAL_H */
diff --git modules/codec/avcodec/vaapi.c modules/codec/avcodec/vaapi.c
index 1d8f7fa97..d8fafed09 100644
--- modules/codec/avcodec/vaapi.c
+++ modules/codec/avcodec/vaapi.c
@@ -1,6 +1,7 @@
 /*****************************************************************************
  * vaapi.c: VAAPI helpers for the libavcodec decoder
  *****************************************************************************
+ * Copyright (C) 2017 VLC authors and VideoLAN
  * Copyright (C) 2009-2010 Laurent Aimar
  * Copyright (C) 2012-2014 Rémi Denis-Courmont
  *
@@ -30,11 +31,9 @@
 #include <vlc_common.h>
 #include <vlc_plugin.h>
 #include <vlc_fourcc.h>
+#include <vlc_picture.h>
+#include <vlc_picture_pool.h>
 
-#ifdef VLC_VA_BACKEND_XLIB
-# include <vlc_xlib.h>
-# include <va/va_x11.h>
-#endif
 #ifdef VLC_VA_BACKEND_DRM
 # include <sys/types.h>
 # include <sys/stat.h>
@@ -47,558 +46,319 @@
 
 #include "avcodec.h"
 #include "va.h"
-#include "../../video_chroma/copy.h"
-
-#ifndef VA_SURFACE_ATTRIB_SETTABLE
-#define vaCreateSurfaces(d, f, w, h, s, ns, a, na) \
-    vaCreateSurfaces(d, w, h, f, ns, s)
-#endif
-
-static int Create( vlc_va_t *, AVCodecContext *, const es_format_t * );
-static void Delete( vlc_va_t * );
-
-vlc_module_begin ()
-#if defined (VLC_VA_BACKEND_XLIB)
-    set_description( N_("VA-API video decoder via X11") )
-#elif defined (VLC_VA_BACKEND_DRM)
-    set_description( N_("VA-API video decoder via DRM") )
-#endif
-    set_capability( "hw decoder", 0 )
-    set_category( CAT_INPUT )
-    set_subcategory( SUBCAT_INPUT_VCODEC )
-    set_callbacks( Create, Delete )
-    add_shortcut( "vaapi" )
-vlc_module_end ()
-
-typedef struct
-{
-    VASurfaceID  i_id;
-    int          i_refcount;
-    unsigned int i_order;
-    vlc_mutex_t *p_lock;
-} vlc_va_surface_t;
+#include "../../hw/vaapi/vlc_vaapi.h"
 
 struct vlc_va_sys_t
 {
-#ifdef VLC_VA_BACKEND_XLIB
-        Display  *p_display_x11;
-#endif
-#ifdef VLC_VA_BACKEND_DRM
-        int       drm_fd;
-#endif
-    VADisplay     p_display;
-
-    VAConfigID    i_config_id;
-    VAContextID   i_context_id;
-
+    struct vlc_vaapi_instance *va_inst;
     struct vaapi_context hw_ctx;
 
-    /* */
-    vlc_mutex_t  lock;
-    int          i_surface_count;
-    unsigned int i_surface_order;
-    int          i_surface_width;
-    int          i_surface_height;
-    vlc_fourcc_t i_surface_chroma;
-
-    vlc_va_surface_t *p_surface;
-
-    VAImage      image;
-    copy_cache_t image_cache;
-
-    bool b_supports_derive;
+#ifdef VLC_VA_BACKEND_DRM
+    picture_pool_t *pool;
+#endif
 };
 
-/* */
-static int Open( vlc_va_t *va, int i_codec_id, int i_thread_count )
+static int GetVaProfile(AVCodecContext *ctx, const es_format_t *fmt,
+                        VAProfile *va_profile, int *vlc_chroma,
+                        unsigned *pic_count)
 {
-    vlc_va_sys_t *sys = calloc( 1, sizeof(*sys) );
-    if ( unlikely(sys == NULL) )
-       return VLC_ENOMEM;
-
-    VAProfile i_profile, *p_profiles_list;
-    bool b_supported_profile = false;
-    int i_profiles_nb = 0;
-    int i_surface_count;
+    VAProfile i_profile;
+    unsigned count = 3;
+    int i_vlc_chroma = VLC_CODEC_VAAPI_420;
 
-    /* */
-    switch( i_codec_id )
+    switch(ctx->codec_id)
     {
     case AV_CODEC_ID_MPEG1VIDEO:
     case AV_CODEC_ID_MPEG2VIDEO:
         i_profile = VAProfileMPEG2Main;
-        i_surface_count = 2 + 2;
+        count = 4;
         break;
     case AV_CODEC_ID_MPEG4:
         i_profile = VAProfileMPEG4AdvancedSimple;
-        i_surface_count = 2+1;
         break;
     case AV_CODEC_ID_WMV3:
         i_profile = VAProfileVC1Main;
-        i_surface_count = 2+1;
         break;
     case AV_CODEC_ID_VC1:
         i_profile = VAProfileVC1Advanced;
-        i_surface_count = 2+1;
         break;
     case AV_CODEC_ID_H264:
         i_profile = VAProfileH264High;
-        i_surface_count = 16 + i_thread_count + 2;
-        break;;
-    default:
-        free( sys );
-        return VLC_EGENERIC;
-    }
-
-    /* */
-    sys->i_config_id  = VA_INVALID_ID;
-    sys->i_context_id = VA_INVALID_ID;
-    sys->image.image_id = VA_INVALID_ID;
-
-    /* Create a VA display */
-#ifdef VLC_VA_BACKEND_XLIB
-    sys->p_display_x11 = XOpenDisplay(NULL);
-    if( !sys->p_display_x11 )
-    {
-        msg_Err( va, "Could not connect to X server" );
-        goto error;
-    }
-
-    sys->p_display = vaGetDisplay( sys->p_display_x11 );
-#endif
-#ifdef VLC_VA_BACKEND_DRM
-    sys->drm_fd = vlc_open("/dev/dri/card0", O_RDWR);
-    if( sys->drm_fd == -1 )
-    {
-        msg_Err( va, "Could not access rendering device: %m" );
-        goto error;
-    }
-
-    sys->p_display = vaGetDisplayDRM( sys->drm_fd );
-#endif
-    if( !sys->p_display )
-    {
-        msg_Err( va, "Could not get a VAAPI device" );
-        goto error;
-    }
-
-    int major, minor;
-
-    if( vaInitialize( sys->p_display, &major, &minor ) )
-    {
-        msg_Err( va, "Failed to initialize the VAAPI device" );
-        goto error;
-    }
-
-    /* Check if the selected profile is supported */
-    i_profiles_nb = vaMaxNumProfiles( sys->p_display );
-    p_profiles_list = calloc( i_profiles_nb, sizeof( VAProfile ) );
-    if( !p_profiles_list )
-        goto error;
-
-    VAStatus i_status = vaQueryConfigProfiles( sys->p_display, p_profiles_list, &i_profiles_nb );
-    if ( i_status == VA_STATUS_SUCCESS )
-    {
-        for( int i = 0; i < i_profiles_nb; i++ )
+        count = 18;
+        break;
+    case AV_CODEC_ID_HEVC:
+        if (fmt->i_profile == FF_PROFILE_HEVC_MAIN)
+            i_profile = VAProfileHEVCMain;
+        else if (fmt->i_profile == FF_PROFILE_HEVC_MAIN_10)
         {
-            if ( p_profiles_list[i] == i_profile )
-            {
-                b_supported_profile = true;
-                break;
-            }
+            i_profile = VAProfileHEVCMain10;
+            i_vlc_chroma = VLC_CODEC_VAAPI_420_10BPP;
         }
-    }
-    free( p_profiles_list );
-    if ( !b_supported_profile )
-    {
-        msg_Dbg( va, "Codec and profile not supported by the hardware" );
-        goto error;
+        else
+            return VLC_EGENERIC;
+        count = 18;
+        break;
+    case AV_CODEC_ID_VP8:
+        i_profile = VAProfileVP8Version0_3;
+        count = 5;
+        break;
+    case AV_CODEC_ID_VP9:
+        if (ctx->profile == FF_PROFILE_VP9_0)
+            i_profile = VAProfileVP9Profile0;
+#if VA_CHECK_VERSION( 0, 39, 0 )
+        else if (ctx->profile == FF_PROFILE_VP9_2)
+        {
+            i_profile = VAProfileVP9Profile2;
+            i_vlc_chroma = VLC_CODEC_VAAPI_420_10BPP;
+        }
+#endif
+        else
+            return VLC_EGENERIC;
+        count = 10;
+        break;
+    default:
+        return VLC_EGENERIC;
     }
 
-    /* Create a VA configuration */
-    VAConfigAttrib attrib;
-    memset( &attrib, 0, sizeof(attrib) );
-    attrib.type = VAConfigAttribRTFormat;
-    if( vaGetConfigAttributes( sys->p_display,
-                               i_profile, VAEntrypointVLD, &attrib, 1 ) )
-        goto error;
-
-    /* Not sure what to do if not, I don't have a way to test */
-    if( (attrib.value & VA_RT_FORMAT_YUV420) == 0 )
-        goto error;
-    if( vaCreateConfig( sys->p_display,
-                        i_profile, VAEntrypointVLD, &attrib, 1, &sys->i_config_id ) )
-    {
-        sys->i_config_id = VA_INVALID_ID;
-        goto error;
-    }
+    *va_profile = i_profile;
+    *pic_count = count + ctx->thread_count;
+    *vlc_chroma = i_vlc_chroma;
+    return VLC_SUCCESS;
+}
 
-    sys->i_surface_count = i_surface_count;
+#ifndef VLC_VA_BACKEND_DRM
 
-    sys->b_supports_derive = false;
+static int Get(vlc_va_t *va, picture_t *pic, uint8_t **data)
+{
+    (void) va;
 
-    vlc_mutex_init(&sys->lock);
+    vlc_vaapi_PicAttachContext(pic);
+    *data = (void *) (uintptr_t) vlc_vaapi_PicGetSurface(pic);
 
-    va->sys = sys;
-    va->description = vaQueryVendorString( sys->p_display );
     return VLC_SUCCESS;
-
-error:
-    if( sys->p_display != NULL )
-        vaTerminate( sys->p_display );
-#ifdef VLC_VA_BACKEND_XLIB
-    if( sys->p_display_x11 != NULL )
-        XCloseDisplay( sys->p_display_x11 );
-#endif
-#ifdef VLC_VA_BACKEND_DRM
-    if( sys->drm_fd != -1 )
-        close( sys->drm_fd );
-#endif
-    free( sys );
-    return VLC_EGENERIC;
 }
 
-static void DestroySurfaces( vlc_va_sys_t *sys )
+static void Delete(vlc_va_t *va, void *hwctx)
 {
-    if( sys->image.image_id != VA_INVALID_ID )
-    {
-        CopyCleanCache( &sys->image_cache );
-        vaDestroyImage( sys->p_display, sys->image.image_id );
-    }
-    else if(sys->b_supports_derive)
-    {
-        CopyCleanCache( &sys->image_cache );
-    }
-
-    if( sys->i_context_id != VA_INVALID_ID )
-        vaDestroyContext( sys->p_display, sys->i_context_id );
+    vlc_va_sys_t *sys = va->sys;
+    vlc_object_t *o = VLC_OBJECT(va);
 
-    for( int i = 0; i < sys->i_surface_count && sys->p_surface; i++ )
-    {
-        vlc_va_surface_t *p_surface = &sys->p_surface[i];
+    (void) hwctx;
 
-        if( p_surface->i_id != VA_INVALID_SURFACE )
-            vaDestroySurfaces( sys->p_display, &p_surface->i_id, 1 );
-    }
-    free( sys->p_surface );
-
-    /* */
-    sys->image.image_id = VA_INVALID_ID;
-    sys->i_context_id = VA_INVALID_ID;
-    sys->p_surface = NULL;
-    sys->i_surface_width = 0;
-    sys->i_surface_height = 0;
-    vlc_mutex_destroy(&sys->lock);
+    vlc_vaapi_DestroyContext(o, sys->hw_ctx.display, sys->hw_ctx.context_id);
+    vlc_vaapi_DestroyConfig(o, sys->hw_ctx.display, sys->hw_ctx.config_id);
+    vlc_vaapi_ReleaseInstance(sys->va_inst);
+    free(sys);
 }
 
-static int CreateSurfaces( vlc_va_sys_t *sys, void **pp_hw_ctx, vlc_fourcc_t *pi_chroma,
-                           int i_width, int i_height )
+static int Create(vlc_va_t *va, AVCodecContext *ctx, enum PixelFormat pix_fmt,
+                  const es_format_t *fmt, void *p_sys)
 {
-    assert( i_width > 0 && i_height > 0 );
-
-    /* */
-    sys->p_surface = calloc( sys->i_surface_count, sizeof(*sys->p_surface) );
-    if( !sys->p_surface )
+    if (pix_fmt != AV_PIX_FMT_VAAPI_VLD || p_sys == NULL)
         return VLC_EGENERIC;
-    sys->image.image_id = VA_INVALID_ID;
-    sys->i_context_id   = VA_INVALID_ID;
 
-    /* Create surfaces */
-    VASurfaceID pi_surface_id[sys->i_surface_count];
-    if( vaCreateSurfaces( sys->p_display, VA_RT_FORMAT_YUV420, i_width, i_height,
-                          pi_surface_id, sys->i_surface_count, NULL, 0 ) )
-    {
-        for( int i = 0; i < sys->i_surface_count; i++ )
-            sys->p_surface[i].i_id = VA_INVALID_SURFACE;
-        goto error;
-    }
+    (void) fmt;
+    vlc_object_t *o = VLC_OBJECT(va);
 
-    for( int i = 0; i < sys->i_surface_count; i++ )
-    {
-        vlc_va_surface_t *p_surface = &sys->p_surface[i];
+    int ret = VLC_EGENERIC;
+    vlc_va_sys_t *sys = NULL;
 
-        p_surface->i_id = pi_surface_id[i];
-        p_surface->i_refcount = 0;
-        p_surface->i_order = 0;
-        p_surface->p_lock = &sys->lock;
-    }
+    /* The picture must be allocated by the vout */
+    VADisplay va_dpy;
+    struct vlc_vaapi_instance *va_inst =
+        vlc_vaapi_PicSysHoldInstance(p_sys, &va_dpy);
 
-    /* Create a context */
-    if( vaCreateContext( sys->p_display, sys->i_config_id,
-                         i_width, i_height, VA_PROGRESSIVE,
-                         pi_surface_id, sys->i_surface_count, &sys->i_context_id ) )
-    {
-        sys->i_context_id = VA_INVALID_ID;
+    VASurfaceID *render_targets;
+    unsigned num_render_targets =
+        vlc_vaapi_PicSysGetRenderTargets(p_sys, &render_targets);
+    if (num_render_targets == 0)
         goto error;
-    }
 
-    /* Find and create a supported image chroma */
-    int i_fmt_count = vaMaxNumImageFormats( sys->p_display );
-    VAImageFormat *p_fmt = calloc( i_fmt_count, sizeof(*p_fmt) );
-    if( !p_fmt )
+    VAProfile i_profile;
+    unsigned count;
+    int i_vlc_chroma;
+    if (GetVaProfile(ctx, fmt, &i_profile, &i_vlc_chroma, &count) != VLC_SUCCESS)
         goto error;
 
-    if( vaQueryImageFormats( sys->p_display, p_fmt, &i_fmt_count ) )
+    sys = malloc(sizeof *sys);
+    if (unlikely(sys == NULL))
     {
-        free( p_fmt );
+        ret = VLC_ENOMEM;
         goto error;
     }
+    memset(sys, 0, sizeof (*sys));
 
-    VAImage test_image;
-    if(vaDeriveImage(sys->p_display, pi_surface_id[0], &test_image) == VA_STATUS_SUCCESS)
-    {
-        sys->b_supports_derive = true;
-        vaDestroyImage(sys->p_display, test_image.image_id);
-    }
-
-    vlc_fourcc_t  i_chroma = 0;
-    for( int i = 0; i < i_fmt_count; i++ )
-    {
-        if( p_fmt[i].fourcc == VA_FOURCC_YV12 ||
-            p_fmt[i].fourcc == VA_FOURCC_IYUV ||
-            p_fmt[i].fourcc == VA_FOURCC_NV12 )
-        {
-            if( vaCreateImage(  sys->p_display, &p_fmt[i], i_width, i_height, &sys->image ) )
-            {
-                sys->image.image_id = VA_INVALID_ID;
-                continue;
-            }
-            /* Validate that vaGetImage works with this format */
-            if( vaGetImage( sys->p_display, pi_surface_id[0],
-                            0, 0, i_width, i_height,
-                            sys->image.image_id) )
-            {
-                vaDestroyImage( sys->p_display, sys->image.image_id );
-                sys->image.image_id = VA_INVALID_ID;
-                continue;
-            }
-
-            i_chroma = VLC_CODEC_YV12;
-            break;
-        }
-    }
-    free( p_fmt );
-    if( !i_chroma )
+    /* */
+    sys->va_inst = va_inst;
+    sys->hw_ctx.display = va_dpy;
+    sys->hw_ctx.config_id = VA_INVALID_ID;
+    sys->hw_ctx.context_id = VA_INVALID_ID;
+
+    sys->hw_ctx.config_id =
+        vlc_vaapi_CreateConfigChecked(o, sys->hw_ctx.display, i_profile,
+                                      VAEntrypointVLD, i_vlc_chroma);
+    if (sys->hw_ctx.config_id == VA_INVALID_ID)
         goto error;
-    *pi_chroma = i_chroma;
 
-    if(sys->b_supports_derive)
-    {
-        vaDestroyImage( sys->p_display, sys->image.image_id );
-        sys->image.image_id = VA_INVALID_ID;
-    }
-
-    if( unlikely(CopyInitCache( &sys->image_cache, i_width )) )
+    /* Create a context */
+    sys->hw_ctx.context_id =
+        vlc_vaapi_CreateContext(o, sys->hw_ctx.display, sys->hw_ctx.config_id,
+                                ctx->coded_width, ctx->coded_height, VA_PROGRESSIVE,
+                                render_targets, num_render_targets);
+    if (sys->hw_ctx.context_id == VA_INVALID_ID)
         goto error;
 
-    /* Setup the ffmpeg hardware context */
-    *pp_hw_ctx = &sys->hw_ctx;
-
-    memset( &sys->hw_ctx, 0, sizeof(sys->hw_ctx) );
-    sys->hw_ctx.display    = sys->p_display;
-    sys->hw_ctx.config_id  = sys->i_config_id;
-    sys->hw_ctx.context_id = sys->i_context_id;
-
-    /* */
-    sys->i_surface_chroma = i_chroma;
-    sys->i_surface_width = i_width;
-    sys->i_surface_height = i_height;
+    ctx->hwaccel_context = &sys->hw_ctx;
+    va->sys = sys;
+    va->description = vaQueryVendorString(sys->hw_ctx.display);
+    va->get = Get;
     return VLC_SUCCESS;
 
 error:
-    DestroySurfaces( sys );
-    return VLC_EGENERIC;
+    if (sys != NULL)
+    {
+        if (sys->hw_ctx.context_id != VA_INVALID_ID)
+            vlc_vaapi_DestroyContext(o, sys->hw_ctx.display, sys->hw_ctx.context_id);
+        if (sys->hw_ctx.config_id != VA_INVALID_ID)
+            vlc_vaapi_DestroyConfig(o, sys->hw_ctx.display, sys->hw_ctx.config_id);
+        free(sys);
+    }
+    vlc_vaapi_ReleaseInstance(va_inst);
+    return ret;
 }
 
-static int Setup( vlc_va_t *va, void **pp_hw_ctx, vlc_fourcc_t *pi_chroma,
-                  int i_width, int i_height )
+#else /* DRM */
+
+static int GetDRM(vlc_va_t *va, picture_t *pic, uint8_t **data)
 {
     vlc_va_sys_t *sys = va->sys;
 
-    if( sys->i_surface_width == i_width &&
-        sys->i_surface_height == i_height )
-    {
-        *pp_hw_ctx = &sys->hw_ctx;
-        *pi_chroma = sys->i_surface_chroma;
-        return VLC_SUCCESS;
-    }
-
-    *pp_hw_ctx = NULL;
-    *pi_chroma = 0;
-    if( sys->i_surface_width || sys->i_surface_height )
-        DestroySurfaces( sys );
+    picture_t *vapic = picture_pool_Wait(sys->pool);
+    if (vapic == NULL)
+        return VLC_EGENERIC;
+    vlc_vaapi_PicAttachContext(vapic);
 
-    if( i_width > 0 && i_height > 0 )
-        return CreateSurfaces( sys, pp_hw_ctx, pi_chroma, i_width, i_height );
+    pic->context = vapic->context->copy(vapic->context);
+    picture_Release(vapic);
+    if (pic->context == NULL)
+        return VLC_EGENERIC;
 
-    return VLC_EGENERIC;
+    *data = (void *)(uintptr_t)vlc_vaapi_PicGetSurface(pic);
+    return VLC_SUCCESS;
 }
 
-static int Extract( vlc_va_t *va, picture_t *p_picture, void *opaque,
-                    uint8_t *data )
+static void DeleteDRM(vlc_va_t *va, void **hwctx)
 {
     vlc_va_sys_t *sys = va->sys;
-    VASurfaceID i_surface_id = (VASurfaceID)(uintptr_t)data;
+    vlc_object_t *o = VLC_OBJECT(va);
+
+    (void) hwctx;
+    picture_pool_Release(sys->pool);
+    vlc_vaapi_DestroyContext(o, sys->hw_ctx.display, sys->hw_ctx.context_id);
+    vlc_vaapi_DestroyConfig(o, sys->hw_ctx.display, sys->hw_ctx.config_id);
+    vlc_vaapi_ReleaseInstance(sys->va_inst);
+    free(sys);
+}
 
-#if VA_CHECK_VERSION(0,31,0)
-    if( vaSyncSurface( sys->p_display, i_surface_id ) )
-#else
-    if( vaSyncSurface( sys->p_display, sys->i_context_id, i_surface_id ) )
-#endif
+static int CreateDRM(vlc_va_t *va, AVCodecContext *ctx, enum PixelFormat pix_fmt,
+                     const es_format_t *fmt, void *p_sys)
+{
+    if (pix_fmt != AV_PIX_FMT_VAAPI_VLD || p_sys)
         return VLC_EGENERIC;
 
-    if(sys->b_supports_derive)
-    {
-        if(vaDeriveImage(sys->p_display, i_surface_id, &(sys->image)) != VA_STATUS_SUCCESS)
-            return VLC_EGENERIC;
-    }
-    else
-    {
-        if( vaGetImage( sys->p_display, i_surface_id,
-                        0, 0, sys->i_surface_width, sys->i_surface_height,
-                        sys->image.image_id) )
-            return VLC_EGENERIC;
-    }
+    (void) fmt;
+    (void) p_sys;
+    vlc_object_t *o = VLC_OBJECT(va);
 
-    void *p_base;
-    if( vaMapBuffer( sys->p_display, sys->image.buf, &p_base ) )
+    VAProfile i_profile;
+    unsigned count;
+    int i_vlc_chroma;
+    if (GetVaProfile(ctx, fmt, &i_profile, &i_vlc_chroma, &count) != VLC_SUCCESS)
         return VLC_EGENERIC;
 
-    const uint32_t i_fourcc = sys->image.format.fourcc;
-    if( i_fourcc == VA_FOURCC_YV12 ||
-        i_fourcc == VA_FOURCC_IYUV )
-    {
-        bool b_swap_uv = i_fourcc == VA_FOURCC_IYUV;
-        uint8_t *pp_plane[3];
-        size_t  pi_pitch[3];
+    vlc_va_sys_t *sys;
 
-        for( int i = 0; i < 3; i++ )
-        {
-            const int i_src_plane = (b_swap_uv && i != 0) ?  (3 - i) : i;
-            pp_plane[i] = (uint8_t*)p_base + sys->image.offsets[i_src_plane];
-            pi_pitch[i] = sys->image.pitches[i_src_plane];
-        }
-        CopyFromYv12( p_picture, pp_plane, pi_pitch,
-                      sys->i_surface_width,
-                      sys->i_surface_height,
-                      &sys->image_cache );
-    }
-    else
-    {
-        assert( i_fourcc == VA_FOURCC_NV12 );
-        uint8_t *pp_plane[2];
-        size_t  pi_pitch[2];
-
-        for( int i = 0; i < 2; i++ )
-        {
-            pp_plane[i] = (uint8_t*)p_base + sys->image.offsets[i];
-            pi_pitch[i] = sys->image.pitches[i];
-        }
-        CopyFromNv12( p_picture, pp_plane, pi_pitch,
-                      sys->i_surface_width,
-                      sys->i_surface_height,
-                      &sys->image_cache );
-    }
-
-    if( vaUnmapBuffer( sys->p_display, sys->image.buf ) )
-        return VLC_EGENERIC;
-
-    if(sys->b_supports_derive)
-    {
-        vaDestroyImage( sys->p_display, sys->image.image_id );
-        sys->image.image_id = VA_INVALID_ID;
-    }
-    (void) opaque;
-    return VLC_SUCCESS;
-}
+    sys = malloc(sizeof(vlc_va_sys_t));
+    if (!sys)
+       return VLC_ENOMEM;
+    memset(sys, 0, sizeof (*sys));
 
-static int Get( vlc_va_t *va, void **opaque, uint8_t **data )
-{
-    vlc_va_sys_t *sys = va->sys;
-    int i_old;
-    int i;
+    /* */
+    sys->hw_ctx.display = NULL;
+    sys->hw_ctx.config_id = VA_INVALID_ID;
+    sys->hw_ctx.context_id = VA_INVALID_ID;
+    sys->pool = NULL;
+    sys->va_inst = NULL;
 
-    vlc_mutex_lock( &sys->lock );
-    /* Grab an unused surface, in case none are, try the oldest
-     * XXX using the oldest is a workaround in case a problem happens with ffmpeg */
-    for( i = 0, i_old = 0; i < sys->i_surface_count; i++ )
-    {
-        vlc_va_surface_t *p_surface = &sys->p_surface[i];
+    /* Create a VA display */
+    sys->va_inst = vlc_vaapi_InitializeInstanceDRM(o, vaGetDisplayDRM,
+                                                   &sys->hw_ctx.display, NULL);
+    if (!sys->va_inst)
+        goto error;
 
-        if( !p_surface->i_refcount )
-            break;
+    sys->hw_ctx.config_id =
+        vlc_vaapi_CreateConfigChecked(o, sys->hw_ctx.display, i_profile,
+                                      VAEntrypointVLD, 0);
+    if (sys->hw_ctx.config_id == VA_INVALID_ID)
+        goto error;
 
-        if( p_surface->i_order < sys->p_surface[i_old].i_order )
-            i_old = i;
-    }
-    if( i >= sys->i_surface_count )
-        i = i_old;
-    vlc_mutex_unlock( &sys->lock );
+    /* Create surfaces */
+    assert(ctx->coded_width > 0 && ctx->coded_height > 0);
+    video_format_t vfmt = {
+        .i_chroma = i_vlc_chroma,
+        .i_width = ctx->coded_width,
+        .i_height = ctx->coded_height,
+        .i_visible_width = ctx->coded_width,
+        .i_visible_height = ctx->coded_height
+    };
+
+    VASurfaceID *surfaces;
+    sys->pool = vlc_vaapi_PoolNew(o, sys->va_inst, sys->hw_ctx.display, count,
+                                  &surfaces, &vfmt, false);
+
+    if (!sys->pool)
+        goto error;
 
-    vlc_va_surface_t *p_surface = &sys->p_surface[i];
+    /* Create a context */
+    sys->hw_ctx.context_id =
+        vlc_vaapi_CreateContext(o, sys->hw_ctx.display, sys->hw_ctx.config_id,
+                                ctx->coded_width, ctx->coded_height,
+                                VA_PROGRESSIVE, surfaces, count);
+    if (sys->hw_ctx.context_id == VA_INVALID_ID)
+        goto error;
 
-    p_surface->i_refcount = 1;
-    p_surface->i_order = sys->i_surface_order++;
-    *data = (void *)(uintptr_t)p_surface->i_id;
-    *opaque = p_surface;
+    ctx->hwaccel_context = &sys->hw_ctx;
+    va->sys = sys;
+    va->description = vaQueryVendorString(sys->hw_ctx.display);
+    va->get = GetDRM;
     return VLC_SUCCESS;
-}
 
-static void Release( void *opaque, uint8_t *data )
-{
-    vlc_va_surface_t *p_surface = opaque;
-
-    vlc_mutex_lock( p_surface->p_lock );
-    p_surface->i_refcount--;
-    vlc_mutex_unlock( p_surface->p_lock );
-    (void) data;
+error:
+    if (sys->hw_ctx.context_id != VA_INVALID_ID)
+        vlc_vaapi_DestroyContext(o, sys->hw_ctx.display, sys->hw_ctx.context_id);
+    if (sys->pool != NULL)
+        picture_pool_Release(sys->pool);
+    if (sys->hw_ctx.config_id != VA_INVALID_ID)
+        vlc_vaapi_DestroyConfig(o, sys->hw_ctx.display, sys->hw_ctx.config_id);
+    if (sys->va_inst != NULL)
+        vlc_vaapi_ReleaseInstance(sys->va_inst);
+    free(sys);
+    return VLC_EGENERIC;
 }
-
-static void Close( vlc_va_sys_t *sys )
-{
-    if( sys->i_surface_width || sys->i_surface_height )
-        DestroySurfaces( sys );
-
-    if( sys->i_config_id != VA_INVALID_ID )
-        vaDestroyConfig( sys->p_display, sys->i_config_id );
-    vaTerminate( sys->p_display );
-#ifdef VLC_VA_BACKEND_XLIB
-    XCloseDisplay( sys->p_display_x11 );
 #endif
-#ifdef VLC_VA_BACKEND_DRM
-    close( sys->drm_fd );
-#endif
-}
 
-static void Delete( vlc_va_t *va )
-{
-    vlc_va_sys_t *sys = va->sys;
-    Close( sys );
-    free( sys );
-}
-
-static int Create( vlc_va_t *p_va, AVCodecContext *ctx,
-                   const es_format_t *fmt )
-{
-#ifdef VLC_VA_BACKEND_XLIB
-    if( !vlc_xlib_init( VLC_OBJECT(p_va) ) )
-    {
-        msg_Warn( p_va, "Ignoring VA API" );
-        return VLC_EGENERIC;
-    }
+vlc_module_begin ()
+#ifdef VLC_VA_BACKEND_DRM
+    set_description( N_("VA-API video decoder via DRM") )
+    set_capability( "hw decoder", 0 )
+    set_callbacks( CreateDRM, DeleteDRM )
+    add_shortcut( "vaapi", "vaapi_drm" )
+#else
+    set_description( N_("VA-API video decoder") )
+    set_capability( "hw decoder", 100 )
+    set_callbacks( Create, Delete )
+    add_shortcut( "vaapi" )
 #endif
-
-    (void) fmt;
-
-    int err = Open( p_va, ctx->codec_id, ctx->thread_count );
-    if( err )
-        return err;
-
-    /* Only VLD supported */
-    p_va->pix_fmt = PIX_FMT_VAAPI_VLD;
-    p_va->setup = Setup;
-    p_va->get = Get;
-    p_va->release = Release;
-    p_va->extract = Extract;
-    return VLC_SUCCESS;
-}
+    set_category( CAT_INPUT )
+    set_subcategory( SUBCAT_INPUT_VCODEC )
+vlc_module_end ()
diff --git modules/codec/avcodec/vda.c modules/codec/avcodec/vda.c
deleted file mode 100644
index 9da052752..000000000
--- modules/codec/avcodec/vda.c
+++ /dev/null
@@ -1,434 +0,0 @@
-/*****************************************************************************
- * vda.c: VDA helpers for the libavcodec decoder
- *****************************************************************************
- * Copyright (C) 2012-2014 VLC authors VideoLAN
- *
- * Authors: Sebastien Zwickert <dilaroga@free.fr>
- *          Rémi Denis-Courmont <remi # remlab : net>
- *          Felix Paul Kühne <fkuehne # videolan org>
- *          David Fuhrmann <david.fuhrmann # googlemail com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2.1 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
- *****************************************************************************/
-
-#ifdef HAVE_CONFIG_H
-# include "config.h"
-#endif
-
-#include <assert.h>
-
-#include <vlc_common.h>
-#include <vlc_vout.h>
-#include <vlc_plugin.h>
-
-#include <libavcodec/avcodec.h>
-
-#include "avcodec.h"
-#include "va.h"
-#include "../../video_chroma/copy.h"
-
-#include <libavcodec/vda.h>
-#include <VideoDecodeAcceleration/VDADecoder.h>
-
-#pragma mark prototypes and definitions
-
-static int Open( vlc_va_t *, AVCodecContext *, const es_format_t * );
-static void Close( vlc_va_t * );
-static int Setup( vlc_va_t *, void **, vlc_fourcc_t *, int , int );
-static int Get( vlc_va_t *, void **, uint8_t ** );
-static int Extract( vlc_va_t *, picture_t *, void *, uint8_t * );
-static void Release( void *, uint8_t * );
-
-static void vda_Copy422YpCbCr8( picture_t *p_pic,
-                                CVPixelBufferRef buffer )
-{
-    int i_dst_stride, i_src_stride;
-    uint8_t *p_dst, *p_src;
-
-    CVPixelBufferLockBaseAddress( buffer, 0 );
-
-    for( int i_plane = 0; i_plane < p_pic->i_planes; i_plane++ )
-    {
-        p_dst = p_pic->p[i_plane].p_pixels;
-        p_src = CVPixelBufferGetBaseAddressOfPlane( buffer, i_plane );
-        i_dst_stride  = p_pic->p[i_plane].i_pitch;
-        i_src_stride  = CVPixelBufferGetBytesPerRowOfPlane( buffer, i_plane );
-
-        for( int i_line = 0; i_line < p_pic->p[i_plane].i_visible_lines ; i_line++ )
-        {
-            memcpy( p_dst, p_src, i_src_stride );
-
-            p_src += i_src_stride;
-            p_dst += i_dst_stride;
-        }
-    }
-
-    CVPixelBufferUnlockBaseAddress( buffer, 0 );
-}
-
-#ifndef HAVE_AV_VDA_ALLOC_CONTEXT
-
-static const int  nvda_pix_fmt_list[] = { 0, 1 };
-static const char *const nvda_pix_fmt_list_text[] =
-  { N_("420YpCbCr8Planar"), N_("422YpCbCr8") };
-
-vlc_module_begin ()
-    set_description( N_("Video Decode Acceleration Framework (VDA)") )
-    set_capability( "hw decoder", 0 )
-    set_category( CAT_INPUT )
-    set_subcategory( SUBCAT_INPUT_VCODEC )
-    set_callbacks( Open, Close )
-    add_integer ( "avcodec-vda-pix-fmt", 0, VDA_PIX_FMT_TEXT,
-                  VDA_PIX_FMT_LONGTEXT, false)
-        change_integer_list( nvda_pix_fmt_list, nvda_pix_fmt_list_text )
-vlc_module_end ()
-
-struct vlc_va_sys_t
-{
-    struct vda_context  hw_ctx;
-
-    uint8_t             *p_extradata;
-    int                 i_extradata;
-
-    vlc_fourcc_t        i_chroma;
-
-    copy_cache_t        image_cache;
-
-    vlc_object_t        *p_log;
-
-};
-
-typedef struct vlc_va_sys_t vlc_va_vda_t;
-
-static vlc_va_vda_t *vlc_va_vda_Get( vlc_va_t *p_va )
-{
-    return p_va->sys;
-}
-
-#pragma mark - module handling
-
-static int Open( vlc_va_t *external, AVCodecContext *ctx,
-                 const es_format_t *fmt )
-{
-    msg_Dbg( external, "opening VDA module" );
-    if( ctx->codec_id != AV_CODEC_ID_H264 )
-    {
-        msg_Warn( external, "input codec isn't H264, canceling VDA decoding" );
-        return VLC_EGENERIC;
-    }
-
-    if( fmt->p_extra == NULL || fmt->i_extra < 7 )
-    {
-        msg_Warn( external, "VDA requires extradata." );
-        return VLC_EGENERIC;
-    }
-
-    vlc_va_vda_t *p_va = calloc( 1, sizeof(*p_va) );
-    if( !p_va )
-        return VLC_EGENERIC;
-
-    p_va->p_log = VLC_OBJECT(external);
-    p_va->p_extradata = fmt->p_extra;
-    p_va->i_extradata = fmt->i_extra;
-
-    external->sys = p_va;
-    external->description = "VDA";
-    external->pix_fmt = PIX_FMT_VDA_VLD;
-    external->setup = Setup;
-    external->get = Get;
-    external->release = Release;
-    external->extract = Extract;
-
-    return VLC_SUCCESS;
-}
-
-static void Close( vlc_va_t *external )
-{
-    vlc_va_vda_t *p_va = vlc_va_vda_Get( external );
-
-    msg_Dbg(p_va->p_log, "destroying VDA decoder");
-
-    ff_vda_destroy_decoder( &p_va->hw_ctx ) ;
-
-    if( p_va->hw_ctx.cv_pix_fmt_type == kCVPixelFormatType_420YpCbCr8Planar )
-        CopyCleanCache( &p_va->image_cache );
-
-    free( p_va );
-}
-
-static int Setup( vlc_va_t *external, void **pp_hw_ctx, vlc_fourcc_t *pi_chroma,
-                 int i_width, int i_height )
-{
-    vlc_va_vda_t *p_va = vlc_va_vda_Get( external );
-
-    if( p_va->hw_ctx.width == i_width
-       && p_va->hw_ctx.height == i_height
-       && p_va->hw_ctx.decoder )
-    {
-        *pp_hw_ctx = &p_va->hw_ctx;
-        *pi_chroma = p_va->i_chroma;
-        return VLC_SUCCESS;
-    }
-
-    if( p_va->hw_ctx.decoder )
-    {
-        ff_vda_destroy_decoder( &p_va->hw_ctx );
-        goto ok;
-    }
-
-    memset( &p_va->hw_ctx, 0, sizeof(p_va->hw_ctx) );
-    p_va->hw_ctx.format = 'avc1';
-    p_va->hw_ctx.use_ref_buffer = 1;
-
-    int i_pix_fmt = var_CreateGetInteger( p_va->p_log, "avcodec-vda-pix-fmt" );
-
-    switch( i_pix_fmt )
-    {
-        case 1 :
-            p_va->hw_ctx.cv_pix_fmt_type = kCVPixelFormatType_422YpCbCr8;
-            p_va->i_chroma = VLC_CODEC_UYVY;
-            msg_Dbg(p_va->p_log, "using pixel format 422YpCbCr8");
-            break;
-        case 0 :
-        default :
-            p_va->hw_ctx.cv_pix_fmt_type = kCVPixelFormatType_420YpCbCr8Planar;
-            p_va->i_chroma = VLC_CODEC_I420;
-            CopyInitCache( &p_va->image_cache, i_width );
-            msg_Dbg(p_va->p_log, "using pixel format 420YpCbCr8Planar");
-    }
-
-ok:
-    /* Setup the libavcodec hardware context */
-    *pp_hw_ctx = &p_va->hw_ctx;
-    *pi_chroma = p_va->i_chroma;
-
-    p_va->hw_ctx.width = i_width;
-    p_va->hw_ctx.height = i_height;
-
-    /* create the decoder */
-    int status = ff_vda_create_decoder( &p_va->hw_ctx,
-                                       p_va->p_extradata,
-                                       p_va->i_extradata );
-    if( status )
-    {
-        msg_Err( p_va->p_log, "Failed to create decoder: %i", status );
-        return VLC_EGENERIC;
-    }
-    else
-        msg_Dbg( p_va->p_log, "VDA decoder created");
-
-    return VLC_SUCCESS;
-}
-
-#pragma mark - actual data handling
-
-static void vda_Copy420YpCbCr8Planar( picture_t *p_pic,
-                                      CVPixelBufferRef buffer,
-                                      unsigned i_width,
-                                      unsigned i_height,
-                                      copy_cache_t *cache )
-{
-    uint8_t *pp_plane[3];
-    size_t  pi_pitch[3];
-
-    if (!buffer)
-        return;
-
-    CVPixelBufferLockBaseAddress( buffer, 0 );
-
-    for( int i = 0; i < 3; i++ )
-    {
-        pp_plane[i] = CVPixelBufferGetBaseAddressOfPlane( buffer, i );
-        pi_pitch[i] = CVPixelBufferGetBytesPerRowOfPlane( buffer, i );
-    }
-
-    CopyFromYv12( p_pic, pp_plane, pi_pitch,
-                  i_width, i_height, cache );
-
-    CVPixelBufferUnlockBaseAddress( buffer, 0 );
-}
-
-static int Get( vlc_va_t *external, void **opaque, uint8_t **data )
-{
-    VLC_UNUSED( external );
-
-    *data = (uint8_t *)1; // dummy
-    (void) opaque;
-    return VLC_SUCCESS;
-}
-
-static int Extract( vlc_va_t *external, picture_t *p_picture, void *opaque,
-                    uint8_t *data )
-{
-    vlc_va_vda_t *p_va = vlc_va_vda_Get( external );
-    CVPixelBufferRef cv_buffer = ( CVPixelBufferRef )data;
-
-    if( !cv_buffer )
-    {
-        msg_Dbg( p_va->p_log, "Frame buffer is empty.");
-        return VLC_EGENERIC;
-    }
-    if (!CVPixelBufferGetDataSize(cv_buffer) > 0)
-    {
-        msg_Dbg( p_va->p_log, "Empty frame buffer");
-        return VLC_EGENERIC;
-    }
-
-    if( p_va->hw_ctx.cv_pix_fmt_type == kCVPixelFormatType_420YpCbCr8Planar )
-    {
-        if( !p_va->image_cache.buffer ) {
-            CVPixelBufferRelease( cv_buffer );
-            return VLC_EGENERIC;
-        }
-
-        vda_Copy420YpCbCr8Planar( p_picture,
-                                  cv_buffer,
-                                  p_va->hw_ctx.width,
-                                  p_va->hw_ctx.height,
-                                  &p_va->image_cache );
-    }
-    else
-        vda_Copy422YpCbCr8( p_picture, cv_buffer );
-    (void) opaque;
-    return VLC_SUCCESS;
-}
-
-static void Release( void *opaque, uint8_t *data )
-{
-#if 0
-    CVPixelBufferRef cv_buffer = ( CVPixelBufferRef )p_ff->data[3];
-
-    if ( cv_buffer )
-        CVPixelBufferRelease( cv_buffer );
-#endif
-    (void) opaque; (void) data;
-}
-
-#else
-
-vlc_module_begin ()
-    set_description( N_("Video Decode Acceleration Framework (VDA)") )
-    set_capability( "hw decoder", 0 )
-    set_category( CAT_INPUT )
-    set_subcategory( SUBCAT_INPUT_VCODEC )
-    set_callbacks( Open, Close )
-vlc_module_end ()
-
-struct vlc_va_sys_t
-{
-    // to free the hwaccel
-    AVCodecContext      *avctx;
-    vlc_object_t        *p_log;
-};
-
-typedef struct vlc_va_sys_t vlc_va_vda_t;
-
-static vlc_va_vda_t *vlc_va_vda_Get( vlc_va_t *p_va )
-{
-    return p_va->sys;
-}
-
-static int Open( vlc_va_t *external, AVCodecContext *avctx,
-                 const es_format_t *fmt )
-{
-    msg_Dbg( external, "VDA decoder Open");
-
-    vlc_va_vda_t *p_va = calloc( 1, sizeof(*p_va) );
-    if (!p_va) {
-        av_vda_default_free(avctx);
-        return VLC_EGENERIC;
-    }
-    p_va->p_log = VLC_OBJECT(external);
-    p_va->avctx = avctx;
-
-    external->sys = p_va;
-    external->description = (char *)"VDA";
-    external->pix_fmt = AV_PIX_FMT_VDA;
-    external->setup = Setup;
-    external->get = Get;
-    external->release = Release;
-    external->extract = Extract;
-    msg_Dbg( external, "VDA decoder Open success!");
-
-    (void) fmt;
-
-    return VLC_SUCCESS;
-}
-
-static void Close( vlc_va_t *external )
-{
-    vlc_va_vda_t *p_va = vlc_va_vda_Get( external );
-
-    av_vda_default_free(p_va->avctx);
-}
-
-static int Setup( vlc_va_t *external, void **pp_hw_ctx, vlc_fourcc_t *pi_chroma,
-                 int i_width, int i_height )
-{
-    VLC_UNUSED( pp_hw_ctx );
-    vlc_va_vda_t *p_va = vlc_va_vda_Get( external );
-
-    *pi_chroma = VLC_CODEC_UYVY;
-
-    av_vda_default_free(p_va->avctx);
-
-    if( av_vda_default_init(p_va->avctx) < 0 )
-        return VLC_EGENERIC;
-
-    (void)i_width; (void)i_height;
-
-    return VLC_SUCCESS;
-}
-
-// Never called
-static int Get( vlc_va_t *external, void **opaque, uint8_t **data )
-{
-    VLC_UNUSED( external );
-
-    (void) data;
-    (void) opaque;
-    return VLC_SUCCESS;
-}
-
-static int Extract( vlc_va_t *external, picture_t *p_picture, void *opaque,
-                    uint8_t *data )
-{
-    vlc_va_vda_t *p_va = vlc_va_vda_Get( external );
-
-    CVPixelBufferRef cv_buffer = (CVPixelBufferRef)data;
-
-    if( !cv_buffer )
-    {
-        msg_Dbg( p_va->p_log, "Frame buffer is empty.");
-        return VLC_EGENERIC;
-    }
-    if (!CVPixelBufferGetDataSize(cv_buffer) > 0)
-    {
-        msg_Dbg( p_va->p_log, "Empty frame buffer");
-        return VLC_EGENERIC;
-    }
-
-    vda_Copy422YpCbCr8( p_picture, cv_buffer );
-
-    (void) opaque;
-    return VLC_SUCCESS;
-}
-
-static void Release( void *opaque, uint8_t *data )
-{
-    (void) opaque; (void) data;
-}
-
-#endif
diff --git modules/codec/avcodec/video.c modules/codec/avcodec/video.c
index ce5254423..d171b4f5f 100644
--- modules/codec/avcodec/video.c
+++ modules/codec/avcodec/video.c
@@ -29,6 +29,8 @@
 # include "config.h"
 #endif
 
+#include <stdatomic.h>
+
 #include <vlc_common.h>
 #include <vlc_codec.h>
 #include <vlc_avcodec.h>
@@ -38,78 +40,98 @@
 #include <libavcodec/avcodec.h>
 #include <libavutil/mem.h>
 #include <libavutil/pixdesc.h>
+#if (LIBAVUTIL_VERSION_MICRO >= 100 && LIBAVUTIL_VERSION_INT >= AV_VERSION_INT( 55, 16, 101 ) )
+#include <libavutil/mastering_display_metadata.h>
+#endif
 
 #include "avcodec.h"
 #include "va.h"
 
+#if LIBAVUTIL_VERSION_CHECK( 52, 20, 0, 58, 100 )
+#include <libavutil/stereo3d.h>
+#endif
+
+#include "../codec/cc.h"
+#define FRAME_INFO_DEPTH 64
+
+struct frame_info_s
+{
+    bool b_eos;
+    bool b_display;
+};
+
 /*****************************************************************************
  * decoder_sys_t : decoder descriptor
  *****************************************************************************/
-struct decoder_sys_t
+typedef struct
 {
-    AVCODEC_COMMON_MEMBERS
+    AVCodecContext *p_context;
+    const AVCodec  *p_codec;
 
     /* Video decoder specific part */
-    mtime_t i_pts;
+    date_t  pts;
 
-    AVFrame          *p_ff_pic;
+    /* Closed captions for decoders */
+    cc_data_t cc;
 
     /* for frame skipping algo */
     bool b_hurry_up;
+    bool b_show_corrupted;
+    bool b_from_preroll;
     enum AVDiscard i_skip_frame;
-    enum AVDiscard i_skip_idct;
 
+    struct frame_info_s frame_info[FRAME_INFO_DEPTH];
+
+    enum
+    {
+        FRAMEDROP_NONE,
+        FRAMEDROP_NONREF,
+        FRAMEDROP_AGGRESSIVE_RECOVER,
+    } framedrop;
     /* how many decoded frames are late */
     int     i_late_frames;
-    mtime_t i_late_frames_start;
+    int64_t i_last_output_frame;
+    mtime_t i_last_late_delay;
 
     /* for direct rendering */
-    bool b_direct_rendering;
-    int  i_direct_rendering_used;
-
-    bool b_has_b_frames;
+    bool        b_direct_rendering;
+    atomic_bool b_dr_failure;
 
     /* Hack to force display of still pictures */
     bool b_first_frame;
 
 
     /* */
-#if LIBAVCODEC_VERSION_MAJOR < 54
-    AVPaletteControl palette;
-#else
     bool palette_sent;
-#endif
-
-    /* */
-    bool b_flush;
 
     /* VA API */
     vlc_va_t *p_va;
+    enum PixelFormat pix_fmt;
+    int profile;
+    int level;
 
     vlc_sem_t sem_mt;
-};
+} decoder_sys_t;
 
-#ifdef HAVE_AVCODEC_MT
-#   define wait_mt(s) vlc_sem_wait( &s->sem_mt )
-#   define post_mt(s) vlc_sem_post( &s->sem_mt )
-#else
-#   define wait_mt(s)
-#   define post_mt(s)
-#endif
+static inline void wait_mt(decoder_sys_t *sys)
+{
+    vlc_sem_wait(&sys->sem_mt);
+}
+
+static inline void post_mt(decoder_sys_t *sys)
+{
+    vlc_sem_post(&sys->sem_mt);
+}
 
 /*****************************************************************************
  * Local prototypes
  *****************************************************************************/
 static void ffmpeg_InitCodec      ( decoder_t * );
-static void ffmpeg_CopyPicture    ( decoder_t *, picture_t *, AVFrame * );
-#if LIBAVCODEC_VERSION_MAJOR >= 55
 static int lavc_GetFrame(struct AVCodecContext *, AVFrame *, int);
-#else
-static int  ffmpeg_GetFrameBuf    ( struct AVCodecContext *, AVFrame * );
-static void ffmpeg_ReleaseFrameBuf( struct AVCodecContext *, AVFrame * );
-#endif
 static enum PixelFormat ffmpeg_GetFormat( AVCodecContext *,
                                           const enum PixelFormat * );
+static int  DecodeVideo( decoder_t *, block_t * );
+static void Flush( decoder_t * );
 
 static uint32_t ffmpeg_CodecTag( vlc_fourcc_t fcc )
 {
@@ -121,96 +143,332 @@ static uint32_t ffmpeg_CodecTag( vlc_fourcc_t fcc )
  * Local Functions
  *****************************************************************************/
 
-/* Returns a new picture buffer */
-static inline picture_t *ffmpeg_NewPictBuf( decoder_t *p_dec,
-                                            AVCodecContext *p_context )
+/**
+ * Sets the decoder output format.
+ */
+static int lavc_GetVideoFormat(decoder_t *dec, video_format_t *restrict fmt,
+                               AVCodecContext *ctx, enum AVPixelFormat pix_fmt,
+                               enum AVPixelFormat sw_pix_fmt)
 {
-    decoder_sys_t *p_sys = p_dec->p_sys;
-    int width = p_context->coded_width;
-    int height = p_context->coded_height;
+    int width = ctx->coded_width;
+    int height = ctx->coded_height;
 
-    if( p_sys->p_va == NULL )
-    {
+    video_format_Init(fmt, 0);
+
+    if (pix_fmt == sw_pix_fmt)
+    {   /* software decoding */
         int aligns[AV_NUM_DATA_POINTERS];
 
-        avcodec_align_dimensions2(p_context, &width, &height, aligns);
-    }
+        if (GetVlcChroma(fmt, pix_fmt))
+            return -1;
 
+        /* The libavcodec palette can only be fetched when the first output
+         * frame is decoded. Assume that the current chroma is RGB32 while we
+         * are waiting for a valid palette. Indeed, fmt_out.video.p_palette
+         * doesn't trigger a new vout request, but a new chroma yes. */
+        if (pix_fmt == AV_PIX_FMT_PAL8 && !dec->fmt_out.video.p_palette)
+            fmt->i_chroma = VLC_CODEC_RGB32;
+
+        avcodec_align_dimensions2(ctx, &width, &height, aligns);
+    }
+    else /* hardware decoding */
+        fmt->i_chroma = vlc_va_GetChroma(pix_fmt, sw_pix_fmt);
 
     if( width == 0 || height == 0 || width > 8192 || height > 8192 ||
-        width < p_context->width || height < p_context->height )
+        width < ctx->width || height < ctx->height )
     {
-        msg_Err( p_dec, "Invalid frame size %dx%d. vsz %dx%d",
-                 width, height, p_context->width, p_context->height );
-        return NULL; /* invalid display size */
+        msg_Err(dec, "Invalid frame size %dx%d vsz %dx%d",
+                     width, height, ctx->width, ctx->height );
+        return -1; /* invalid display size */
     }
-    p_dec->fmt_out.video.i_width = width;
-    p_dec->fmt_out.video.i_height = height;
 
-    if( width != p_context->width || height != p_context->height )
+    fmt->i_width = width;
+    fmt->i_height = height;
+    fmt->i_visible_width = ctx->width;
+    fmt->i_visible_height = ctx->height;
+
+    /* If an aspect-ratio was specified in the input format then force it */
+    if (dec->fmt_in.video.i_sar_num > 0 && dec->fmt_in.video.i_sar_den > 0)
     {
-        p_dec->fmt_out.video.i_visible_width = p_context->width;
-        p_dec->fmt_out.video.i_visible_height = p_context->height;
+        fmt->i_sar_num = dec->fmt_in.video.i_sar_num;
+        fmt->i_sar_den = dec->fmt_in.video.i_sar_den;
     }
     else
     {
-        p_dec->fmt_out.video.i_visible_width = width;
-        p_dec->fmt_out.video.i_visible_height = height;
+        fmt->i_sar_num = ctx->sample_aspect_ratio.num;
+        fmt->i_sar_den = ctx->sample_aspect_ratio.den;
+
+        if (fmt->i_sar_num == 0 || fmt->i_sar_den == 0)
+            fmt->i_sar_num = fmt->i_sar_den = 1;
     }
 
-    if( !p_sys->p_va && GetVlcChroma( &p_dec->fmt_out.video, p_context->pix_fmt ) )
+    if (dec->fmt_in.video.i_frame_rate > 0
+     && dec->fmt_in.video.i_frame_rate_base > 0)
     {
-        /* we are doomed, but not really, because most codecs set their pix_fmt
-         * much later
-         * FIXME does it make sense here ? */
-        p_dec->fmt_out.video.i_chroma = VLC_CODEC_I420;
+        fmt->i_frame_rate = dec->fmt_in.video.i_frame_rate;
+        fmt->i_frame_rate_base = dec->fmt_in.video.i_frame_rate_base;
+    }
+    else if (ctx->framerate.num > 0 && ctx->framerate.den > 0)
+    {
+        fmt->i_frame_rate = ctx->framerate.num;
+        fmt->i_frame_rate_base = ctx->framerate.den;
+# if LIBAVCODEC_VERSION_MICRO <  100
+        // for some reason libav don't thinkg framerate presents actually same thing as in ffmpeg
+        fmt->i_frame_rate_base *= __MAX(ctx->ticks_per_frame, 1);
+# endif
+    }
+    else if (ctx->time_base.num > 0 && ctx->time_base.den > 0)
+    {
+        fmt->i_frame_rate = ctx->time_base.den;
+        fmt->i_frame_rate_base = ctx->time_base.num
+                                 * __MAX(ctx->ticks_per_frame, 1);
     }
-    p_dec->fmt_out.i_codec = p_dec->fmt_out.video.i_chroma;
 
-    /* If an aspect-ratio was specified in the input format then force it */
-    if( p_dec->fmt_in.video.i_sar_num > 0 && p_dec->fmt_in.video.i_sar_den > 0 )
+    /* FIXME we should only set the known values and let the core decide
+     * later of fallbacks, but we can't do that with a boolean */
+    switch ( ctx->color_range )
     {
-        p_dec->fmt_out.video.i_sar_num = p_dec->fmt_in.video.i_sar_num;
-        p_dec->fmt_out.video.i_sar_den = p_dec->fmt_in.video.i_sar_den;
+    case AVCOL_RANGE_JPEG:
+        fmt->b_color_range_full = true;
+        break;
+    case AVCOL_RANGE_UNSPECIFIED:
+        fmt->b_color_range_full = !vlc_fourcc_IsYUV( fmt->i_chroma );
+        break;
+    case AVCOL_RANGE_MPEG:
+    default:
+        fmt->b_color_range_full = false;
+        break;
     }
-    else
+
+    switch( ctx->colorspace )
     {
-        p_dec->fmt_out.video.i_sar_num = p_context->sample_aspect_ratio.num;
-        p_dec->fmt_out.video.i_sar_den = p_context->sample_aspect_ratio.den;
+        case AVCOL_SPC_BT709:
+            fmt->space = COLOR_SPACE_BT709;
+            break;
+        case AVCOL_SPC_SMPTE170M:
+        case AVCOL_SPC_BT470BG:
+            fmt->space = COLOR_SPACE_BT601;
+            break;
+        case AVCOL_SPC_BT2020_NCL:
+        case AVCOL_SPC_BT2020_CL:
+            fmt->space = COLOR_SPACE_BT2020;
+            break;
+        default:
+            break;
+    }
 
-        if( !p_dec->fmt_out.video.i_sar_num || !p_dec->fmt_out.video.i_sar_den )
-        {
-            p_dec->fmt_out.video.i_sar_num = 1;
-            p_dec->fmt_out.video.i_sar_den = 1;
-        }
+    switch( ctx->color_trc )
+    {
+        case AVCOL_TRC_LINEAR:
+            fmt->transfer = TRANSFER_FUNC_LINEAR;
+            break;
+        case AVCOL_TRC_GAMMA22:
+            fmt->transfer = TRANSFER_FUNC_SRGB;
+            break;
+        case AVCOL_TRC_BT709:
+            fmt->transfer = TRANSFER_FUNC_BT709;
+            break;
+        case AVCOL_TRC_SMPTE170M:
+        case AVCOL_TRC_BT2020_10:
+        case AVCOL_TRC_BT2020_12:
+            fmt->transfer = TRANSFER_FUNC_BT2020;
+            break;
+#if LIBAVUTIL_VERSION_CHECK( 55, 14, 0, 31, 100)
+        case AVCOL_TRC_ARIB_STD_B67:
+            fmt->transfer = TRANSFER_FUNC_ARIB_B67;
+            break;
+#endif
+#if LIBAVUTIL_VERSION_CHECK( 55, 17, 0, 37, 100)
+        case AVCOL_TRC_SMPTE2084:
+            fmt->transfer = TRANSFER_FUNC_SMPTE_ST2084;
+            break;
+        case AVCOL_TRC_SMPTE240M:
+            fmt->transfer = TRANSFER_FUNC_SMPTE_240;
+            break;
+        case AVCOL_TRC_GAMMA28:
+            fmt->transfer = TRANSFER_FUNC_BT470_BG;
+            break;
+#endif
+        default:
+            break;
     }
 
-    if( p_dec->fmt_in.video.i_frame_rate > 0 &&
-        p_dec->fmt_in.video.i_frame_rate_base > 0 )
+    switch( ctx->color_primaries )
     {
-        p_dec->fmt_out.video.i_frame_rate =
-            p_dec->fmt_in.video.i_frame_rate;
-        p_dec->fmt_out.video.i_frame_rate_base =
-            p_dec->fmt_in.video.i_frame_rate_base;
+        case AVCOL_PRI_BT709:
+            fmt->primaries = COLOR_PRIMARIES_BT709;
+            break;
+        case AVCOL_PRI_BT470BG:
+            fmt->primaries = COLOR_PRIMARIES_BT601_625;
+            break;
+        case AVCOL_PRI_SMPTE170M:
+        case AVCOL_PRI_SMPTE240M:
+            fmt->primaries = COLOR_PRIMARIES_BT601_525;
+            break;
+        case AVCOL_PRI_BT2020:
+            fmt->primaries = COLOR_PRIMARIES_BT2020;
+            break;
+        default:
+            break;
     }
-#if LIBAVCODEC_VERSION_CHECK( 56, 5, 0, 7, 100 )
-    else if( p_context->framerate.num > 0 && p_context->framerate.den > 0 )
+
+    switch( ctx->chroma_sample_location )
     {
-        p_dec->fmt_out.video.i_frame_rate = p_context->framerate.num;
-        p_dec->fmt_out.video.i_frame_rate_base = p_context->framerate.den;
-# if LIBAVCODEC_VERSION_MICRO <  100
-        // for some reason libav don't thinkg framerate presents actually same thing as in ffmpeg
-        p_dec->fmt_out.video.i_frame_rate_base *= __MAX( p_context->ticks_per_frame, 1 );
-# endif
+        case AVCHROMA_LOC_LEFT:
+            fmt->chroma_location = CHROMA_LOCATION_LEFT;
+            break;
+        case AVCHROMA_LOC_CENTER:
+            fmt->chroma_location = CHROMA_LOCATION_CENTER;
+            break;
+        case AVCHROMA_LOC_TOPLEFT:
+            fmt->chroma_location = CHROMA_LOCATION_TOP_LEFT;
+            break;
+        default:
+            break;
     }
-#endif
-    else if( p_context->time_base.num > 0 && p_context->time_base.den > 0 )
+
+    return 0;
+}
+
+static int lavc_UpdateVideoFormat(decoder_t *dec, AVCodecContext *ctx,
+                                  enum AVPixelFormat fmt,
+                                  enum AVPixelFormat swfmt)
+{
+    video_format_t fmt_out;
+    int val;
+
+    val = lavc_GetVideoFormat(dec, &fmt_out, ctx, fmt, swfmt);
+    if (val)
+        return val;
+
+    decoder_sys_t *p_sys = dec->p_sys;
+
+    /* always have date in fields/ticks units */
+    if(p_sys->pts.i_divider_num)
+        date_Change(&p_sys->pts, fmt_out.i_frame_rate *
+                                 __MAX(ctx->ticks_per_frame, 1),
+                                 fmt_out.i_frame_rate_base);
+    else
+        date_Init(&p_sys->pts, fmt_out.i_frame_rate *
+                               __MAX(ctx->ticks_per_frame, 1),
+                               fmt_out.i_frame_rate_base);
+
+    fmt_out.p_palette = dec->fmt_out.video.p_palette;
+    dec->fmt_out.video.p_palette = NULL;
+
+    es_format_Change(&dec->fmt_out, VIDEO_ES, fmt_out.i_chroma);
+    dec->fmt_out.video = fmt_out;
+    dec->fmt_out.video.orientation = dec->fmt_in.video.orientation;
+    dec->fmt_out.video.projection_mode = dec->fmt_in.video.projection_mode;
+    dec->fmt_out.video.multiview_mode = dec->fmt_in.video.multiview_mode;
+    dec->fmt_out.video.pose = dec->fmt_in.video.pose;
+    if ( dec->fmt_in.video.mastering.max_luminance )
+        dec->fmt_out.video.mastering = dec->fmt_in.video.mastering;
+    dec->fmt_out.video.lighting = dec->fmt_in.video.lighting;
+
+    return decoder_UpdateVideoFormat(dec);
+}
+
+/**
+ * Copies a picture from the libavcodec-allocate buffer to a picture_t.
+ * This is used when not in direct rendering mode.
+ */
+static int lavc_CopyPicture(decoder_t *dec, picture_t *pic, AVFrame *frame)
+{
+    decoder_sys_t *sys = dec->p_sys;
+
+    vlc_fourcc_t fourcc = FindVlcChroma(frame->format);
+    if (!fourcc)
+    {
+        const char *name = av_get_pix_fmt_name(frame->format);
+
+        msg_Err(dec, "Unsupported decoded output format %d (%s)",
+                sys->p_context->pix_fmt, (name != NULL) ? name : "unknown");
+        return VLC_EGENERIC;
+    } else if (fourcc != pic->format.i_chroma
+     || frame->width > (int) pic->format.i_width
+     || frame->height > (int) pic->format.i_height)
     {
-        p_dec->fmt_out.video.i_frame_rate = p_context->time_base.den;
-        p_dec->fmt_out.video.i_frame_rate_base = p_context->time_base.num * __MAX( p_context->ticks_per_frame, 1 );
+        msg_Warn(dec, "dropping frame because the vout changed");
+        return VLC_EGENERIC;
     }
 
-    return decoder_NewPicture( p_dec );
+    for (int plane = 0; plane < pic->i_planes; plane++)
+    {
+        const uint8_t *src = frame->data[plane];
+        uint8_t *dst = pic->p[plane].p_pixels;
+        size_t src_stride = frame->linesize[plane];
+        size_t dst_stride = pic->p[plane].i_pitch;
+        size_t size = __MIN(src_stride, dst_stride);
+
+        for (int line = 0; line < pic->p[plane].i_visible_lines; line++)
+        {
+            memcpy(dst, src, size);
+            src += src_stride;
+            dst += dst_stride;
+        }
+    }
+    return VLC_SUCCESS;
+}
+
+static int OpenVideoCodec( decoder_t *p_dec )
+{
+    decoder_sys_t *p_sys = p_dec->p_sys;
+    AVCodecContext *ctx = p_sys->p_context;
+    const AVCodec *codec = p_sys->p_codec;
+    int ret;
+
+    if( ctx->extradata_size <= 0 )
+    {
+        if( codec->id == AV_CODEC_ID_VC1 ||
+            codec->id == AV_CODEC_ID_THEORA )
+        {
+            msg_Warn( p_dec, "waiting for extra data for codec %s",
+                      codec->name );
+            return 1;
+        }
+    }
+
+    ctx->width  = p_dec->fmt_in.video.i_visible_width;
+    ctx->height = p_dec->fmt_in.video.i_visible_height;
+
+    ctx->coded_width = p_dec->fmt_in.video.i_width;
+    ctx->coded_height = p_dec->fmt_in.video.i_height;
+
+    ctx->bits_per_coded_sample = p_dec->fmt_in.video.i_bits_per_pixel;
+    p_sys->pix_fmt = AV_PIX_FMT_NONE;
+    p_sys->profile = -1;
+    p_sys->level = -1;
+    cc_Init( &p_sys->cc );
+
+    set_video_color_settings( &p_dec->fmt_in.video, ctx );
+
+    post_mt( p_sys );
+    ret = ffmpeg_OpenCodec( p_dec, ctx, codec );
+    wait_mt( p_sys );
+    if( ret < 0 )
+        return ret;
+
+    switch( ctx->active_thread_type )
+    {
+        case FF_THREAD_FRAME:
+            msg_Dbg( p_dec, "using frame thread mode with %d threads",
+                     ctx->thread_count );
+            break;
+        case FF_THREAD_SLICE:
+            msg_Dbg( p_dec, "using slice thread mode with %d threads",
+                     ctx->thread_count );
+            break;
+        case 0:
+            if( ctx->thread_count > 1 )
+                msg_Warn( p_dec, "failed to enable threaded decoding" );
+            break;
+        default:
+            msg_Warn( p_dec, "using unknown thread mode with %d threads",
+                      ctx->thread_count );
+            break;
+    }
+    return 0;
 }
 
 /*****************************************************************************
@@ -219,118 +477,99 @@ static inline picture_t *ffmpeg_NewPictBuf( decoder_t *p_dec,
  * the ffmpeg codec will be opened, some memory allocated. The vout is not yet
  * opened (done after the first decoded frame).
  *****************************************************************************/
-int InitVideoDec( decoder_t *p_dec, AVCodecContext *p_context,
-                      AVCodec *p_codec, int i_codec_id, const char *psz_namecodec )
+int InitVideoDec( vlc_object_t *obj )
 {
-    decoder_sys_t *p_sys;
+    decoder_t *p_dec = (decoder_t *)obj;
+    const AVCodec *p_codec;
+    AVCodecContext *p_context = ffmpeg_AllocContext( p_dec, &p_codec );
+    if( p_context == NULL )
+        return VLC_EGENERIC;
+
     int i_val;
 
     /* Allocate the memory needed to store the decoder's structure */
-    if( ( p_dec->p_sys = p_sys = calloc( 1, sizeof(decoder_sys_t) ) ) == NULL )
+    decoder_sys_t *p_sys = calloc( 1, sizeof(*p_sys) );
+    if( unlikely(p_sys == NULL) )
+    {
+        avcodec_free_context( &p_context );
         return VLC_ENOMEM;
+    }
 
-    p_codec->type = AVMEDIA_TYPE_VIDEO;
-    p_context->codec_type = AVMEDIA_TYPE_VIDEO;
-    p_context->codec_id = i_codec_id;
+    p_dec->p_sys = p_sys;
     p_sys->p_context = p_context;
     p_sys->p_codec = p_codec;
-    p_sys->i_codec_id = i_codec_id;
-    p_sys->psz_namecodec = psz_namecodec;
-    p_sys->p_ff_pic = avcodec_alloc_frame();
-    p_sys->b_delayed_open = true;
     p_sys->p_va = NULL;
     vlc_sem_init( &p_sys->sem_mt, 0 );
 
     /* ***** Fill p_context with init values ***** */
-    p_sys->p_context->codec_tag = ffmpeg_CodecTag( p_dec->fmt_in.i_original_fourcc ?: p_dec->fmt_in.i_codec );
+    p_context->codec_tag = ffmpeg_CodecTag( p_dec->fmt_in.i_original_fourcc ?
+                                p_dec->fmt_in.i_original_fourcc : p_dec->fmt_in.i_codec );
 
     /*  ***** Get configuration of ffmpeg plugin ***** */
-    p_sys->p_context->workaround_bugs =
+    p_context->workaround_bugs =
         var_InheritInteger( p_dec, "avcodec-workaround-bugs" );
-    p_sys->p_context->err_recognition =
+    p_context->err_recognition =
         var_InheritInteger( p_dec, "avcodec-error-resilience" );
 
     if( var_CreateGetBool( p_dec, "grayscale" ) )
-        p_sys->p_context->flags |= CODEC_FLAG_GRAY;
+        p_context->flags |= AV_CODEC_FLAG_GRAY;
 
     /* ***** Output always the frames ***** */
-#if LIBAVCODEC_VERSION_CHECK(55, 23, 1, 40, 101)
-    p_sys->p_context->flags |= CODEC_FLAG_OUTPUT_CORRUPT;
-#endif
-
-    i_val = var_CreateGetInteger( p_dec, "avcodec-vismv" );
-    if( i_val ) p_sys->p_context->debug_mv = i_val;
+    p_context->flags |= AV_CODEC_FLAG_OUTPUT_CORRUPT;
 
     i_val = var_CreateGetInteger( p_dec, "avcodec-skiploopfilter" );
-    if( i_val >= 4 ) p_sys->p_context->skip_loop_filter = AVDISCARD_ALL;
-    else if( i_val == 3 ) p_sys->p_context->skip_loop_filter = AVDISCARD_NONKEY;
-    else if( i_val == 2 ) p_sys->p_context->skip_loop_filter = AVDISCARD_BIDIR;
-    else if( i_val == 1 ) p_sys->p_context->skip_loop_filter = AVDISCARD_NONREF;
+    if( i_val >= 4 ) p_context->skip_loop_filter = AVDISCARD_ALL;
+    else if( i_val == 3 ) p_context->skip_loop_filter = AVDISCARD_NONKEY;
+    else if( i_val == 2 ) p_context->skip_loop_filter = AVDISCARD_BIDIR;
+    else if( i_val == 1 ) p_context->skip_loop_filter = AVDISCARD_NONREF;
+    else p_context->skip_loop_filter = AVDISCARD_DEFAULT;
 
     if( var_CreateGetBool( p_dec, "avcodec-fast" ) )
-        p_sys->p_context->flags2 |= CODEC_FLAG2_FAST;
+        p_context->flags2 |= AV_CODEC_FLAG2_FAST;
 
     /* ***** libavcodec frame skipping ***** */
     p_sys->b_hurry_up = var_CreateGetBool( p_dec, "avcodec-hurry-up" );
+    p_sys->b_show_corrupted = var_CreateGetBool( p_dec, "avcodec-corrupted" );
 
     i_val = var_CreateGetInteger( p_dec, "avcodec-skip-frame" );
-    if( i_val >= 4 ) p_sys->p_context->skip_frame = AVDISCARD_ALL;
-    else if( i_val == 3 ) p_sys->p_context->skip_frame = AVDISCARD_NONKEY;
-    else if( i_val == 2 ) p_sys->p_context->skip_frame = AVDISCARD_BIDIR;
-    else if( i_val == 1 ) p_sys->p_context->skip_frame = AVDISCARD_NONREF;
-    else if( i_val == -1 ) p_sys->p_context->skip_frame = AVDISCARD_NONE;
-    else p_sys->p_context->skip_frame = AVDISCARD_DEFAULT;
-    p_sys->i_skip_frame = p_sys->p_context->skip_frame;
+    if( i_val >= 4 ) p_sys->i_skip_frame = AVDISCARD_ALL;
+    else if( i_val == 3 ) p_sys->i_skip_frame = AVDISCARD_NONKEY;
+    else if( i_val == 2 ) p_sys->i_skip_frame = AVDISCARD_BIDIR;
+    else if( i_val == 1 ) p_sys->i_skip_frame = AVDISCARD_NONREF;
+    else if( i_val == -1 ) p_sys->i_skip_frame = AVDISCARD_NONE;
+    else p_sys->i_skip_frame = AVDISCARD_DEFAULT;
+    p_context->skip_frame = p_sys->i_skip_frame;
 
     i_val = var_CreateGetInteger( p_dec, "avcodec-skip-idct" );
-    if( i_val >= 4 ) p_sys->p_context->skip_idct = AVDISCARD_ALL;
-    else if( i_val == 3 ) p_sys->p_context->skip_idct = AVDISCARD_NONKEY;
-    else if( i_val == 2 ) p_sys->p_context->skip_idct = AVDISCARD_BIDIR;
-    else if( i_val == 1 ) p_sys->p_context->skip_idct = AVDISCARD_NONREF;
-    else if( i_val == -1 ) p_sys->p_context->skip_idct = AVDISCARD_NONE;
-    else p_sys->p_context->skip_idct = AVDISCARD_DEFAULT;
-    p_sys->i_skip_idct = p_sys->p_context->skip_idct;
+    if( i_val >= 4 ) p_context->skip_idct = AVDISCARD_ALL;
+    else if( i_val == 3 ) p_context->skip_idct = AVDISCARD_NONKEY;
+    else if( i_val == 2 ) p_context->skip_idct = AVDISCARD_BIDIR;
+    else if( i_val == 1 ) p_context->skip_idct = AVDISCARD_NONREF;
+    else if( i_val == -1 ) p_context->skip_idct = AVDISCARD_NONE;
+    else p_context->skip_idct = AVDISCARD_DEFAULT;
 
     /* ***** libavcodec direct rendering ***** */
     p_sys->b_direct_rendering = false;
-    p_sys->i_direct_rendering_used = -1;
+    atomic_init(&p_sys->b_dr_failure, false);
     if( var_CreateGetBool( p_dec, "avcodec-dr" ) &&
-       (p_sys->p_codec->capabilities & CODEC_CAP_DR1) &&
+       (p_codec->capabilities & AV_CODEC_CAP_DR1) &&
         /* No idea why ... but this fixes flickering on some TSCC streams */
-        p_sys->i_codec_id != AV_CODEC_ID_TSCC && p_sys->i_codec_id != AV_CODEC_ID_CSCD &&
-        p_sys->i_codec_id != AV_CODEC_ID_CINEPAK &&
-        !p_sys->p_context->debug_mv )
+        p_sys->p_codec->id != AV_CODEC_ID_TSCC &&
+        p_sys->p_codec->id != AV_CODEC_ID_CSCD &&
+        p_sys->p_codec->id != AV_CODEC_ID_CINEPAK )
     {
         /* Some codecs set pix_fmt only after the 1st frame has been decoded,
          * so we need to do another check in ffmpeg_GetFrameBuf() */
         p_sys->b_direct_rendering = true;
     }
 
-    /* libavcodec doesn't properly release old pictures when frames are skipped */
-    //if( p_sys->b_hurry_up ) p_sys->b_direct_rendering = false;
-    if( p_sys->b_direct_rendering )
-    {
-        msg_Dbg( p_dec, "trying to use direct rendering" );
-        p_sys->p_context->flags |= CODEC_FLAG_EMU_EDGE;
-    }
-    else
-    {
-        msg_Dbg( p_dec, "direct rendering is disabled" );
-    }
-
-    p_sys->p_context->get_format = ffmpeg_GetFormat;
+    p_context->get_format = ffmpeg_GetFormat;
     /* Always use our get_buffer wrapper so we can calculate the
      * PTS correctly */
-#if LIBAVCODEC_VERSION_MAJOR >= 55
-    p_sys->p_context->get_buffer2 = lavc_GetFrame;
-#else
-    p_sys->p_context->get_buffer = ffmpeg_GetFrameBuf;
-    p_sys->p_context->reget_buffer = avcodec_default_reget_buffer;
-    p_sys->p_context->release_buffer = ffmpeg_ReleaseFrameBuf;
-#endif
-    p_sys->p_context->opaque = p_dec;
+    p_context->get_buffer2 = lavc_GetFrame;
+    p_context->opaque = p_dec;
+    p_context->reordered_opaque = 0;
 
-#ifdef HAVE_AVCODEC_MT
     int i_thread_count = var_InheritInteger( p_dec, "avcodec-threads" );
     if( i_thread_count <= 0 )
     {
@@ -339,59 +578,50 @@ int InitVideoDec( decoder_t *p_dec, AVCodecContext *p_context,
             i_thread_count++;
 
         //FIXME: take in count the decoding time
-        i_thread_count = __MIN( i_thread_count, 4 );
+#if VLC_WINSTORE_APP
+        i_thread_count = __MIN( i_thread_count, 6 );
+#else
+        i_thread_count = __MIN( i_thread_count, p_codec->id == AV_CODEC_ID_HEVC ? 10 : 6 );
+#endif
     }
-    i_thread_count = __MIN( i_thread_count, 16 );
+    i_thread_count = __MIN( i_thread_count, p_codec->id == AV_CODEC_ID_HEVC ? 32 : 16 );
     msg_Dbg( p_dec, "allowing %d thread(s) for decoding", i_thread_count );
-    p_sys->p_context->thread_count = i_thread_count;
-    p_sys->p_context->thread_safe_callbacks = true;
+    p_context->thread_count = i_thread_count;
+    p_context->thread_safe_callbacks = true;
 
-    switch( i_codec_id )
+    switch( p_codec->id )
     {
         case AV_CODEC_ID_MPEG4:
         case AV_CODEC_ID_H263:
-            p_sys->p_context->thread_type = 0;
+            p_context->thread_type = 0;
             break;
         case AV_CODEC_ID_MPEG1VIDEO:
         case AV_CODEC_ID_MPEG2VIDEO:
-            p_sys->p_context->thread_type &= ~FF_THREAD_SLICE;
+            p_context->thread_type &= ~FF_THREAD_SLICE;
             /* fall through */
 # if (LIBAVCODEC_VERSION_INT < AV_VERSION_INT(55, 1, 0))
         case AV_CODEC_ID_H264:
         case AV_CODEC_ID_VC1:
         case AV_CODEC_ID_WMV3:
-            p_sys->p_context->thread_type &= ~FF_THREAD_FRAME;
+            p_context->thread_type &= ~FF_THREAD_FRAME;
 # endif
+        default:
+            break;
     }
 
-    /* Workaround: frame multithreading is not compatible with
-     * DXVA2. When a frame is being copied to host memory, the frame
-     * is locked and cannot be used as a reference frame
-     * simultaneously and thus decoding fails for some frames. This
-     * causes major image corruption. */
-# if defined(_WIN32)
-    char *avcodec_hw = var_InheritString( p_dec, "avcodec-hw" );
-    if( avcodec_hw == NULL || strcasecmp( avcodec_hw, "none" ) )
-    {
-        msg_Warn( p_dec, "threaded frame decoding is not compatible with DXVA2, disabled" );
-        p_sys->p_context->thread_type &= ~FF_THREAD_FRAME;
-    }
-    free( avcodec_hw );
-# endif
-
-    if( p_sys->p_context->thread_type & FF_THREAD_FRAME )
-        p_dec->i_extra_picture_buffers = 2 * p_sys->p_context->thread_count;
-#endif
+    if( p_context->thread_type & FF_THREAD_FRAME )
+        p_dec->i_extra_picture_buffers = 2 * p_context->thread_count;
 
     /* ***** misc init ***** */
-    p_sys->i_pts = VLC_TS_INVALID;
-    p_sys->b_has_b_frames = false;
+    date_Init(&p_sys->pts, 1, 30001);
+    date_Set(&p_sys->pts, VLC_TS_INVALID);
     p_sys->b_first_frame = true;
-    p_sys->b_flush = false;
     p_sys->i_late_frames = 0;
+    p_sys->b_from_preroll = false;
+    p_sys->i_last_output_frame = -1;
+    p_sys->framedrop = FRAMEDROP_NONE;
 
     /* Set output properties */
-    p_dec->fmt_out.i_cat = VIDEO_ES;
     if( GetVlcChroma( &p_dec->fmt_out.video, p_context->pix_fmt ) != VLC_SUCCESS )
     {
         /* we are doomed. but not really, because most codecs set their pix_fmt later on */
@@ -401,37 +631,6 @@ int InitVideoDec( decoder_t *p_dec, AVCodecContext *p_context,
 
     p_dec->fmt_out.video.orientation = p_dec->fmt_in.video.orientation;
 
-#if LIBAVCODEC_VERSION_MAJOR < 54
-    /* Setup palette */
-    memset( &p_sys->palette, 0, sizeof(p_sys->palette) );
-    if( p_dec->fmt_in.video.p_palette )
-    {
-        p_sys->palette.palette_changed = 1;
-
-        for( int i = 0; i < __MIN( AVPALETTE_COUNT, p_dec->fmt_in.video.p_palette->i_entries ); i++ )
-        {
-            union {
-                uint32_t u;
-                uint8_t a[4];
-            } c;
-            c.a[0] = p_dec->fmt_in.video.p_palette->palette[i][0];
-            c.a[1] = p_dec->fmt_in.video.p_palette->palette[i][1];
-            c.a[2] = p_dec->fmt_in.video.p_palette->palette[i][2];
-            c.a[3] = p_dec->fmt_in.video.p_palette->palette[i][3];
-
-            p_sys->palette.palette[i] = c.u;
-        }
-        p_sys->p_context->palctrl = &p_sys->palette;
-
-        p_dec->fmt_out.video.p_palette = malloc( sizeof(video_palette_t) );
-        if( p_dec->fmt_out.video.p_palette )
-            *p_dec->fmt_out.video.p_palette = *p_dec->fmt_in.video.p_palette;
-    }
-    else if( p_sys->i_codec_id != CODEC_ID_MSVIDEO1 && p_sys->i_codec_id != CODEC_ID_CINEPAK )
-    {
-        p_sys->p_context->palctrl = &p_sys->palette;
-    }
-#else
     if( p_dec->fmt_in.video.p_palette ) {
         p_sys->palette_sent = false;
         p_dec->fmt_out.video.p_palette = malloc( sizeof(video_palette_t) );
@@ -439,149 +638,369 @@ int InitVideoDec( decoder_t *p_dec, AVCodecContext *p_context,
             *p_dec->fmt_out.video.p_palette = *p_dec->fmt_in.video.p_palette;
     } else
         p_sys->palette_sent = true;
-#endif
 
     /* ***** init this codec with special data ***** */
     ffmpeg_InitCodec( p_dec );
 
     /* ***** Open the codec ***** */
-    if( ffmpeg_OpenCodec( p_dec ) < 0 )
+    if( OpenVideoCodec( p_dec ) < 0 )
     {
-        msg_Err( p_dec, "cannot open codec (%s)", p_sys->psz_namecodec );
-        avcodec_free_frame( &p_sys->p_ff_pic );
         vlc_sem_destroy( &p_sys->sem_mt );
         free( p_sys );
+        avcodec_free_context( &p_context );
         return VLC_EGENERIC;
     }
 
-    if ( p_dec->fmt_in.i_codec == VLC_CODEC_VP9 )
-        p_dec->b_need_packetized = true;
+    p_dec->pf_decode = DecodeVideo;
+    p_dec->pf_flush  = Flush;
 
+    /* XXX: Writing input format makes little sense. */
+    if( p_context->profile != FF_PROFILE_UNKNOWN )
+        p_dec->fmt_in.i_profile = p_context->profile;
+    if( p_context->level != FF_LEVEL_UNKNOWN )
+        p_dec->fmt_in.i_level = p_context->level;
     return VLC_SUCCESS;
 }
 
 /*****************************************************************************
- * DecodeVideo: Called to decode one or more frames
+ * Flush:
  *****************************************************************************/
-picture_t *DecodeVideo( decoder_t *p_dec, block_t **pp_block )
+static void Flush( decoder_t *p_dec )
 {
     decoder_sys_t *p_sys = p_dec->p_sys;
     AVCodecContext *p_context = p_sys->p_context;
-    int b_drawpicture;
-    block_t *p_block;
 
-    if( !pp_block )
+    date_Set(&p_sys->pts, VLC_TS_INVALID); /* To make sure we recover properly */
+    p_sys->i_late_frames = 0;
+    p_sys->framedrop = FRAMEDROP_NONE;
+    cc_Flush( &p_sys->cc );
+
+    /* Abort pictures in order to unblock all avcodec workers threads waiting
+     * for a picture. This will avoid a deadlock between avcodec_flush_buffers
+     * and workers threads */
+    decoder_AbortPictures( p_dec, true );
+
+    post_mt( p_sys );
+    /* do not flush buffers if codec hasn't been opened (theora/vorbis/VC1) */
+    if( avcodec_is_open( p_context ) )
+        avcodec_flush_buffers( p_context );
+    wait_mt( p_sys );
+
+    /* Reset cancel state to false */
+    decoder_AbortPictures( p_dec, false );
+}
+
+static block_t * filter_earlydropped_blocks( decoder_t *p_dec, block_t *block )
+{
+    decoder_sys_t *p_sys = p_dec->p_sys;
+
+    if( !block )
         return NULL;
 
-    if( !p_context->extradata_size && p_dec->fmt_in.i_extra )
+    if( block->i_flags & BLOCK_FLAG_PREROLL )
     {
-        ffmpeg_InitCodec( p_dec );
-        if( p_sys->b_delayed_open )
-        {
-            if( ffmpeg_OpenCodec( p_dec ) )
-                msg_Err( p_dec, "cannot open codec (%s)", p_sys->psz_namecodec );
-        }
+        /* Do not care about late frames when prerolling
+         * TODO avoid decoding of non reference frame
+         * (ie all B except for H264 where it depends only on nal_ref_idc) */
+        p_sys->i_late_frames = 0;
+        p_sys->framedrop = FRAMEDROP_NONE;
+        p_sys->b_from_preroll = true;
+        p_sys->i_last_late_delay = INT64_MAX;
     }
 
-    p_block = *pp_block;
-    if(!p_block && !(p_sys->p_codec->capabilities & CODEC_CAP_DELAY) )
-        return NULL;
+    if( p_sys->i_late_frames == 0 )
+        p_sys->framedrop = FRAMEDROP_NONE;
+
+    if( p_sys->framedrop == FRAMEDROP_NONE && p_sys->i_late_frames < 11 )
+        return block;
 
-    if( p_sys->b_delayed_open )
+    if( p_sys->i_last_output_frame >= 0 &&
+        p_sys->p_context->reordered_opaque - p_sys->i_last_output_frame > 24 )
     {
-        if( p_block )
-            block_Release( p_block );
-        return NULL;
+        p_sys->framedrop = FRAMEDROP_AGGRESSIVE_RECOVER;
     }
 
-    if( p_block)
+    /* A good idea could be to decode all I pictures and see for the other */
+    if( p_sys->framedrop == FRAMEDROP_AGGRESSIVE_RECOVER )
     {
-        if( p_block->i_flags & (BLOCK_FLAG_DISCONTINUITY|BLOCK_FLAG_CORRUPTED) )
+        if( !(block->i_flags & BLOCK_FLAG_TYPE_I) )
         {
-            p_sys->i_pts = VLC_TS_INVALID; /* To make sure we recover properly */
+            msg_Err( p_dec, "more than %"PRId64" frames of late video -> "
+                            "dropping frame (computer too slow ?)",
+                     p_sys->p_context->reordered_opaque - p_sys->i_last_output_frame );
 
-            p_sys->i_late_frames = 0;
+            date_Set( &p_sys->pts, VLC_TS_INVALID ); /* To make sure we recover properly */
+            block_Release( block );
+            p_sys->i_late_frames--;
+            return NULL;
+        }
+    }
 
-            post_mt( p_sys );
-            if( p_block->i_flags & BLOCK_FLAG_DISCONTINUITY )
-                avcodec_flush_buffers( p_context );
-            wait_mt( p_sys );
+    return block;
+}
 
-            block_Release( p_block );
-            return NULL;
+static void interpolate_next_pts( decoder_t *p_dec, AVFrame *frame )
+{
+    decoder_sys_t *p_sys = p_dec->p_sys;
+    AVCodecContext *p_context = p_sys->p_context;
+
+    if( p_sys->pts.i_divider_num == 0 ||
+        date_Get( &p_sys->pts ) == VLC_TS_INVALID )
+        return;
+
+    int i_tick = p_context->ticks_per_frame;
+    if( i_tick <= 0 )
+        i_tick = 1;
+
+    /* interpolate the next PTS */
+    date_Increment( &p_sys->pts, i_tick + frame->repeat_pict );
+}
+
+static void update_late_frame_count( decoder_t *p_dec, block_t *p_block,
+                                     mtime_t current_time, mtime_t i_pts, int64_t i_fnum )
+{
+    decoder_sys_t *p_sys = p_dec->p_sys;
+   /* Update frame late count (except when doing preroll) */
+   mtime_t i_display_date = VLC_TS_INVALID;
+   if( !p_block || !(p_block->i_flags & BLOCK_FLAG_PREROLL) )
+       i_display_date = decoder_GetDisplayDate( p_dec, i_pts );
+
+   if( i_display_date != VLC_TS_INVALID && i_display_date <= current_time )
+   {
+       /* Out of preroll, consider only late frames on rising delay */
+       if( p_sys->b_from_preroll )
+       {
+           if( p_sys->i_last_late_delay > current_time - i_display_date )
+           {
+               p_sys->i_last_late_delay = current_time - i_display_date;
+               return;
+           }
+           p_sys->b_from_preroll = false;
+       }
+
+       p_sys->i_late_frames++;
+   }
+   else
+   {
+       p_sys->i_last_output_frame = i_fnum;
+       p_sys->i_late_frames = 0;
+   }
+}
+
+
+static int DecodeSidedata( decoder_t *p_dec, const AVFrame *frame, picture_t *p_pic )
+{
+    decoder_sys_t *p_sys = p_dec->p_sys;
+    bool format_changed = false;
+
+#if (LIBAVUTIL_VERSION_MICRO >= 100 && LIBAVUTIL_VERSION_INT >= AV_VERSION_INT( 55, 16, 101 ) )
+#define FROM_AVRAT(default_factor, avrat) \
+(uint64_t)(default_factor) * (avrat).num / (avrat).den
+    const AVFrameSideData *metadata =
+            av_frame_get_side_data( frame,
+                                    AV_FRAME_DATA_MASTERING_DISPLAY_METADATA );
+    if ( metadata )
+    {
+        const AVMasteringDisplayMetadata *hdr_meta =
+                (const AVMasteringDisplayMetadata *) metadata->data;
+        if ( hdr_meta->has_luminance )
+        {
+#define ST2086_LUMA_FACTOR 10000
+            p_pic->format.mastering.max_luminance =
+                    FROM_AVRAT(ST2086_LUMA_FACTOR, hdr_meta->max_luminance);
+            p_pic->format.mastering.min_luminance =
+                    FROM_AVRAT(ST2086_LUMA_FACTOR, hdr_meta->min_luminance);
+        }
+        if ( hdr_meta->has_primaries )
+        {
+#define ST2086_RED   2
+#define ST2086_GREEN 0
+#define ST2086_BLUE  1
+#define LAV_RED    0
+#define LAV_GREEN  1
+#define LAV_BLUE   2
+#define ST2086_PRIM_FACTOR 50000
+            p_pic->format.mastering.primaries[ST2086_RED*2   + 0] =
+                    FROM_AVRAT(ST2086_PRIM_FACTOR, hdr_meta->display_primaries[LAV_RED][0]);
+            p_pic->format.mastering.primaries[ST2086_RED*2   + 1] =
+                    FROM_AVRAT(ST2086_PRIM_FACTOR, hdr_meta->display_primaries[LAV_RED][1]);
+            p_pic->format.mastering.primaries[ST2086_GREEN*2 + 0] =
+                    FROM_AVRAT(ST2086_PRIM_FACTOR, hdr_meta->display_primaries[LAV_GREEN][0]);
+            p_pic->format.mastering.primaries[ST2086_GREEN*2 + 1] =
+                    FROM_AVRAT(ST2086_PRIM_FACTOR, hdr_meta->display_primaries[LAV_GREEN][1]);
+            p_pic->format.mastering.primaries[ST2086_BLUE*2  + 0] =
+                    FROM_AVRAT(ST2086_PRIM_FACTOR, hdr_meta->display_primaries[LAV_BLUE][0]);
+            p_pic->format.mastering.primaries[ST2086_BLUE*2  + 1] =
+                    FROM_AVRAT(ST2086_PRIM_FACTOR, hdr_meta->display_primaries[LAV_BLUE][1]);
+            p_pic->format.mastering.white_point[0] =
+                    FROM_AVRAT(ST2086_PRIM_FACTOR, hdr_meta->white_point[0]);
+            p_pic->format.mastering.white_point[1] =
+                    FROM_AVRAT(ST2086_PRIM_FACTOR, hdr_meta->white_point[1]);
         }
 
-        if( p_block->i_flags & BLOCK_FLAG_PREROLL )
+        if ( memcmp( &p_dec->fmt_out.video.mastering,
+                     &p_pic->format.mastering,
+                     sizeof(p_pic->format.mastering) ) )
         {
-            /* Do not care about late frames when prerolling
-             * TODO avoid decoding of non reference frame
-             * (ie all B except for H264 where it depends only on nal_ref_idc) */
-            p_sys->i_late_frames = 0;
+            p_dec->fmt_out.video.mastering = p_pic->format.mastering;
+            format_changed = true;
         }
+#undef FROM_AVRAT
     }
-
-    if( !p_dec->b_pace_control && (p_sys->i_late_frames > 0) &&
-        (mdate() - p_sys->i_late_frames_start > INT64_C(5000000)) )
+#endif
+#if (LIBAVUTIL_VERSION_MICRO >= 100 && LIBAVUTIL_VERSION_INT >= AV_VERSION_INT( 55, 60, 100 ) )
+    const AVFrameSideData *metadata_lt =
+            av_frame_get_side_data( frame,
+                                    AV_FRAME_DATA_CONTENT_LIGHT_LEVEL );
+    if ( metadata_lt )
     {
-        if( p_sys->i_pts > VLC_TS_INVALID )
+        const AVContentLightMetadata *light_meta =
+                (const AVContentLightMetadata *) metadata_lt->data;
+        p_pic->format.lighting.MaxCLL = light_meta->MaxCLL;
+        p_pic->format.lighting.MaxFALL = light_meta->MaxFALL;
+        if ( memcmp( &p_dec->fmt_out.video.lighting,
+                     &p_pic->format.lighting,
+                     sizeof(p_pic->format.lighting) ) )
         {
-            p_sys->i_pts = VLC_TS_INVALID; /* To make sure we recover properly */
+            p_dec->fmt_out.video.lighting  = p_pic->format.lighting;
+            format_changed = true;
         }
-        if( p_block )
-            block_Release( p_block );
-        p_sys->i_late_frames--;
-        msg_Err( p_dec, "more than 5 seconds of late video -> "
-                 "dropping frame (computer too slow ?)" );
-        return NULL;
     }
+#endif
 
-    /* A good idea could be to decode all I pictures and see for the other */
-    if( !p_dec->b_pace_control &&
-        p_sys->b_hurry_up &&
-        (p_sys->i_late_frames > 4) )
+#if LIBAVUTIL_VERSION_CHECK( 52, 20, 0, 58, 100 )
+    const AVFrameSideData *p_stereo3d_data =
+            av_frame_get_side_data( frame,
+                                    AV_FRAME_DATA_STEREO3D );
+    if( p_stereo3d_data )
     {
-        b_drawpicture = 0;
-        if( p_sys->i_late_frames < 12 )
+        const struct AVStereo3D *stereo_data =
+                (const AVStereo3D *) p_stereo3d_data->data;
+        switch (stereo_data->type)
         {
-            p_context->skip_frame =
-                    (p_sys->i_skip_frame <= AVDISCARD_NONREF) ?
-                    AVDISCARD_NONREF : p_sys->i_skip_frame;
+        case AV_STEREO3D_SIDEBYSIDE:
+            p_pic->format.multiview_mode = MULTIVIEW_STEREO_SBS;
+            break;
+        case AV_STEREO3D_TOPBOTTOM:
+            p_pic->format.multiview_mode = MULTIVIEW_STEREO_TB;
+            break;
+        case AV_STEREO3D_FRAMESEQUENCE:
+            p_pic->format.multiview_mode = MULTIVIEW_STEREO_FRAME;
+            break;
+        case AV_STEREO3D_COLUMNS:
+            p_pic->format.multiview_mode = MULTIVIEW_STEREO_ROW;
+            break;
+        case AV_STEREO3D_LINES:
+            p_pic->format.multiview_mode = MULTIVIEW_STEREO_COL;
+            break;
+        case AV_STEREO3D_CHECKERBOARD:
+            p_pic->format.multiview_mode = MULTIVIEW_STEREO_CHECKERBOARD;
+            break;
+        default:
+        case AV_STEREO3D_2D:
+            p_pic->format.multiview_mode = MULTIVIEW_2D;
+            break;
         }
-        else
+#if LIBAVUTIL_VERSION_CHECK( 56, 7, 0, 4, 100 )
+        p_pic->format.b_multiview_right_eye_first = stereo_data->flags & AV_STEREO3D_FLAG_INVERT;
+        p_pic->format.b_multiview_left_eye = (stereo_data->view == AV_STEREO3D_VIEW_LEFT);
+
+        p_dec->fmt_out.video.b_multiview_right_eye_first = p_pic->format.b_multiview_right_eye_first;
+#endif
+
+        if (p_dec->fmt_out.video.multiview_mode != p_pic->format.multiview_mode)
         {
-            /* picture too late, won't decode
-             * but break picture until a new I, and for mpeg4 ...*/
-            p_sys->i_late_frames--; /* needed else it will never be decrease */
-            if( p_block )
-                block_Release( p_block );
-            msg_Warn( p_dec, "More than 4 late frames, dropping frame" );
-            return NULL;
+            p_dec->fmt_out.video.multiview_mode = p_pic->format.multiview_mode;
+            format_changed = true;
         }
     }
     else
+        p_pic->format.multiview_mode = p_dec->fmt_out.video.multiview_mode;
+#endif
+
+    if (format_changed && decoder_UpdateVideoFormat( p_dec ))
+        return -1;
+
+    const AVFrameSideData *p_avcc = av_frame_get_side_data( frame, AV_FRAME_DATA_A53_CC );
+    if( p_avcc )
     {
-        if( p_sys->b_hurry_up )
-            p_context->skip_frame = p_sys->i_skip_frame;
-        if( !p_block || !(p_block->i_flags & BLOCK_FLAG_PREROLL) )
-            b_drawpicture = 1;
-        else
-            b_drawpicture = 0;
+        cc_Extract( &p_sys->cc, CC_PAYLOAD_RAW, true, p_avcc->data, p_avcc->size );
+        if( p_sys->cc.b_reorder || p_sys->cc.i_data )
+        {
+            block_t *p_cc = block_Alloc( p_sys->cc.i_data );
+            if( p_cc )
+            {
+                memcpy( p_cc->p_buffer, p_sys->cc.p_data, p_sys->cc.i_data );
+                if( p_sys->cc.b_reorder )
+                    p_cc->i_dts = p_cc->i_pts = p_pic->date;
+                else
+                    p_cc->i_pts = p_cc->i_dts;
+                decoder_cc_desc_t desc;
+                desc.i_608_channels = p_sys->cc.i_608channels;
+                desc.i_708_channels = p_sys->cc.i_708channels;
+                desc.i_reorder_depth = 4;
+                decoder_QueueCc( p_dec, p_cc, &desc );
+            }
+            cc_Flush( &p_sys->cc );
+        }
     }
+    return 0;
+}
+
+/*****************************************************************************
+ * DecodeBlock: Called to decode one or more frames
+ *              drains if pp_block == NULL
+ *              tries to output only if p_block == NULL
+ *****************************************************************************/
+static int DecodeBlock( decoder_t *p_dec, block_t **pp_block )
+{
+    decoder_sys_t *p_sys = p_dec->p_sys;
+    AVCodecContext *p_context = p_sys->p_context;
+    /* Boolean if we assume that we should get valid pic as result */
+    bool b_need_output_picture = true;
+    bool b_error = false;
 
-    if( p_context->width <= 0 || p_context->height <= 0 )
+    block_t *p_block;
+
+    if( !p_context->extradata_size && p_dec->fmt_in.i_extra )
     {
-        if( p_sys->b_hurry_up )
-            p_context->skip_frame = p_sys->i_skip_frame;
+        ffmpeg_InitCodec( p_dec );
+        if( !avcodec_is_open( p_context ) )
+            OpenVideoCodec( p_dec );
     }
-    else if( !b_drawpicture )
+
+    p_block = pp_block ? *pp_block : NULL;
+    if(!p_block && !(p_sys->p_codec->capabilities & AV_CODEC_CAP_DELAY) )
+        return VLCDEC_SUCCESS;
+
+    if( !avcodec_is_open( p_context ) )
     {
-        /* It creates broken picture
-         * FIXME either our parser or ffmpeg is broken */
-#if 0
-        if( p_sys->b_hurry_up )
-            p_context->skip_frame = __MAX( p_context->skip_frame,
-                                                  AVDISCARD_NONREF );
-#endif
+        if( p_block )
+            block_Release( p_block );
+        return VLCDEC_SUCCESS;
+    }
+
+    /* Defaults that if we aren't in prerolling, we want output picture
+       same for if we are flushing (p_block==NULL) */
+    if( !p_block || !(p_block->i_flags & BLOCK_FLAG_PREROLL) )
+        b_need_output_picture = true;
+    else
+        b_need_output_picture = false;
+
+    /* Change skip_frame config only if hurry_up is enabled */
+    if( p_sys->b_hurry_up )
+    {
+        p_context->skip_frame = p_sys->i_skip_frame;
+
+        /* Check also if we should/can drop the block and move to next block
+            as trying to catchup the speed*/
+        if( p_dec->b_frame_drop_allowed )
+            p_block = filter_earlydropped_blocks( p_dec, p_block );
+    }
+
+    if( !b_need_output_picture || p_sys->framedrop == FRAMEDROP_NONREF )
+    {
+        p_context->skip_frame = __MAX( p_context->skip_frame, AVDISCARD_NONREF );
     }
 
     /*
@@ -591,199 +1010,238 @@ picture_t *DecodeVideo( decoder_t *p_dec, block_t **pp_block )
      * that the real frame size */
     if( p_block && p_block->i_buffer > 0 )
     {
-        p_sys->b_flush = ( p_block->i_flags & BLOCK_FLAG_END_OF_SEQUENCE ) != 0;
-
         p_block = block_Realloc( p_block, 0,
                             p_block->i_buffer + FF_INPUT_BUFFER_PADDING_SIZE );
         if( !p_block )
-            return NULL;
+            return VLCDEC_SUCCESS;
         p_block->i_buffer -= FF_INPUT_BUFFER_PADDING_SIZE;
         *pp_block = p_block;
         memset( p_block->p_buffer + p_block->i_buffer, 0,
                 FF_INPUT_BUFFER_PADDING_SIZE );
     }
 
-    while( !p_block || p_block->i_buffer > 0 || p_sys->b_flush )
+    bool b_drain = ( pp_block == NULL );
+    bool b_drained = false;
+
+    do
     {
-        int i_used, b_gotpicture;
-        picture_t *p_pic;
-        AVPacket pkt;
+        int i_used = 0;
 
         post_mt( p_sys );
 
-        av_init_packet( &pkt );
-        if( p_block && p_block->i_buffer > 0 )
+        if( (p_block && p_block->i_buffer > 0) || b_drain )
         {
-            pkt.data = p_block->p_buffer;
-            pkt.size = p_block->i_buffer;
-            pkt.pts = p_block->i_pts;
-            pkt.dts = p_block->i_dts;
+            AVPacket pkt;
+            av_init_packet( &pkt );
+            if( p_block && p_block->i_buffer > 0 )
+            {
+                pkt.data = p_block->p_buffer;
+                pkt.size = p_block->i_buffer;
+                pkt.pts = p_block->i_pts != VLC_TS_INVALID ? p_block->i_pts : AV_NOPTS_VALUE;
+                pkt.dts = p_block->i_dts != VLC_TS_INVALID ? p_block->i_dts : AV_NOPTS_VALUE;
+            }
+            else
+            {
+                /* Drain */
+                pkt.data = NULL;
+                pkt.size = 0;
+                b_drain = false;
+                b_drained = true;
+            }
+
+            if( !p_sys->palette_sent )
+            {
+                uint8_t *pal = av_packet_new_side_data(&pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);
+                if (pal) {
+                    memcpy(pal, p_dec->fmt_in.video.p_palette->palette, AVPALETTE_SIZE);
+                    p_sys->palette_sent = true;
+                }
+            }
+
+            /* Make sure we don't reuse the same timestamps twice */
+            if( p_block )
+            {
+                p_block->i_pts =
+                p_block->i_dts = VLC_TS_INVALID;
+            }
+
+#if LIBAVCODEC_VERSION_CHECK( 57, 0, 0xFFFFFFFFU, 64, 101 )
+            if( !b_need_output_picture )
+                pkt.flags |= AV_PKT_FLAG_DISCARD;
+#endif
+
+            int ret = avcodec_send_packet(p_context, &pkt);
+            if( ret != 0 && ret != AVERROR(EAGAIN) )
+            {
+                if (ret == AVERROR(ENOMEM) || ret == AVERROR(EINVAL))
+                {
+                    msg_Err(p_dec, "avcodec_send_packet critical error");
+                    b_error = true;
+                }
+                av_packet_unref( &pkt );
+                break;
+            }
+
+            struct frame_info_s *p_frame_info = &p_sys->frame_info[p_context->reordered_opaque % FRAME_INFO_DEPTH];
+            p_frame_info->b_eos = p_block && (p_block->i_flags & BLOCK_FLAG_END_OF_SEQUENCE);
+            p_frame_info->b_display = b_need_output_picture;
+
+            p_context->reordered_opaque++;
+            i_used = ret != AVERROR(EAGAIN) ? pkt.size : 0;
+            av_packet_unref( &pkt );
+
+            if( p_frame_info->b_eos && !b_drained )
+            {
+                 avcodec_send_packet( p_context, NULL );
+                 b_drained = true;
+            }
         }
-        else
+
+        AVFrame *frame = av_frame_alloc();
+        if (unlikely(frame == NULL))
         {
-            /* Return delayed frames if codec has CODEC_CAP_DELAY */
-            pkt.data = NULL;
-            pkt.size = 0;
+            b_error = true;
+            break;
         }
 
-#if LIBAVCODEC_VERSION_MAJOR >= 54
-        if( !p_sys->palette_sent )
+        int ret = avcodec_receive_frame(p_context, frame);
+        if( ret != 0 && ret != AVERROR(EAGAIN) )
         {
-            uint8_t *pal = av_packet_new_side_data(&pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);
-            if (pal) {
-                memcpy(pal, p_dec->fmt_in.video.p_palette->palette, AVPALETTE_SIZE);
-                p_sys->palette_sent = true;
+            if (ret == AVERROR(ENOMEM) || ret == AVERROR(EINVAL))
+            {
+                msg_Err(p_dec, "avcodec_receive_frame critical error");
+                b_error = true;
             }
+            av_frame_free(&frame);
+            if( ret == AVERROR_EOF )
+                break;
         }
-#endif
+        bool not_received_frame = ret;
+
+        wait_mt( p_sys );
 
-        /* Make sure we don't reuse the same timestamps twice */
         if( p_block )
         {
-            p_block->i_pts =
-            p_block->i_dts = VLC_TS_INVALID;
+            /* Consumed bytes */
+            p_block->p_buffer += i_used;
+            p_block->i_buffer -= i_used;
         }
 
-        i_used = avcodec_decode_video2( p_context, p_sys->p_ff_pic,
-                                       &b_gotpicture, &pkt );
-
-        wait_mt( p_sys );
+        /* Nothing to display */
+        if( not_received_frame )
+        {
+            av_frame_free(&frame);
+            if( i_used == 0 ) break;
+            continue;
+        }
 
-        if( p_sys->b_flush )
+        struct frame_info_s *p_frame_info = &p_sys->frame_info[frame->reordered_opaque % FRAME_INFO_DEPTH];
+        if( p_frame_info->b_eos )
             p_sys->b_first_frame = true;
 
-        if( p_block )
-        {
-            if( p_block->i_buffer <= 0 )
-                p_sys->b_flush = false;
+        /* Compute the PTS */
+#ifdef FF_API_PKT_PTS
+        mtime_t i_pts = frame->pts;
 
-            if( i_used < 0 )
-            {
-                if( b_drawpicture )
-                    msg_Warn( p_dec, "cannot decode one frame (%zu bytes)",
-                            p_block->i_buffer );
-                block_Release( p_block );
-                return NULL;
-            }
-            else if( (unsigned)i_used > p_block->i_buffer ||
-                    p_context->thread_count > 1 )
-            {
-                i_used = p_block->i_buffer;
-            }
+        if (i_pts == AV_NOPTS_VALUE )
+            i_pts = frame->pkt_dts;
+#else
+        mtime_t i_pts = frame->pkt_pts;
+#endif
+        if( i_pts == AV_NOPTS_VALUE )
+            i_pts = date_Get( &p_sys->pts );
 
-            /* Consumed bytes */
-            p_block->i_buffer -= i_used;
-            p_block->p_buffer += i_used;
+        /* Interpolate the next PTS */
+        if( i_pts != VLC_TS_INVALID )
+            date_Set( &p_sys->pts, i_pts );
+
+        interpolate_next_pts( p_dec, frame );
+
+        update_late_frame_count( p_dec, p_block, mdate(), i_pts, frame->reordered_opaque);
+
+        if( ( !p_sys->p_va && !frame->linesize[0] ) ||
+           ( p_dec->b_frame_drop_allowed && (frame->flags & AV_FRAME_FLAG_CORRUPT) &&
+             !p_sys->b_show_corrupted ) )
+        {
+            av_frame_free(&frame);
+            continue;
         }
 
-        /* Nothing to display */
-        if( !b_gotpicture )
+#if !LIBAVCODEC_VERSION_CHECK( 57, 0, 0xFFFFFFFFU, 64, 101 )
+        if( !p_frame_info->b_display )
         {
-            if( i_used == 0 ) break;
+            av_frame_free(&frame);
             continue;
         }
+#endif
 
-#if LIBAVCODEC_VERSION_MAJOR >= 54
         if( p_context->pix_fmt == AV_PIX_FMT_PAL8
-         && !p_dec->fmt_out.video.p_palette && p_sys->p_ff_pic->data[1] )
+         && !p_dec->fmt_out.video.p_palette )
         {
+            /* See AV_PIX_FMT_PAL8 comment in avc_GetVideoFormat(): update the
+             * fmt_out palette and change the fmt_out chroma to request a new
+             * vout */
+            assert( p_dec->fmt_out.video.i_chroma != VLC_CODEC_RGBP );
+
             video_palette_t *p_palette;
             p_palette = p_dec->fmt_out.video.p_palette
                       = malloc( sizeof(video_palette_t) );
             if( !p_palette )
             {
-                if( p_block )
-                    block_Release( p_block );
-                return NULL;
+                b_error = true;
+                av_frame_free(&frame);
+                break;
             }
             static_assert( sizeof(p_palette->palette) == AVPALETTE_SIZE,
                            "Palette size mismatch between vlc and libavutil" );
-            memcpy( p_palette->palette, p_sys->p_ff_pic->data[1],
-                    AVPALETTE_SIZE );
+            assert( frame->data[1] != NULL );
+            memcpy( p_palette->palette, frame->data[1], AVPALETTE_SIZE );
             p_palette->i_entries = AVPALETTE_COUNT;
-        }
-#endif
-
-        /* Sanity check (seems to be needed for some streams) */
-        if( p_sys->p_ff_pic->pict_type == AV_PICTURE_TYPE_B)
-        {
-            p_sys->b_has_b_frames = true;
-        }
-
-        /* Compute the PTS */
-        mtime_t i_pts =
-                    p_sys->p_ff_pic->pkt_pts;
-        if (i_pts <= VLC_TS_INVALID)
-            i_pts = p_sys->p_ff_pic->pkt_dts;
-
-        if( i_pts <= VLC_TS_INVALID )
-            i_pts = p_sys->i_pts;
-
-        /* Interpolate the next PTS */
-        if( i_pts > VLC_TS_INVALID )
-            p_sys->i_pts = i_pts;
-        if( p_sys->i_pts > VLC_TS_INVALID )
-        {
-            /* interpolate the next PTS */
-            if( p_dec->fmt_in.video.i_frame_rate > 0 &&
-                p_dec->fmt_in.video.i_frame_rate_base > 0 )
+            p_dec->fmt_out.video.i_chroma = VLC_CODEC_RGBP;
+            if( decoder_UpdateVideoFormat( p_dec ) )
             {
-                p_sys->i_pts += INT64_C(1000000) *
-                    (2 + p_sys->p_ff_pic->repeat_pict) *
-                    p_dec->fmt_in.video.i_frame_rate_base /
-                    (2 * p_dec->fmt_in.video.i_frame_rate);
+                av_frame_free(&frame);
+                continue;
             }
-            else if( p_context->time_base.den > 0 )
-            {
-                int i_tick = p_context->ticks_per_frame;
-                if( i_tick <= 0 )
-                    i_tick = 1;
-
-                p_sys->i_pts += INT64_C(1000000) *
-                    (2 + p_sys->p_ff_pic->repeat_pict) *
-                    i_tick * p_context->time_base.num /
-                    (2 * p_context->time_base.den);
-            }
-        }
-
-        /* Update frame late count (except when doing preroll) */
-        mtime_t i_display_date = 0;
-        if( !p_block || !(p_block->i_flags & BLOCK_FLAG_PREROLL) )
-            i_display_date = decoder_GetDisplayDate( p_dec, i_pts );
-
-        if( i_display_date > 0 && i_display_date <= mdate() )
-        {
-            p_sys->i_late_frames++;
-            if( p_sys->i_late_frames == 1 )
-                p_sys->i_late_frames_start = mdate();
-        }
-        else
-        {
-            p_sys->i_late_frames = 0;
         }
 
-        if( !b_drawpicture || ( !p_sys->p_va && !p_sys->p_ff_pic->linesize[0] ) )
-            continue;
+        picture_t *p_pic = frame->opaque;
+        if( p_pic == NULL )
+        {   /* When direct rendering is not used, get_format() and get_buffer()
+             * might not be called. The output video format must be set here
+             * then picture buffer can be allocated. */
+            if (p_sys->p_va == NULL
+             && lavc_UpdateVideoFormat(p_dec, p_context, p_context->pix_fmt,
+                                       p_context->pix_fmt) == 0)
+                p_pic = decoder_NewPicture(p_dec);
 
-        if( p_sys->p_va != NULL || p_sys->p_ff_pic->opaque == NULL )
-        {
-            /* Get a new picture */
-            p_pic = ffmpeg_NewPictBuf( p_dec, p_context );
             if( !p_pic )
             {
-                if( p_block )
-                    block_Release( p_block );
-                return NULL;
+                av_frame_free(&frame);
+                break;
             }
 
-            /* Fill p_picture_t from AVVideoFrame and do chroma conversion
-             * if needed */
-            ffmpeg_CopyPicture( p_dec, p_pic, p_sys->p_ff_pic );
+            /* Fill picture_t from AVFrame */
+            if( lavc_CopyPicture( p_dec, p_pic, frame ) != VLC_SUCCESS )
+            {
+                av_frame_free(&frame);
+                picture_Release( p_pic );
+                break;
+            }
         }
         else
         {
-            p_pic = (picture_t *)p_sys->p_ff_pic->opaque;
-            decoder_LinkPicture( p_dec, p_pic );
+            /* Some codecs can return the same frame multiple times. By the
+             * time that the same frame is returned a second time, it will be
+             * too late to clone the underlying picture. So clone proactively.
+             * A single picture CANNOT be queued multiple times.
+             */
+            p_pic = picture_Clone( p_pic );
+            if( unlikely(p_pic == NULL) )
+            {
+                av_frame_free(&frame);
+                break;
+            }
         }
 
         if( !p_dec->fmt_in.video.i_sar_num || !p_dec->fmt_in.video.i_sar_den )
@@ -801,33 +1259,64 @@ picture_t *DecodeVideo( decoder_t *p_dec, block_t **pp_block )
             }
         }
 
-        /* Send decoded frame to vout */
-        if( i_pts > VLC_TS_INVALID)
-        {
-            p_pic->date = i_pts;
+        p_pic->date = i_pts;
+        /* Hack to force display of still pictures */
+        p_pic->b_force = p_sys->b_first_frame;
+        p_pic->i_nb_fields = 2 + frame->repeat_pict;
+        p_pic->b_progressive = !frame->interlaced_frame;
+        p_pic->b_top_field_first = frame->top_field_first;
 
-            if( p_sys->b_first_frame )
-            {
-                /* Hack to force display of still pictures */
-                p_sys->b_first_frame = false;
-                p_pic->b_force = true;
-            }
+        if (DecodeSidedata(p_dec, frame, p_pic))
+            i_pts = VLC_TS_INVALID;
 
-            p_pic->i_nb_fields = 2 + p_sys->p_ff_pic->repeat_pict;
-            p_pic->b_progressive = !p_sys->p_ff_pic->interlaced_frame;
-            p_pic->b_top_field_first = p_sys->p_ff_pic->top_field_first;
+        av_frame_free(&frame);
 
-            return p_pic;
+        /* Send decoded frame to vout */
+        if (i_pts != VLC_TS_INVALID)
+        {
+            p_sys->b_first_frame = false;
+            decoder_QueueVideo( p_dec, p_pic );
         }
         else
+            picture_Release( p_pic );
+
+    } while( true );
+
+    /* After draining, we need to reset decoder with a flush */
+    if( b_drained )
+        avcodec_flush_buffers( p_sys->p_context );
+
+    if( p_block )
+        block_Release( p_block );
+
+    return b_error ? VLCDEC_ECRITICAL : VLCDEC_SUCCESS;
+}
+
+static int DecodeVideo( decoder_t *p_dec, block_t *p_block )
+{
+    decoder_sys_t *p_sys = p_dec->p_sys;
+    block_t **pp_block = p_block ? &p_block : NULL /* drain signal */;
+
+    if( p_block &&
+        p_block->i_flags & (BLOCK_FLAG_DISCONTINUITY|BLOCK_FLAG_CORRUPTED) )
+    {
+        /* Drain */
+        DecodeBlock( p_dec, NULL );
+        p_sys->i_late_frames = 0;
+        p_sys->i_last_output_frame = -1;
+        p_sys->framedrop = FRAMEDROP_NONE;
+
+        date_Set( &p_sys->pts, VLC_TS_INVALID ); /* To make sure we recover properly */
+        cc_Flush( &p_sys->cc );
+
+        if( p_block->i_flags & BLOCK_FLAG_CORRUPTED )
         {
-            decoder_DeletePicture( p_dec, p_pic );
+            block_Release( p_block );
+            p_block = NULL; /* output only */
         }
     }
 
-    if( p_block )
-        block_Release( p_block );
-    return NULL;
+    return DecodeBlock( p_dec, pp_block );
 }
 
 /*****************************************************************************
@@ -836,25 +1325,31 @@ picture_t *DecodeVideo( decoder_t *p_dec, block_t **pp_block )
  * This function is called when the thread ends after a successful
  * initialization.
  *****************************************************************************/
-void EndVideoDec( decoder_t *p_dec )
+void EndVideoDec( vlc_object_t *obj )
 {
+    decoder_t *p_dec = (decoder_t *)obj;
     decoder_sys_t *p_sys = p_dec->p_sys;
+    AVCodecContext *ctx = p_sys->p_context;
+    void *hwaccel_context;
 
     post_mt( p_sys );
 
     /* do not flush buffers if codec hasn't been opened (theora/vorbis/VC1) */
-    if( p_sys->p_context->codec )
-        avcodec_flush_buffers( p_sys->p_context );
+    if( avcodec_is_open( ctx ) )
+        avcodec_flush_buffers( ctx );
 
     wait_mt( p_sys );
 
-    if( p_sys->p_ff_pic )
-        avcodec_free_frame( &p_sys->p_ff_pic );
+    cc_Flush( &p_sys->cc );
+
+    hwaccel_context = ctx->hwaccel_context;
+    avcodec_free_context( &ctx );
 
     if( p_sys->p_va )
-        vlc_va_Delete( p_sys->p_va );
+        vlc_va_Delete( p_sys->p_va, &hwaccel_context );
 
     vlc_sem_destroy( &p_sys->sem_mt );
+    free( p_sys );
 }
 
 /*****************************************************************************
@@ -863,11 +1358,11 @@ void EndVideoDec( decoder_t *p_dec )
 static void ffmpeg_InitCodec( decoder_t *p_dec )
 {
     decoder_sys_t *p_sys = p_dec->p_sys;
-    int i_size = p_dec->fmt_in.i_extra;
+    size_t i_size = p_dec->fmt_in.i_extra;
 
     if( !i_size ) return;
 
-    if( p_sys->i_codec_id == AV_CODEC_ID_SVQ3 )
+    if( p_sys->p_codec->id == AV_CODEC_ID_SVQ3 )
     {
         uint8_t *p;
 
@@ -890,8 +1385,8 @@ static void ffmpeg_InitCodec( decoder_t *p_dec )
 
             while( psz < &p[p_sys->p_context->extradata_size - 8] )
             {
-                int i_size = GetDWBE( psz );
-                if( i_size <= 1 )
+                uint_fast32_t atom_size = GetDWBE( psz );
+                if( atom_size <= 1 )
                 {
                     /* FIXME handle 1 as long size */
                     break;
@@ -903,7 +1398,7 @@ static void ffmpeg_InitCodec( decoder_t *p_dec )
                     break;
                 }
 
-                psz += i_size;
+                psz += atom_size;
             }
         }
     }
@@ -922,113 +1417,51 @@ static void ffmpeg_InitCodec( decoder_t *p_dec )
     }
 }
 
-/*****************************************************************************
- * ffmpeg_CopyPicture: copy a picture from ffmpeg internal buffers to a
- *                     picture_t structure (when not in direct rendering mode).
- *****************************************************************************/
-static void ffmpeg_CopyPicture( decoder_t *p_dec,
-                                picture_t *p_pic, AVFrame *p_ff_pic )
+static void lavc_ReleaseFrame(void *opaque, uint8_t *data)
 {
-    decoder_sys_t *p_sys = p_dec->p_sys;
-
-    if( p_sys->p_va )
-    {
-        vlc_va_Extract( p_sys->p_va, p_pic, p_ff_pic->opaque,
-                        p_ff_pic->data[3] );
-    }
-    else if( FindVlcChroma( p_sys->p_context->pix_fmt ) )
-    {
-        int i_plane, i_size, i_line;
-        uint8_t *p_dst, *p_src;
-        int i_src_stride, i_dst_stride;
+    (void) data;
+    picture_t *picture = opaque;
 
-        for( i_plane = 0; i_plane < p_pic->i_planes; i_plane++ )
-        {
-            p_src  = p_ff_pic->data[i_plane];
-            p_dst = p_pic->p[i_plane].p_pixels;
-            i_src_stride = p_ff_pic->linesize[i_plane];
-            i_dst_stride = p_pic->p[i_plane].i_pitch;
-
-            i_size = __MIN( i_src_stride, i_dst_stride );
-            for( i_line = 0; i_line < p_pic->p[i_plane].i_visible_lines;
-                 i_line++ )
-            {
-                memcpy( p_dst, p_src, i_size );
-                p_src += i_src_stride;
-                p_dst += i_dst_stride;
-            }
-        }
-    }
-    else
-    {
-        const char *name = av_get_pix_fmt_name( p_sys->p_context->pix_fmt );
-        msg_Err( p_dec, "Unsupported decoded output format %d (%s)",
-                 p_sys->p_context->pix_fmt, name ? name : "unknown" );
-        p_dec->b_error = 1;
-    }
+    picture_Release(picture);
 }
 
-#if LIBAVCODEC_VERSION_MAJOR >= 55
 static int lavc_va_GetFrame(struct AVCodecContext *ctx, AVFrame *frame,
-                            int flags)
+                            picture_t *pic)
 {
     decoder_t *dec = ctx->opaque;
-    decoder_sys_t *sys = dec->p_sys;
-    vlc_va_t *va = sys->p_va;
+    decoder_sys_t *p_sys = dec->p_sys;
+    vlc_va_t *va = p_sys->p_va;
 
-    if (vlc_va_Setup(va, &ctx->hwaccel_context, &dec->fmt_out.video.i_chroma,
-                     ctx->coded_width, ctx->coded_height))
-    {
-        msg_Err(dec, "hardware acceleration setup failed");
-        return -1;
-    }
-    if (vlc_va_Get(va, &frame->opaque, &frame->data[0]))
+    if (vlc_va_Get(va, pic, &frame->data[0]))
     {
         msg_Err(dec, "hardware acceleration picture allocation failed");
+        picture_Release(pic);
         return -1;
     }
+    assert(frame->data[0] != NULL);
     /* data[0] must be non-NULL for libavcodec internal checks.
      * data[3] actually contains the format-specific surface handle. */
     frame->data[3] = frame->data[0];
 
-    frame->buf[0] = av_buffer_create(frame->data[0], 0, va->release,
-                                     frame->opaque, 0);
+    frame->buf[0] = av_buffer_create(frame->data[0], 0, lavc_ReleaseFrame, pic, 0);
     if (unlikely(frame->buf[0] == NULL))
     {
-        vlc_va_Release(va, frame->opaque, frame->data[0]);
+        lavc_ReleaseFrame(pic, frame->data[0]);
         return -1;
     }
-    assert(frame->data[0] != NULL);
-    (void) flags;
-    return 0;
-}
-
-typedef struct
-{
-    decoder_t *decoder;
-    picture_t *picture;
-} lavc_pic_ref_t;
-
-static void lavc_dr_ReleaseFrame(void *opaque, uint8_t *data)
-{
-    lavc_pic_ref_t *ref = opaque;
 
-    decoder_UnlinkPicture(ref->decoder, ref->picture);
-    free(ref);
-    (void) data;
+    frame->opaque = pic;
+    return 0;
 }
 
-static picture_t *lavc_dr_GetFrame(struct AVCodecContext *ctx,
-                                   AVFrame *frame, int flags)
+static int lavc_dr_GetFrame(struct AVCodecContext *ctx, AVFrame *frame,
+                            picture_t *pic)
 {
     decoder_t *dec = (decoder_t *)ctx->opaque;
     decoder_sys_t *sys = dec->p_sys;
 
-    if (GetVlcChroma(&dec->fmt_out.video, ctx->pix_fmt) != VLC_SUCCESS)
-        return NULL;
-    dec->fmt_out.i_codec = dec->fmt_out.video.i_chroma;
     if (ctx->pix_fmt == AV_PIX_FMT_PAL8)
-        return NULL;
+        goto error;
 
     int width = frame->width;
     int height = frame->height;
@@ -1036,74 +1469,56 @@ static picture_t *lavc_dr_GetFrame(struct AVCodecContext *ctx,
 
     avcodec_align_dimensions2(ctx, &width, &height, aligns);
 
-    picture_t *pic = ffmpeg_NewPictBuf(dec, ctx);
-    if (pic == NULL)
-        return NULL;
-
     /* Check that the picture is suitable for libavcodec */
-    if (pic->p[0].i_pitch < width * pic->p[0].i_pixel_pitch)
-    {
-        if (sys->i_direct_rendering_used != 0)
-            msg_Dbg(dec, "plane 0: pitch too small (%d/%d*%d)",
-                    pic->p[0].i_pitch, width, pic->p[0].i_pixel_pitch);
-        goto no_dr;
-    }
-
-    if (pic->p[0].i_lines < height)
-    {
-        if (sys->i_direct_rendering_used != 0)
-            msg_Dbg(dec, "plane 0: lines too few (%d/%d)",
-                    pic->p[0].i_lines, height);
-        goto no_dr;
-    }
+    assert(pic->p[0].i_pitch >= width * pic->p[0].i_pixel_pitch);
+    assert(pic->p[0].i_lines >= height);
 
     for (int i = 0; i < pic->i_planes; i++)
     {
         if (pic->p[i].i_pitch % aligns[i])
         {
-            if (sys->i_direct_rendering_used != 0)
-                msg_Dbg(dec, "plane %d: pitch not aligned (%d%%%d)",
-                        i, pic->p[i].i_pitch, aligns[i]);
-            goto no_dr;
+            if (!atomic_exchange(&sys->b_dr_failure, true))
+                msg_Warn(dec, "plane %d: pitch not aligned (%d%%%d): disabling direct rendering",
+                         i, pic->p[i].i_pitch, aligns[i]);
+            goto error;
         }
         if (((uintptr_t)pic->p[i].p_pixels) % aligns[i])
         {
-            if (sys->i_direct_rendering_used != 0)
-                msg_Warn(dec, "plane %d not aligned", i);
-            goto no_dr;
+            if (!atomic_exchange(&sys->b_dr_failure, true))
+                msg_Warn(dec, "plane %d not aligned: disabling direct rendering", i);
+            goto error;
         }
     }
 
-    /* Allocate buffer references */
+    /* Allocate buffer references and initialize planes */
+    assert(pic->i_planes < PICTURE_PLANE_MAX);
+    static_assert(PICTURE_PLANE_MAX <= AV_NUM_DATA_POINTERS, "Oops!");
+
     for (int i = 0; i < pic->i_planes; i++)
     {
-        lavc_pic_ref_t *ref = malloc(sizeof (*ref));
-        if (ref == NULL)
-            goto error;
-        ref->decoder = dec;
-        ref->picture = pic;
-        decoder_LinkPicture(dec, pic);
-
         uint8_t *data = pic->p[i].p_pixels;
         int size = pic->p[i].i_pitch * pic->p[i].i_lines;
 
-        frame->buf[i] = av_buffer_create(data, size, lavc_dr_ReleaseFrame,
-                                         ref, 0);
+        frame->data[i] = data;
+        frame->linesize[i] = pic->p[i].i_pitch;
+        frame->buf[i] = av_buffer_create(data, size, lavc_ReleaseFrame,
+                                         pic, 0);
         if (unlikely(frame->buf[i] == NULL))
         {
-            lavc_dr_ReleaseFrame(ref, data);
+            while (i > 0)
+                av_buffer_unref(&frame->buf[--i]);
             goto error;
         }
+        picture_Hold(pic);
     }
-    decoder_UnlinkPicture(dec, pic);
-    (void) flags;
-    return pic;
+
+    frame->opaque = pic;
+    /* The loop above held one reference to the picture for each plane. */
+    picture_Release(pic);
+    return 0;
 error:
-    for (unsigned i = 0; frame->buf[i] != NULL; i++)
-        av_buffer_unref(&frame->buf[i]);
-no_dr:
-    decoder_DeletePicture(dec, pic);
-    return NULL;
+    picture_Release(pic);
+    return -1;
 }
 
 /**
@@ -1124,231 +1539,55 @@ static int lavc_GetFrame(struct AVCodecContext *ctx, AVFrame *frame, int flags)
         frame->linesize[i] = 0;
         frame->buf[i] = NULL;
     }
-
-    if (sys->p_va != NULL)
-        return lavc_va_GetFrame(ctx, frame, flags);
-
     frame->opaque = NULL;
-    if (!sys->b_direct_rendering)
-        return avcodec_default_get_buffer2(ctx, frame, flags);
 
-    /* Some codecs set pix_fmt only after the 1st frame has been decoded,
-     * so we need to check for direct rendering again. */
     wait_mt(sys);
-    pic = lavc_dr_GetFrame(ctx, frame, flags);
-    if (pic == NULL)
+    if (sys->p_va == NULL)
     {
-        if (sys->i_direct_rendering_used != 0)
+        if (!sys->b_direct_rendering)
         {
-            msg_Warn(dec, "disabling direct rendering");
-            sys->i_direct_rendering_used = 0;
+            post_mt(sys);
+            return avcodec_default_get_buffer2(ctx, frame, flags);
         }
-        post_mt(sys);
-        return avcodec_default_get_buffer2(ctx, frame, flags);
-    }
-
-    if (sys->i_direct_rendering_used != 1)
-    {
-        msg_Dbg(dec, "enabling direct rendering");
-        sys->i_direct_rendering_used = 1;
-    }
-    post_mt(sys);
-
-    frame->opaque = pic;
-    static_assert(PICTURE_PLANE_MAX <= AV_NUM_DATA_POINTERS, "Oops!");
-    for (unsigned i = 0; i < PICTURE_PLANE_MAX; i++)
-    {
-        frame->data[i] = pic->p[i].p_pixels;
-        frame->linesize[i] = pic->p[i].i_pitch;
-    }
-    return 0;
-}
-#else
-static int ffmpeg_va_GetFrameBuf( struct AVCodecContext *p_context, AVFrame *p_ff_pic )
-{
-    decoder_t *p_dec = (decoder_t *)p_context->opaque;
-    decoder_sys_t *p_sys = p_dec->p_sys;
-    vlc_va_t *p_va = p_sys->p_va;
-
-    /* hwaccel_context is not present in old ffmpeg version */
-    if( vlc_va_Setup( p_va,
-                &p_context->hwaccel_context, &p_dec->fmt_out.video.i_chroma,
-                p_context->coded_width, p_context->coded_height ) )
-    {
-        msg_Err( p_dec, "vlc_va_Setup failed" );
-        return -1;
-    }
-
-    if( vlc_va_Get( p_va, &p_ff_pic->opaque, &p_ff_pic->data[0] ) )
-    {
-        msg_Err( p_dec, "vlc_va_Get failed" );
-        return -1;
-    }
-
-    p_ff_pic->data[3] = p_ff_pic->data[0];
-    p_ff_pic->type = FF_BUFFER_TYPE_USER;
-    return 0;
-}
-
-static picture_t *ffmpeg_dr_GetFrameBuf(struct AVCodecContext *p_context)
-{
-    decoder_t *p_dec = (decoder_t *)p_context->opaque;
-    decoder_sys_t *p_sys = p_dec->p_sys;
-
-    int i_width = p_context->width;
-    int i_height = p_context->height;
-    avcodec_align_dimensions( p_context, &i_width, &i_height );
-
-    picture_t *p_pic = NULL;
-    if (GetVlcChroma(&p_dec->fmt_out.video, p_context->pix_fmt) != VLC_SUCCESS)
-        goto no_dr;
-
-    if (p_context->pix_fmt == AV_PIX_FMT_PAL8)
-        goto no_dr;
-
-    p_dec->fmt_out.i_codec = p_dec->fmt_out.video.i_chroma;
-
-    p_pic = ffmpeg_NewPictBuf( p_dec, p_context );
-    if( !p_pic )
-        goto no_dr;
 
-    if( p_pic->p[0].i_pitch / p_pic->p[0].i_pixel_pitch < i_width ||
-        p_pic->p[0].i_lines < i_height )
-        goto no_dr;
-
-    for( int i = 0; i < p_pic->i_planes; i++ )
-    {
-        unsigned i_align;
-        switch( p_sys->i_codec_id )
+        /* Most unaccelerated decoders do not call get_format(), so we need to
+         * update the output video format here. The MT semaphore must be held
+         * to protect p_dec->fmt_out. */
+        if (lavc_UpdateVideoFormat(dec, ctx, ctx->pix_fmt, ctx->pix_fmt))
         {
-        case AV_CODEC_ID_SVQ1:
-        case AV_CODEC_ID_VP5:
-        case AV_CODEC_ID_VP6:
-        case AV_CODEC_ID_VP6F:
-        case AV_CODEC_ID_VP6A:
-            i_align = 16;
-            break;
-        default:
-            i_align = i == 0 ? 16 : 8;
-            break;
+            post_mt(sys);
+            return -1;
         }
-        if( p_pic->p[i].i_pitch % i_align )
-            goto no_dr;
-        if( (intptr_t)p_pic->p[i].p_pixels % i_align )
-            goto no_dr;
-    }
-
-    if( p_context->pix_fmt == AV_PIX_FMT_YUV422P )
-    {
-        if( 2 * p_pic->p[1].i_pitch != p_pic->p[0].i_pitch ||
-            2 * p_pic->p[2].i_pitch != p_pic->p[0].i_pitch )
-            goto no_dr;
     }
+    post_mt(sys);
 
-    return p_pic;
-
-no_dr:
-    if (p_pic)
-        decoder_DeletePicture( p_dec, p_pic );
-
-    return NULL;
-}
-
-static int ffmpeg_GetFrameBuf( struct AVCodecContext *p_context,
-                               AVFrame *p_ff_pic )
-{
-    decoder_t *p_dec = (decoder_t *)p_context->opaque;
-    decoder_sys_t *p_sys = p_dec->p_sys;
-
-    /* */
-    p_ff_pic->opaque = NULL;
-#if ! LIBAVCODEC_VERSION_CHECK(54, 34, 0, 79, 101)
-    p_ff_pic->pkt_pts = p_context->pkt ? p_context->pkt->pts : AV_NOPTS_VALUE;
-#endif
-#if LIBAVCODEC_VERSION_MAJOR < 54
-    p_ff_pic->age = 256*256*256*64;
-#endif
-
-    if( p_sys->p_va )
-        return ffmpeg_va_GetFrameBuf(p_context, p_ff_pic);
+    pic = decoder_NewPicture(dec);
+    if (pic == NULL)
+        return -ENOMEM;
 
-    if( !p_sys->b_direct_rendering )
-        return avcodec_default_get_buffer( p_context, p_ff_pic );
+    if (sys->p_va != NULL)
+        return lavc_va_GetFrame(ctx, frame, pic);
 
-    wait_mt( p_sys );
     /* Some codecs set pix_fmt only after the 1st frame has been decoded,
      * so we need to check for direct rendering again. */
-
-    picture_t *p_pic = ffmpeg_dr_GetFrameBuf(p_context);
-    if (!p_pic) {
-        if( p_sys->i_direct_rendering_used != 0 )
-        {
-            msg_Warn( p_dec, "disabling direct rendering" );
-            p_sys->i_direct_rendering_used = 0;
-        }
-
-        post_mt( p_sys );
-        return avcodec_default_get_buffer( p_context, p_ff_pic );
-    }
-
-    if( p_sys->i_direct_rendering_used != 1 ) {
-        msg_Dbg( p_dec, "using direct rendering" );
-        p_sys->i_direct_rendering_used = 1;
-    }
-
-    p_context->draw_horiz_band = NULL;
-    post_mt( p_sys );
-
-    p_ff_pic->opaque = (void*)p_pic;
-    p_ff_pic->type = FF_BUFFER_TYPE_USER;
-    p_ff_pic->data[0] = p_pic->p[0].p_pixels;
-    p_ff_pic->data[1] = p_pic->p[1].p_pixels;
-    p_ff_pic->data[2] = p_pic->p[2].p_pixels;
-    p_ff_pic->data[3] = NULL; /* alpha channel but I'm not sure */
-
-    p_ff_pic->linesize[0] = p_pic->p[0].i_pitch;
-    p_ff_pic->linesize[1] = p_pic->p[1].i_pitch;
-    p_ff_pic->linesize[2] = p_pic->p[2].i_pitch;
-    p_ff_pic->linesize[3] = 0;
-
-    return 0;
-}
-
-static void ffmpeg_ReleaseFrameBuf( struct AVCodecContext *p_context,
-                                    AVFrame *p_ff_pic )
-{
-    decoder_t *p_dec = (decoder_t *)p_context->opaque;
-    decoder_sys_t *p_sys = p_dec->p_sys;
-
-    if( p_sys->p_va )
-        vlc_va_Release( p_sys->p_va, p_ff_pic->opaque, p_ff_pic->data[0] );
-    else if( p_ff_pic->opaque )
-        decoder_UnlinkPicture( p_dec, (picture_t*)p_ff_pic->opaque);
-    else if( p_ff_pic->type == FF_BUFFER_TYPE_INTERNAL )
-        /* We can end up here without the AVFrame being allocated by
-         * avcodec_default_get_buffer() if VA is used and the frame is
-         * released when the decoder is closed
-         */
-        avcodec_default_release_buffer( p_context, p_ff_pic );
-
-    for( int i = 0; i < 4; i++ )
-        p_ff_pic->data[i] = NULL;
+    int ret = lavc_dr_GetFrame(ctx, frame, pic);
+    if (ret)
+        ret = avcodec_default_get_buffer2(ctx, frame, flags);
+    return ret;
 }
-#endif
 
 static enum PixelFormat ffmpeg_GetFormat( AVCodecContext *p_context,
                                           const enum PixelFormat *pi_fmt )
 {
     decoder_t *p_dec = p_context->opaque;
     decoder_sys_t *p_sys = p_dec->p_sys;
-    vlc_va_t *p_va = p_sys->p_va;
-
-    if( p_va != NULL )
-        vlc_va_Delete( p_va );
+    video_format_t fmt;
 
     /* Enumerate available formats */
+    enum PixelFormat swfmt = avcodec_default_get_format(p_context, pi_fmt);
     bool can_hwaccel = false;
-    for( size_t i = 0; pi_fmt[i] != AV_PIX_FMT_NONE; i++ )
+
+    for (size_t i = 0; pi_fmt[i] != AV_PIX_FMT_NONE; i++)
     {
         const AVPixFmtDescriptor *dsc = av_pix_fmt_desc_get(pi_fmt[i]);
         if (dsc == NULL)
@@ -1361,53 +1600,113 @@ static enum PixelFormat ffmpeg_GetFormat( AVCodecContext *p_context,
             can_hwaccel = true;
     }
 
+    /* If the format did not actually change (e.g. seeking), try to reuse the
+     * existing output format, and if present, hardware acceleration back-end.
+     * This avoids resetting the pipeline downstream. This also avoids
+     * needlessly probing for hardware acceleration support. */
+    if (p_sys->pix_fmt != AV_PIX_FMT_NONE
+     && lavc_GetVideoFormat(p_dec, &fmt, p_context, p_sys->pix_fmt, swfmt) == 0
+     && fmt.i_width == p_dec->fmt_out.video.i_width
+     && fmt.i_height == p_dec->fmt_out.video.i_height
+     && p_context->profile == p_sys->profile
+     && p_context->level <= p_sys->level)
+    {
+        for (size_t i = 0; pi_fmt[i] != AV_PIX_FMT_NONE; i++)
+            if (pi_fmt[i] == p_sys->pix_fmt)
+            {
+                msg_Dbg(p_dec, "reusing decoder output format %d", pi_fmt[i]);
+                return p_sys->pix_fmt;
+            }
+    }
+
+    if (p_sys->p_va != NULL)
+    {
+        msg_Err(p_dec, "existing hardware acceleration cannot be reused");
+        vlc_va_Delete(p_sys->p_va, &p_context->hwaccel_context);
+        p_sys->p_va = NULL;
+    }
+
+    p_sys->profile = p_context->profile;
+    p_sys->level = p_context->level;
+
     if (!can_hwaccel)
-        goto end;
+        return swfmt;
 
-    /* Profile and level information is needed now.
-     * TODO: avoid code duplication with avcodec.c */
-    if( p_context->profile != FF_PROFILE_UNKNOWN)
-        p_dec->fmt_in.i_profile = p_context->profile;
-    if( p_context->level != FF_LEVEL_UNKNOWN)
-        p_dec->fmt_in.i_level = p_context->level;
+#if (LIBAVCODEC_VERSION_MICRO >= 100) \
+  && (LIBAVCODEC_VERSION_INT < AV_VERSION_INT(57, 83, 101))
+    if (p_context->active_thread_type)
+    {
+        msg_Warn(p_dec, "thread type %d: disabling hardware acceleration",
+                 p_context->active_thread_type);
+        return swfmt;
+    }
+#endif
+
+    wait_mt(p_sys);
 
-    p_va = vlc_va_New( VLC_OBJECT(p_dec), p_context, &p_dec->fmt_in );
-    if( p_va == NULL )
-        goto end;
+    static const enum PixelFormat hwfmts[] =
+    {
+#ifdef _WIN32
+#if LIBAVUTIL_VERSION_CHECK(54, 13, 1, 24, 100)
+        AV_PIX_FMT_D3D11VA_VLD,
+#endif
+        AV_PIX_FMT_DXVA2_VLD,
+#endif
+        AV_PIX_FMT_VAAPI_VLD,
+#if (LIBAVUTIL_VERSION_INT >= AV_VERSION_INT(52, 4, 0))
+        AV_PIX_FMT_VDPAU,
+#endif
+        AV_PIX_FMT_NONE,
+    };
 
-    for( size_t i = 0; pi_fmt[i] != AV_PIX_FMT_NONE; i++ )
+    for( size_t i = 0; hwfmts[i] != AV_PIX_FMT_NONE; i++ )
     {
-        if( p_va->pix_fmt != pi_fmt[i] )
+        enum PixelFormat hwfmt = AV_PIX_FMT_NONE;
+        for( size_t j = 0; hwfmt == AV_PIX_FMT_NONE && pi_fmt[j] != AV_PIX_FMT_NONE; j++ )
+            if( hwfmts[i] == pi_fmt[j] )
+                hwfmt = hwfmts[i];
+
+        if( hwfmt == AV_PIX_FMT_NONE )
             continue;
 
-        /* We try to call vlc_va_Setup when possible to detect errors when
-         * possible (later is too late) */
-        if( p_context->coded_width > 0 && p_context->coded_height > 0
-         && vlc_va_Setup( p_va, &p_context->hwaccel_context,
-                          &p_dec->fmt_out.video.i_chroma,
-                          p_context->coded_width, p_context->coded_height ) )
+        p_dec->fmt_out.video.i_chroma = vlc_va_GetChroma(hwfmt, swfmt);
+        if (p_dec->fmt_out.video.i_chroma == 0)
+            continue; /* Unknown brand of hardware acceleration */
+        if (p_context->width == 0 || p_context->height == 0)
+        {   /* should never happen */
+            msg_Err(p_dec, "unspecified video dimensions");
+            continue;
+        }
+        const AVPixFmtDescriptor *dsc = av_pix_fmt_desc_get(hwfmt);
+        msg_Dbg(p_dec, "trying format %s", dsc ? dsc->name : "unknown");
+        if (lavc_UpdateVideoFormat(p_dec, p_context, hwfmt, swfmt))
+            continue; /* Unsupported brand of hardware acceleration */
+        post_mt(p_sys);
+
+        picture_t *test_pic = decoder_NewPicture(p_dec);
+        assert(!test_pic || test_pic->format.i_chroma == p_dec->fmt_out.video.i_chroma);
+        vlc_va_t *va = vlc_va_New(VLC_OBJECT(p_dec), p_context, hwfmt,
+                                  &p_dec->fmt_in,
+                                  test_pic ? test_pic->p_sys : NULL);
+        if (test_pic)
+            picture_Release(test_pic);
+        if (va == NULL)
         {
-            msg_Err( p_dec, "acceleration setup failure" );
-            break;
+            wait_mt(p_sys);
+            continue; /* Unsupported codec profile or such */
         }
 
-        if( p_va->description )
-            msg_Info( p_dec, "Using %s for hardware decoding.",
-                      p_va->description );
+        if (va->description != NULL)
+            msg_Info(p_dec, "Using %s for hardware decoding", va->description);
 
-        /* FIXME this will disable direct rendering
-         * even if a new pixel format is renegotiated
-         */
-        p_sys->b_direct_rendering = false;
-        p_sys->p_va = p_va;
+        p_sys->p_va = va;
+        p_sys->pix_fmt = hwfmt;
         p_context->draw_horiz_band = NULL;
-        return pi_fmt[i];
+        return hwfmt;
     }
 
-    vlc_va_Delete( p_va );
-
-end:
+    post_mt(p_sys);
     /* Fallback to default behaviour */
-    p_sys->p_va = NULL;
-    return avcodec_default_get_format( p_context, pi_fmt );
+    p_sys->pix_fmt = swfmt;
+    return swfmt;
 }
