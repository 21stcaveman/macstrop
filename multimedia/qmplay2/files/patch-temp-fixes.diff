diff --git a/src/modules/FFmpeg/FFDecVTB.cpp b/src/modules/FFmpeg/FFDecVTB.cpp
index 618347d2a8f5efc73cfaa62eba07abacbec52bf8..2f13caa2674fc3b508e21c38bbc24024e90bcf9f 100644
--- a/src/modules/FFmpeg/FFDecVTB.cpp
+++ b/src/modules/FFmpeg/FFDecVTB.cpp
@@ -299,19 +299,22 @@ bool FFDecVTB::open(StreamInfo &streamInfo, VideoWriter *writer)
 		return false;
 
 	/* Workaround: check if decoder can be used. */
-	const int extradataSize = codec_ctx->extradata_size;
-	if (codec->id == AV_CODEC_ID_H264 || codec->id == AV_CODEC_ID_HEVC)
+	if (codec_ctx->internal)
 	{
-		// Prevent crash for H.264 codec. HEVC is currently unimplemented in FFmpeg.
-		codec_ctx->extradata_size = 0;
-	}
-	int ret = av_videotoolbox_default_init(codec_ctx);
-	av_videotoolbox_default_free(codec_ctx);
-	codec_ctx->extradata_size = extradataSize;
-	if (ret != 0 && ret != AVERROR(ENOSYS))
-	{
-		// For H.264 we have ENOSYS, because extradata doesn't exist. This is the only way to check it before decoding first video frame.
-		return false;
+		const int extradataSize = codec_ctx->extradata_size;
+		if (codec->id == AV_CODEC_ID_H264 || codec->id == AV_CODEC_ID_HEVC)
+		{
+			// Prevent crash for H.264 codec. HEVC is currently unimplemented in FFmpeg.
+			codec_ctx->extradata_size = 0;
+		}
+		int ret = av_videotoolbox_default_init(codec_ctx);
+		av_videotoolbox_default_free(codec_ctx);
+		codec_ctx->extradata_size = extradataSize;
+		if (ret != 0 && ret != AVERROR(ENOSYS))
+		{
+			// For H.264 we have ENOSYS, because extradata doesn't exist. This is the only way to check it before decoding first video frame.
+			return false;
+		}
 	}
 	/**/
 
